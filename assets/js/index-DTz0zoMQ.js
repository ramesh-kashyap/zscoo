import {
    w as ou,
    _ as E,
    e as T,
    B as gt,
    a as sy,
    m as Wo,
    b as $s,
    c as vr,
    d as Of,
    f as zf,
    g as G,
    h as Dt,
    n as ua,
    j as rt,
    k as wt,
    l as tt,
    p as H,
    o as ly,
    s as uy,
    q as vy,
    r as hy,
    t as Nf,
    u as Gf,
    v as su,
    x as cy,
    y as Bf,
    z as Lt,
    A as Yt,
    C as ft,
    D as yt,
    E as Hf,
    T as Er,
    F as xt,
    G as Re,
    Z as ge,
    H as _a,
    I as fy,
    J as lu,
    K as py,
    L as Ff,
    M as q,
    N as dy,
    O as gy,
    P as W,
    Q as Wf,
    R as $f,
    S as te,
    U as Zs,
    V as yy,
    W as Pt,
    X as Zf,
    Y as my,
    $ as xy,
    a0 as Sy,
    a1 as Ki,
    a2 as _y,
    a3 as ba,
    a4 as by,
    a5 as ot,
    a6 as wy,
    a7 as Ay,
    a8 as Ty,
    a9 as Cy,
    aa as Dy,
    ab as Iy,
    ac as Ly,
    ad as Uf,
    ae as Us,
    af as My,
    ag as Py,
    ah as Ry,
    ai as Ey,
    aj as B,
    ak as St,
    al as kr,
    am as ky,
    an as pe,
    ao as Yf,
    ap as $o,
    aq as Ys,
    ar as Zo,
    as as Xf,
    at as Vy,
    au as Oy,
    av as zy,
    aw as Ny,
    ax as Ja,
    ay as Gy,
    az as By,
    aA as Nt,
    aB as ct,
    aC as Hy,
    aD as dr,
    aE as U,
    aF as Et,
    aG as Vt,
    aH as Br,
    aI as Hr,
    aJ as gr,
    aK as Gt,
    aL as jr,
    aM as Xt,
    aN as wa,
    aO as Tt,
    aP as Fr,
    aQ as Na,
    aR as Ga,
    aS as Wr,
    aT as or,
    aU as uu,
    aV as vu,
    aW as $r,
    aX as at,
    aY as ee,
    aZ as Uo,
    a_ as At,
    a$ as Ti,
    b0 as ut,
    b1 as Fy,
    b2 as Wy,
    b3 as qi,
    b4 as Aa,
    b5 as Ba,
    b6 as $y,
    b7 as Zy,
    b8 as Uy,
    b9 as ji,
    ba as Yy,
    bb as Ct,
    bc as Kt,
    bd as le,
    be as Ji,
    bf as Xy,
    bg as Ky,
    bh as Qi,
    bi as tn,
    bj as qy,
    bk as ye,
    bl as Ut,
    bm as kt,
    bn as jy,
    bo as en,
    bp as Yo,
    bq as Jy,
    br as Xo,
    bs as Zr,
    bt as Qy,
    bu as K,
    bv as Rt,
    bw as It,
    bx as Q,
    by as pt,
    bz as ze,
    bA as rn,
    bB as Jt,
    bC as Ko,
    bD as j,
    bE as an,
    bF as F,
    bG as hu,
    bH as Ne,
    bI as N,
    bJ as nn,
    bK as tm,
    bL as de,
    bM as $e,
    bN as em,
    bO as rm,
    bP as Kf,
    bQ as Ha,
    bR as qf,
    bS as Ge,
    bT as yr,
    bU as jf,
    bV as hr,
    bW as Ur,
    bX as on,
    bY as sn,
    bZ as am,
    b_ as Fa,
    b$ as ln,
    c0 as Jf,
    c1 as qt,
    c2 as im,
    c3 as Ft,
    c4 as Xs,
    c5 as un,
    c6 as Qf,
    c7 as Ks,
    c8 as nm,
    c9 as vn,
    ca as qo,
    cb as om,
    cc as tp,
    cd as Se,
    ce as qs,
    cf as Qt,
    cg as jo,
    ch as Wt,
    ci as hn,
    cj as sm,
    ck as mt,
    cl as ep,
    cm as Be,
    cn as Ci,
    co as cu,
    cp as va,
    cq as fu,
    cr as lm,
    cs as An,
    ct as xi,
    cu as ht,
    cv as rp,
    cx as ya,
    cy as Di,
    cz as pu,
    cA as Wa,
    cB as Ve,
    cC as $a,
    cD as um,
    cE as vm,
    cF as Vr,
    cG as du,
    cH as hm,
    cI as Jo,
    cJ as js,
    cK as cm,
    cL as ap,
    cM as fm,
    cN as ip,
    cO as Js,
    cP as pm,
    cQ as dm,
    cR as gu,
    cS as gm,
    cT as yu,
    cU as cr,
    cV as _e,
    cW as ym,
    cX as Qs,
    cY as mm,
    cZ as xm,
    c_ as Jr,
    c$ as Ta,
    d0 as we,
    d1 as oe,
    d2 as tl,
    d3 as zr,
    d4 as Sm,
    d5 as Qo,
    d6 as ts,
    d7 as _m,
    d8 as Qr,
    d9 as Tn,
    da as np,
    db as bt,
    dc as cn,
    dd as Cn,
    de as bm,
    df as ha,
    dg as wm,
    dh as mu,
    di as Am,
    dj as Tm,
    dk as mr,
    dl as xu,
    dm as Cm,
    dn as Dm,
    dp as Su,
    dq as Im,
    dr as Lm,
    ds as Mm,
    dt as Ca,
    du as Pm,
    dv as op,
    dw as Za,
    dx as _u,
    dy as Rm,
    dz as sp,
    dA as Em,
    dB as lp,
    dC as fn,
    dD as pn,
    dE as el,
    dF as up,
    dG as km,
    dH as xe,
    dI as Vm,
    dJ as Om,
    dK as bu,
    dL as zm,
    dM as Nm,
    dN as Gm,
    dO as Bm,
    dP as Hm,
    dQ as Fm,
    dR as Wm,
    dS as $m,
    dT as sr,
    dU as es,
    dV as wu,
    dW as vp,
    dX as Zm,
    dY as Um,
    dZ as hp,
    d_ as Ym,
    d$ as cp,
    e0 as Xm,
    e1 as Km,
    e2 as Au,
    e3 as Tu,
    e4 as qm,
    e5 as jm,
    e6 as Jm,
    e7 as Qm,
    e8 as Dn,
    e9 as fp,
    ea as pp,
    eb as Qa,
    ec as t0,
    ed as dp,
    ee as Nr,
    ef as rs,
    eg as e0,
    eh as r0,
    ei as a0,
    ej as i0,
    ek as Ii,
    el as n0,
    em as o0,
    en as dn,
    eo as s0,
    ep as l0,
    eq as u0,
    er as v0,
    es as Cu,
    et as gp,
    eu as h0,
    ev as c0,
    ew as f0,
    ex as p0,
    ey as d0,
    ez as Du,
    eA as g0,
    eB as Li,
    eC as rl,
    eD as y0,
    eE as In,
    eF as m0,
    eG as x0,
    eH as S0,
    eI as _0
} from "./echartsCharts-RcjN-jxb.js";
var b0 = 1e-8;

function Iu(a, e) {
    return Math.abs(a - e) < b0
}

function rr(a, e, t) {
    var r = 0,
        i = a[0];
    if (!i) return !1;
    for (var n = 1; n < a.length; n++) {
        var o = a[n];
        r += ou(i[0], i[1], o[0], o[1], e, t), i = o
    }
    var s = a[0];
    return (!Iu(i[0], s[0]) || !Iu(i[1], s[1])) && (r += ou(i[0], i[1], s[0], s[1], e, t)), r !== 0
}
var w0 = [];

function Ln(a, e) {
    for (var t = 0; t < a.length; t++) vr(a[t], a[t], e)
}

function Lu(a, e, t, r) {
    for (var i = 0; i < a.length; i++) {
        var n = a[i];
        r && (n = r.project(n)), n && isFinite(n[0]) && isFinite(n[1]) && (Of(e, e, n), zf(t, t, n))
    }
}

function A0(a) {
    for (var e = 0, t = 0, r = 0, i = a.length, n = a[i - 1][0], o = a[i - 1][1], s = 0; s < i; s++) {
        var l = a[s][0],
            u = a[s][1],
            v = n * u - l * o;
        e += v, t += (n + l) * v, r += (o + u) * v, n = l, o = u
    }
    return e ? [t / e / 3, r / e / 3, e] : [a[0][0] || 0, a[0][1] || 0]
}
var yp = function () {
        function a(e) {
            this.name = e
        }
        return a.prototype.setCenter = function (e) {
            this._center = e
        }, a.prototype.getCenter = function () {
            var e = this._center;
            return e || (e = this._center = this.calcCenter()), e
        }, a
    }(),
    Mu = function () {
        function a(e, t) {
            this.type = "polygon", this.exterior = e, this.interiors = t
        }
        return a
    }(),
    Pu = function () {
        function a(e) {
            this.type = "linestring", this.points = e
        }
        return a
    }(),
    mp = function (a) {
        E(e, a);

        function e(t, r, i) {
            var n = a.call(this, t) || this;
            return n.type = "geoJSON", n.geometries = r, n._center = i && [i[0], i[1]], n
        }
        return e.prototype.calcCenter = function () {
            for (var t = this.geometries, r, i = 0, n = 0; n < t.length; n++) {
                var o = t[n],
                    s = o.exterior,
                    l = s && s.length;
                l > i && (r = o, i = l)
            }
            if (r) return A0(r.exterior);
            var u = this.getBoundingRect();
            return [u.x + u.width / 2, u.y + u.height / 2]
        }, e.prototype.getBoundingRect = function (t) {
            var r = this._rect;
            if (r && !t) return r;
            var i = [1 / 0, 1 / 0],
                n = [-1 / 0, -1 / 0],
                o = this.geometries;
            return T(o, function (s) {
                s.type === "polygon" ? Lu(s.exterior, i, n, t) : T(s.points, function (l) {
                    Lu(l, i, n, t)
                })
            }), isFinite(i[0]) && isFinite(i[1]) && isFinite(n[0]) && isFinite(n[1]) || (i[0] = i[1] = n[0] = n[1] = 0), r = new gt(i[0], i[1], n[0] - i[0], n[1] - i[1]), t || (this._rect = r), r
        }, e.prototype.contain = function (t) {
            var r = this.getBoundingRect(),
                i = this.geometries;
            if (!r.contain(t[0], t[1])) return !1;
            t: for (var n = 0, o = i.length; n < o; n++) {
                var s = i[n];
                if (s.type === "polygon") {
                    var l = s.exterior,
                        u = s.interiors;
                    if (rr(l, t[0], t[1])) {
                        for (var v = 0; v < (u ? u.length : 0); v++)
                            if (rr(u[v], t[0], t[1])) continue t;
                        return !0
                    }
                }
            }
            return !1
        }, e.prototype.transformTo = function (t, r, i, n) {
            var o = this.getBoundingRect(),
                s = o.width / o.height;
            i ? n || (n = i / s) : i = s * n;
            for (var l = new gt(t, r, i, n), u = o.calculateTransform(l), v = this.geometries, h = 0; h < v.length; h++) {
                var c = v[h];
                c.type === "polygon" ? (Ln(c.exterior, u), T(c.interiors, function (f) {
                    Ln(f, u)
                })) : T(c.points, function (f) {
                    Ln(f, u)
                })
            }
            o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2]
        }, e.prototype.cloneShallow = function (t) {
            t == null && (t = this.name);
            var r = new e(t, this.geometries, this._center);
            return r._rect = this._rect, r.transformTo = null, r
        }, e
    }(yp),
    T0 = function (a) {
        E(e, a);

        function e(t, r) {
            var i = a.call(this, t) || this;
            return i.type = "geoSVG", i._elOnlyForCalculate = r, i
        }
        return e.prototype.calcCenter = function () {
            for (var t = this._elOnlyForCalculate, r = t.getBoundingRect(), i = [r.x + r.width / 2, r.y + r.height / 2], n = sy(w0), o = t; o && !o.isGeoSVGGraphicRoot;) Wo(n, o.getLocalTransform(), n), o = o.parent;
            return $s(n, n), vr(i, i, n), i
        }, e
    }(yp);

function C0(a) {
    if (!a.UTF8Encoding) return a;
    var e = a,
        t = e.UTF8Scale;
    t == null && (t = 1024);
    var r = e.features;
    return T(r, function (i) {
        var n = i.geometry,
            o = n.encodeOffsets,
            s = n.coordinates;
        if (o) switch (n.type) {
            case "LineString":
                n.coordinates = xp(s, o, t);
                break;
            case "Polygon":
                Mn(s, o, t);
                break;
            case "MultiLineString":
                Mn(s, o, t);
                break;
            case "MultiPolygon":
                T(s, function (l, u) {
                    return Mn(l, o[u], t)
                })
        }
    }), e.UTF8Encoding = !1, e
}

function Mn(a, e, t) {
    for (var r = 0; r < a.length; r++) a[r] = xp(a[r], e[r], t)
}

function xp(a, e, t) {
    for (var r = [], i = e[0], n = e[1], o = 0; o < a.length; o += 2) {
        var s = a.charCodeAt(o) - 64,
            l = a.charCodeAt(o + 1) - 64;
        s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += n, i = s, n = l, r.push([s / t, l / t])
    }
    return r
}

function D0(a, e) {
    return a = C0(a), G(Dt(a.features, function (t) {
        return t.geometry && t.properties && t.geometry.coordinates.length > 0
    }), function (t) {
        var r = t.properties,
            i = t.geometry,
            n = [];
        switch (i.type) {
            case "Polygon":
                var o = i.coordinates;
                n.push(new Mu(o[0], o.slice(1)));
                break;
            case "MultiPolygon":
                T(i.coordinates, function (l) {
                    l[0] && n.push(new Mu(l[0], l.slice(1)))
                });
                break;
            case "LineString":
                n.push(new Pu([i.coordinates]));
                break;
            case "MultiLineString":
                n.push(new Pu(i.coordinates))
        }
        var s = new mp(r[e || "name"], n, r.cp);
        return s.properties = r, s
    })
}

function I0(a) {
    if (a) {
        for (var e = [], t = 0; t < a.length; t++) e.push(a[t].slice());
        return e
    }
}

function L0(a, e) {
    var t = a.label,
        r = e && e.getTextGuideLine();
    return {
        dataIndex: a.dataIndex,
        dataType: a.dataType,
        seriesIndex: a.seriesModel.seriesIndex,
        text: a.label.style.text,
        rect: a.hostRect,
        labelRect: a.rect,
        align: t.style.align,
        verticalAlign: t.style.verticalAlign,
        labelLinePoints: I0(r && r.shape.points)
    }
}
var Ru = ["align", "verticalAlign", "width", "height", "fontSize"],
    Ht = new Er,
    Pn = xt(),
    M0 = xt();

function ti(a, e, t) {
    for (var r = 0; r < t.length; r++) {
        var i = t[r];
        e[i] != null && (a[i] = e[i])
    }
}
var ei = ["x", "y", "rotation"],
    P0 = function () {
        function a() {
            this._labelList = [], this._chartViewList = []
        }
        return a.prototype.clearLabels = function () {
            this._labelList = [], this._chartViewList = []
        }, a.prototype._addLabel = function (e, t, r, i, n) {
            var o = i.style,
                s = i.__hostTarget,
                l = s.textConfig || {},
                u = i.getComputedTransform(),
                v = i.getBoundingRect().plain();
            gt.applyTransform(v, v, u), u ? Ht.setLocalTransform(u) : (Ht.x = Ht.y = Ht.rotation = Ht.originX = Ht.originY = 0, Ht.scaleX = Ht.scaleY = 1), Ht.rotation = ua(Ht.rotation);
            var h = i.__hostTarget,
                c;
            if (h) {
                c = h.getBoundingRect().plain();
                var f = h.getComputedTransform();
                gt.applyTransform(c, c, f)
            }
            var p = c && h.getTextGuideLine();
            this._labelList.push({
                label: i,
                labelLine: p,
                seriesModel: r,
                dataIndex: e,
                dataType: t,
                layoutOption: n,
                computedLayoutOption: null,
                rect: v,
                hostRect: c,
                priority: c ? c.width * c.height : 0,
                defaultAttr: {
                    ignore: i.ignore,
                    labelGuideIgnore: p && p.ignore,
                    x: Ht.x,
                    y: Ht.y,
                    scaleX: Ht.scaleX,
                    scaleY: Ht.scaleY,
                    rotation: Ht.rotation,
                    style: {
                        x: o.x,
                        y: o.y,
                        align: o.align,
                        verticalAlign: o.verticalAlign,
                        width: o.width,
                        height: o.height,
                        fontSize: o.fontSize
                    },
                    cursor: i.cursor,
                    attachedPos: l.position,
                    attachedRot: l.rotation
                }
            })
        }, a.prototype.addLabelsOfSeries = function (e) {
            var t = this;
            this._chartViewList.push(e);
            var r = e.__model,
                i = r.get("labelLayout");
            (rt(i) || wt(i).length) && e.group.traverse(function (n) {
                if (n.ignore) return !0;
                var o = n.getTextContent(),
                    s = tt(n);
                o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, r, o, i)
            })
        }, a.prototype.updateLayoutConfig = function (e) {
            var t = e.getWidth(),
                r = e.getHeight();

            function i(m, S) {
                return function () {
                    su(m, S)
                }
            }
            for (var n = 0; n < this._labelList.length; n++) {
                var o = this._labelList[n],
                    s = o.label,
                    l = s.__hostTarget,
                    u = o.defaultAttr,
                    v = void 0;
                rt(o.layoutOption) ? v = o.layoutOption(L0(o, l)) : v = o.layoutOption, v = v || {}, o.computedLayoutOption = v;
                var h = Math.PI / 180;
                l && l.setTextConfig({
                    local: !1,
                    position: v.x != null || v.y != null ? null : u.attachedPos,
                    rotation: v.rotate != null ? v.rotate * h : u.attachedRot,
                    offset: [v.dx || 0, v.dy || 0]
                });
                var c = !1;
                if (v.x != null ? (s.x = H(v.x, t), s.setStyle("x", 0), c = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), v.y != null ? (s.y = H(v.y, r), s.setStyle("y", 0), c = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), v.labelLinePoints) {
                    var f = l.getTextGuideLine();
                    f && (f.setShape({
                        points: v.labelLinePoints
                    }), c = !1)
                }
                var p = Pn(s);
                p.needsUpdateLabelLine = c, s.rotation = v.rotate != null ? v.rotate * h : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
                for (var d = 0; d < Ru.length; d++) {
                    var g = Ru[d];
                    s.setStyle(g, v[g] != null ? v[g] : u.style[g])
                }
                if (v.draggable) {
                    if (s.draggable = !0, s.cursor = "move", l) {
                        var y = o.seriesModel;
                        if (o.dataIndex != null) {
                            var x = o.seriesModel.getData(o.dataType);
                            y = x.getItemModel(o.dataIndex)
                        }
                        s.on("drag", i(l, y.getModel("labelLine")))
                    }
                } else s.off("drag"), s.cursor = u.cursor
            }
        }, a.prototype.layout = function (e) {
            var t = e.getWidth(),
                r = e.getHeight(),
                i = ly(this._labelList),
                n = Dt(i, function (l) {
                    return l.layoutOption.moveOverlap === "shiftX"
                }),
                o = Dt(i, function (l) {
                    return l.layoutOption.moveOverlap === "shiftY"
                });
            uy(n, 0, t), vy(o, 0, r);
            var s = Dt(i, function (l) {
                return l.layoutOption.hideOverlap
            });
            hy(s)
        }, a.prototype.processLabelsOverall = function () {
            var e = this;
            T(this._chartViewList, function (t) {
                var r = t.__model,
                    i = t.ignoreLabelLineUpdate,
                    n = r.isAnimationEnabled();
                t.group.traverse(function (o) {
                    if (o.ignore && !o.forceLabelAnimation) return !0;
                    var s = !i,
                        l = o.getTextContent();
                    !s && l && (s = Pn(l).needsUpdateLabelLine), s && e._updateLabelLine(o, r), n && e._animateLabels(o, r)
                })
            })
        }, a.prototype._updateLabelLine = function (e, t) {
            var r = e.getTextContent(),
                i = tt(e),
                n = i.dataIndex;
            if (r && n != null) {
                var o = t.getData(i.dataType),
                    s = o.getItemModel(n),
                    l = {},
                    u = o.getItemVisual(n, "style");
                if (u) {
                    var v = o.getVisual("drawType");
                    l.stroke = u[v]
                }
                var h = s.getModel("labelLine");
                Nf(e, Gf(s), l), su(e, h)
            }
        }, a.prototype._animateLabels = function (e, t) {
            var r = e.getTextContent(),
                i = e.getTextGuideLine();
            if (r && (e.forceLabelAnimation || !r.ignore && !r.invisible && !e.disableLabelAnimation && !cy(e))) {
                var n = Pn(r),
                    o = n.oldLayout,
                    s = tt(e),
                    l = s.dataIndex,
                    u = {
                        x: r.x,
                        y: r.y,
                        rotation: r.rotation
                    },
                    v = t.getData(s.dataType);
                if (o) {
                    r.attr(o);
                    var c = e.prevStates;
                    c && (ft(c, "select") >= 0 && r.attr(n.oldLayoutSelect), ft(c, "emphasis") >= 0 && r.attr(n.oldLayoutEmphasis)), yt(r, u, t, l)
                } else if (r.attr(u), !Bf(r).valueAnimation) {
                    var h = Lt(r.style.opacity, 1);
                    r.style.opacity = 0, Yt(r, {
                        style: {
                            opacity: h
                        }
                    }, t, l)
                }
                if (n.oldLayout = u, r.states.select) {
                    var f = n.oldLayoutSelect = {};
                    ti(f, u, ei), ti(f, r.states.select, ei)
                }
                if (r.states.emphasis) {
                    var p = n.oldLayoutEmphasis = {};
                    ti(p, u, ei), ti(p, r.states.emphasis, ei)
                }
                Hf(r, l, v, t, t)
            }
            if (i && !i.ignore && !i.invisible) {
                var n = M0(i),
                    o = n.oldLayout,
                    d = {
                        points: i.shape.points
                    };
                o ? (i.attr({
                    shape: o
                }), yt(i, {
                    shape: d
                }, t)) : (i.setShape(d), i.style.strokePercent = 0, Yt(i, {
                    style: {
                        strokePercent: 1
                    }
                }, t)), n.oldLayout = d
            }
        }, a
    }(),
    Rn = xt();

function R0(a) {
    a.registerUpdateLifecycle("series:beforeupdate", function (e, t, r) {
        var i = Rn(t).labelManager;
        i || (i = Rn(t).labelManager = new P0), i.clearLabels()
    }), a.registerUpdateLifecycle("series:layoutlabels", function (e, t, r) {
        var i = Rn(t).labelManager;
        r.updatedSeries.forEach(function (n) {
            i.addLabelsOfSeries(t.getViewOfSeriesModel(n))
        }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall()
    })
}
var En = Math.sin,
    kn = Math.cos,
    Sp = Math.PI,
    Ye = Math.PI * 2,
    E0 = 180 / Sp,
    _p = function () {
        function a() {}
        return a.prototype.reset = function (e) {
            this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4)
        }, a.prototype.moveTo = function (e, t) {
            this._add("M", e, t)
        }, a.prototype.lineTo = function (e, t) {
            this._add("L", e, t)
        }, a.prototype.bezierCurveTo = function (e, t, r, i, n, o) {
            this._add("C", e, t, r, i, n, o)
        }, a.prototype.quadraticCurveTo = function (e, t, r, i) {
            this._add("Q", e, t, r, i)
        }, a.prototype.arc = function (e, t, r, i, n, o) {
            this.ellipse(e, t, r, r, 0, i, n, o)
        }, a.prototype.ellipse = function (e, t, r, i, n, o, s, l) {
            var u = s - o,
                v = !l,
                h = Math.abs(u),
                c = Re(h - Ye) || (v ? u >= Ye : -u >= Ye),
                f = u > 0 ? u % Ye : u % Ye + Ye,
                p = !1;
            c ? p = !0 : Re(h) ? p = !1 : p = f >= Sp == !!v;
            var d = e + r * kn(o),
                g = t + i * En(o);
            this._start && this._add("M", d, g);
            var y = Math.round(n * E0);
            if (c) {
                var x = 1 / this._p,
                    m = (v ? 1 : -1) * (Ye - x);
                this._add("A", r, i, y, 1, +v, e + r * kn(o + m), t + i * En(o + m)), x > .01 && this._add("A", r, i, y, 0, +v, d, g)
            } else {
                var S = e + r * kn(s),
                    _ = t + i * En(s);
                this._add("A", r, i, y, +p, +v, S, _)
            }
        }, a.prototype.rect = function (e, t, r, i) {
            this._add("M", e, t), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z")
        }, a.prototype.closePath = function () {
            this._d.length > 0 && this._add("Z")
        }, a.prototype._add = function (e, t, r, i, n, o, s, l, u) {
            for (var v = [], h = this._p, c = 1; c < arguments.length; c++) {
                var f = arguments[c];
                if (isNaN(f)) {
                    this._invalid = !0;
                    return
                }
                v.push(Math.round(f * h) / h)
            }
            this._d.push(e + v.join(" ")), this._start = e === "Z"
        }, a.prototype.generateStr = function () {
            this._str = this._invalid ? "" : this._d.join(""), this._d = []
        }, a.prototype.getStr = function () {
            return this._str
        }, a
    }(),
    ma = "none",
    k0 = Math.round;

function V0(a) {
    var e = a.fill;
    return e != null && e !== ma
}

function O0(a) {
    var e = a.stroke;
    return e != null && e !== ma
}
var as = ["lineCap", "miterLimit", "lineJoin"],
    z0 = G(as, function (a) {
        return "stroke-" + a.toLowerCase()
    });

function N0(a, e, t, r) {
    var i = e.opacity == null ? 1 : e.opacity;
    if (t instanceof ge) {
        a("opacity", i);
        return
    }
    if (V0(e)) {
        var n = _a(e.fill);
        a("fill", n.color);
        var o = e.fillOpacity != null ? e.fillOpacity * n.opacity * i : n.opacity * i;
        (r || o < 1) && a("fill-opacity", o)
    } else a("fill", ma);
    if (O0(e)) {
        var s = _a(e.stroke);
        a("stroke", s.color);
        var l = e.strokeNoScale ? t.getLineScale() : 1,
            u = l ? (e.lineWidth || 0) / l : 0,
            v = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i,
            h = e.strokeFirst;
        if ((r || u !== 1) && a("stroke-width", u), (r || h) && a("paint-order", h ? "stroke" : "fill"), (r || v < 1) && a("stroke-opacity", v), e.lineDash) {
            var c = fy(t),
                f = c[0],
                p = c[1];
            f && (p = k0(p || 0), a("stroke-dasharray", f.join(",")), (p || r) && a("stroke-dashoffset", p))
        } else r && a("stroke-dasharray", ma);
        for (var d = 0; d < as.length; d++) {
            var g = as[d];
            if (r || e[g] !== lu[g]) {
                var y = e[g] || lu[g];
                y && a(z0[d], y)
            }
        }
    } else r && a("stroke", ma)
}
var bp = "http://www.w3.org/2000/svg",
    wp = "http://www.w3.org/1999/xlink",
    G0 = "http://www.w3.org/2000/xmlns/",
    B0 = "http://www.w3.org/XML/1998/namespace",
    Eu = "ecmeta_";

function Ap(a) {
    return document.createElementNS(bp, a)
}

function Mt(a, e, t, r, i) {
    return {
        tag: a,
        attrs: t || {},
        children: r,
        text: i,
        key: e
    }
}

function H0(a, e) {
    var t = [];
    if (e)
        for (var r in e) {
            var i = e[r],
                n = r;
            i !== !1 && (i !== !0 && i != null && (n += '="' + i + '"'), t.push(n))
        }
    return "<" + a + " " + t.join(" ") + ">"
}

function F0(a) {
    return "</" + a + ">"
}

function al(a, e) {
    e = e || {};
    var t = e.newline ? `
` : "";

    function r(i) {
        var n = i.children,
            o = i.tag,
            s = i.attrs,
            l = i.text;
        return H0(o, s) + (o !== "style" ? py(l) : l || "") + (n ? "" + t + G(n, function (u) {
            return r(u)
        }).join(t) + t : "") + F0(o)
    }
    return r(a)
}

function W0(a, e, t) {
    t = t || {};
    var r = t.newline ? `
` : "",
        i = " {" + r,
        n = r + "}",
        o = G(wt(a), function (l) {
            return l + i + G(wt(a[l]), function (u) {
                return u + ":" + a[l][u] + ";"
            }).join(r) + n
        }).join(r),
        s = G(wt(e), function (l) {
            return "@keyframes " + l + i + G(wt(e[l]), function (u) {
                return u + i + G(wt(e[l][u]), function (v) {
                    var h = e[l][u][v];
                    return v === "d" && (h = 'path("' + h + '")'), v + ":" + h + ";"
                }).join(r) + n
            }).join(r) + n
        }).join(r);
    return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(r)
}

function is(a) {
    return {
        zrId: a,
        shadowCache: {},
        patternCache: {},
        gradientCache: {},
        clipPathCache: {},
        defs: {},
        cssNodes: {},
        cssAnims: {},
        cssStyleCache: {},
        cssAnimIdx: 0,
        shadowIdx: 0,
        gradientIdx: 0,
        patternIdx: 0,
        clipPathIdx: 0
    }
}

function ku(a, e, t, r) {
    return Mt("svg", "root", {
        width: a,
        height: e,
        xmlns: bp,
        "xmlns:xlink": wp,
        version: "1.1",
        baseProfile: "full",
        viewBox: r ? "0 0 " + a + " " + e : !1
    }, t)
}
var $0 = 0;

function Tp() {
    return $0++
}
var Vu = {
        cubicIn: "0.32,0,0.67,0",
        cubicOut: "0.33,1,0.68,1",
        cubicInOut: "0.65,0,0.35,1",
        quadraticIn: "0.11,0,0.5,0",
        quadraticOut: "0.5,1,0.89,1",
        quadraticInOut: "0.45,0,0.55,1",
        quarticIn: "0.5,0,0.75,0",
        quarticOut: "0.25,1,0.5,1",
        quarticInOut: "0.76,0,0.24,1",
        quinticIn: "0.64,0,0.78,0",
        quinticOut: "0.22,1,0.36,1",
        quinticInOut: "0.83,0,0.17,1",
        sinusoidalIn: "0.12,0,0.39,0",
        sinusoidalOut: "0.61,1,0.88,1",
        sinusoidalInOut: "0.37,0,0.63,1",
        exponentialIn: "0.7,0,0.84,0",
        exponentialOut: "0.16,1,0.3,1",
        exponentialInOut: "0.87,0,0.13,1",
        circularIn: "0.55,0,1,0.45",
        circularOut: "0,0.55,0.45,1",
        circularInOut: "0.85,0,0.15,1"
    },
    qe = "transform-origin";

function Z0(a, e, t) {
    var r = W({}, a.shape);
    W(r, e), a.buildPath(t, r);
    var i = new _p;
    return i.reset($f(a)), t.rebuildPath(i, 1), i.generateStr(), i.getStr()
}

function U0(a, e) {
    var t = e.originX,
        r = e.originY;
    (t || r) && (a[qe] = t + "px " + r + "px")
}
var Y0 = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
};

function Cp(a, e) {
    var t = e.zrId + "-ani-" + e.cssAnimIdx++;
    return e.cssAnims[t] = a, t
}

function X0(a, e, t) {
    var r = a.shape.paths,
        i = {},
        n, o;
    if (T(r, function (l) {
            var u = is(t.zrId);
            u.animation = !0, gn(l, {}, u, !0);
            var v = u.cssAnims,
                h = u.cssNodes,
                c = wt(v),
                f = c.length;
            if (f) {
                o = c[f - 1];
                var p = v[o];
                for (var d in p) {
                    var g = p[d];
                    i[d] = i[d] || {
                        d: ""
                    }, i[d].d += g.d || ""
                }
                for (var y in h) {
                    var x = h[y].animation;
                    x.indexOf(o) >= 0 && (n = x)
                }
            }
        }), !!n) {
        e.d = !1;
        var s = Cp(i, t);
        return n.replace(o, s)
    }
}

function Ou(a) {
    return q(a) ? Vu[a] ? "cubic-bezier(" + Vu[a] + ")" : dy(a) ? a : "" : ""
}

function gn(a, e, t, r) {
    var i = a.animators,
        n = i.length,
        o = [];
    if (a instanceof Ff) {
        var s = X0(a, e, t);
        if (s) o.push(s);
        else if (!n) return
    } else if (!n) return;
    for (var l = {}, u = 0; u < n; u++) {
        var v = i[u],
            h = [v.getMaxTime() / 1e3 + "s"],
            c = Ou(v.getClip().easing),
            f = v.getDelay();
        c ? h.push(c) : h.push("linear"), f && h.push(f / 1e3 + "s"), v.getLoop() && h.push("infinite");
        var p = h.join(" ");
        l[p] = l[p] || [p, []], l[p][1].push(v)
    }

    function d(x) {
        var m = x[1],
            S = m.length,
            _ = {},
            b = {},
            w = {},
            A = "animation-timing-function";

        function C(Y, vt, lt) {
            for (var dt = Y.getTracks(), zt = Y.getMaxTime(), Bt = 0; Bt < dt.length; Bt++) {
                var _t = dt[Bt];
                if (_t.needsAnimate()) {
                    var $t = _t.keyframes,
                        Zt = _t.propName;
                    if (lt && (Zt = lt(Zt)), Zt)
                        for (var ue = 0; ue < $t.length; ue++) {
                            var Ze = $t[ue],
                                Ue = Math.round(Ze.time / zt * 100) + "%",
                                iu = Ou(Ze.easing),
                                nu = Ze.rawValue;
                            (q(nu) || te(nu)) && (vt[Ue] = vt[Ue] || {}, vt[Ue][Zt] = Ze.rawValue, iu && (vt[Ue][A] = iu))
                        }
                }
            }
        }
        for (var D = 0; D < S; D++) {
            var I = m[D],
                L = I.targetName;
            L ? L === "shape" && C(I, b) : !r && C(I, _)
        }
        for (var M in _) {
            var P = {};
            gy(P, a), W(P, _[M]);
            var R = Wf(P),
                k = _[M][A];
            w[M] = R ? {
                transform: R
            } : {}, U0(w[M], P), k && (w[M][A] = k)
        }
        var V, O = !0;
        for (var M in b) {
            w[M] = w[M] || {};
            var z = !V,
                k = b[M][A];
            z && (V = new Zs);
            var $ = V.len();
            V.reset(), w[M].d = Z0(a, b[M], V);
            var Z = V.len();
            if (!z && $ !== Z) {
                O = !1;
                break
            }
            k && (w[M][A] = k)
        }
        if (!O)
            for (var M in w) delete w[M].d;
        if (!r)
            for (var D = 0; D < S; D++) {
                var I = m[D],
                    L = I.targetName;
                L === "style" && C(I, w, function (dt) {
                    return Y0[dt]
                })
            }
        for (var et = wt(w), J = !0, X, D = 1; D < et.length; D++) {
            var nt = et[D - 1],
                st = et[D];
            if (w[nt][qe] !== w[st][qe]) {
                J = !1;
                break
            }
            X = w[nt][qe]
        }
        if (J && X) {
            for (var M in w) w[M][qe] && delete w[M][qe];
            e[qe] = X
        }
        if (Dt(et, function (Y) {
                return wt(w[Y]).length > 0
            }).length) {
            var it = Cp(w, t);
            return it + " " + x[0] + " both"
        }
    }
    for (var g in l) {
        var s = d(l[g]);
        s && o.push(s)
    }
    if (o.length) {
        var y = t.zrId + "-cls-" + Tp();
        t.cssNodes["." + y] = {
            animation: o.join(",")
        }, e.class = y
    }
}

function K0(a, e, t) {
    if (!a.ignore)
        if (a.isSilent()) {
            var r = {
                "pointer-events": "none"
            };
            zu(r, e, t, !0)
        } else {
            var i = a.states.emphasis && a.states.emphasis.style ? a.states.emphasis.style : {},
                n = i.fill;
            if (!n) {
                var o = a.style && a.style.fill,
                    s = a.states.select && a.states.select.style && a.states.select.style.fill,
                    l = a.currentStates.indexOf("select") >= 0 && s || o;
                l && (n = yy(l))
            }
            var u = i.lineWidth;
            if (u) {
                var v = !i.strokeNoScale && a.transform ? a.transform[0] : 1;
                u = u / v
            }
            var r = {
                cursor: "pointer"
            };
            n && (r.fill = n), i.stroke && (r.stroke = i.stroke), u && (r["stroke-width"] = u), zu(r, e, t, !0)
        }
}

function zu(a, e, t, r) {
    var i = JSON.stringify(a),
        n = t.cssStyleCache[i];
    n || (n = t.zrId + "-cls-" + Tp(), t.cssStyleCache[i] = n, t.cssNodes["." + n + (r ? ":hover" : "")] = a), e.class = e.class ? e.class + " " + n : n
}
var Da = Math.round;

function Dp(a) {
    return a && q(a.src)
}

function Ip(a) {
    return a && rt(a.toDataURL)
}

function il(a, e, t, r) {
    N0(function (i, n) {
        var o = i === "fill" || i === "stroke";
        o && Uf(n) ? Mp(e, a, i, r) : o && Us(n) ? Pp(t, a, i, r) : o && n === "none" ? a[i] = "transparent" : a[i] = n
    }, e, t, !1), rx(t, a, r)
}

function nl(a, e) {
    var t = My(e);
    t && (t.each(function (r, i) {
        r != null && (a[(Eu + i).toLowerCase()] = r + "")
    }), e.isSilent() && (a[Eu + "silent"] = "true"))
}

function Nu(a) {
    return Re(a[0] - 1) && Re(a[1]) && Re(a[2]) && Re(a[3] - 1)
}

function q0(a) {
    return Re(a[4]) && Re(a[5])
}

function ol(a, e, t) {
    if (e && !(q0(e) && Nu(e))) {
        var r = t ? 10 : 1e4;
        a.transform = Nu(e) ? "translate(" + Da(e[4] * r) / r + " " + Da(e[5] * r) / r + ")" : Py(e)
    }
}

function Gu(a, e, t) {
    for (var r = a.points, i = [], n = 0; n < r.length; n++) i.push(Da(r[n][0] * t) / t), i.push(Da(r[n][1] * t) / t);
    e.points = i.join(" ")
}

function Bu(a) {
    return !a.smooth
}

function j0(a) {
    var e = G(a, function (t) {
        return typeof t == "string" ? [t, t] : t
    });
    return function (t, r, i) {
        for (var n = 0; n < e.length; n++) {
            var o = e[n],
                s = t[o[0]];
            s != null && (r[o[1]] = Da(s * i) / i)
        }
    }
}
var J0 = {
    circle: [j0(["cx", "cy", "r"])],
    polyline: [Gu, Bu],
    polygon: [Gu, Bu]
};

function Q0(a) {
    for (var e = a.animators, t = 0; t < e.length; t++)
        if (e[t].targetName === "shape") return !0;
    return !1
}

function Lp(a, e) {
    var t = a.style,
        r = a.shape,
        i = J0[a.type],
        n = {},
        o = e.animation,
        s = "path",
        l = a.style.strokePercent,
        u = e.compress && $f(a) || 4;
    if (i && !e.willUpdate && !(i[1] && !i[1](r)) && !(o && Q0(a)) && !(l < 1)) {
        s = a.type;
        var v = Math.pow(10, u);
        i[0](r, n, v)
    } else {
        var h = !a.path || a.shapeChanged();
        a.path || a.createPathProxy();
        var c = a.path;
        h && (c.beginPath(), a.buildPath(c, a.shape), a.pathUpdated());
        var f = c.getVersion(),
            p = a,
            d = p.__svgPathBuilder;
        (p.__svgPathVersion !== f || !d || l !== p.__svgPathStrokePercent) && (d || (d = p.__svgPathBuilder = new _p), d.reset(u), c.rebuildPath(d, l), d.generateStr(), p.__svgPathVersion = f, p.__svgPathStrokePercent = l), n.d = d.getStr()
    }
    return ol(n, a.transform), il(n, t, a, e), nl(n, a), e.animation && gn(a, n, e), e.emphasis && K0(a, n, e), Mt(s, a.id + "", n)
}

function tx(a, e) {
    var t = a.style,
        r = t.image;
    if (r && !q(r) && (Dp(r) ? r = r.src : Ip(r) && (r = r.toDataURL())), !!r) {
        var i = t.x || 0,
            n = t.y || 0,
            o = t.width,
            s = t.height,
            l = {
                href: r,
                width: o,
                height: s
            };
        return i && (l.x = i), n && (l.y = n), ol(l, a.transform), il(l, t, a, e), nl(l, a), e.animation && gn(a, l, e), Mt("image", a.id + "", l)
    }
}

function ex(a, e) {
    var t = a.style,
        r = t.text;
    if (r != null && (r += ""), !(!r || isNaN(t.x) || isNaN(t.y))) {
        var i = t.font || wy,
            n = t.x || 0,
            o = Ay(t.y || 0, Ty(i), t.textBaseline),
            s = Cy[t.textAlign] || t.textAlign,
            l = {
                "dominant-baseline": "central",
                "text-anchor": s
            };
        if (Dy(t)) {
            var u = "",
                v = t.fontStyle,
                h = Iy(t.fontSize);
            if (!parseFloat(h)) return;
            var c = t.fontFamily || Ly,
                f = t.fontWeight;
            u += "font-size:" + h + ";font-family:" + c + ";", v && v !== "normal" && (u += "font-style:" + v + ";"), f && f !== "normal" && (u += "font-weight:" + f + ";"), l.style = u
        } else l.style = "font: " + i;
        return r.match(/\s/) && (l["xml:space"] = "preserve"), n && (l.x = n), o && (l.y = o), ol(l, a.transform), il(l, t, a, e), nl(l, a), e.animation && gn(a, l, e), Mt("text", a.id + "", l, void 0, r)
    }
}

function Hu(a, e) {
    if (a instanceof Pt) return Lp(a, e);
    if (a instanceof ge) return tx(a, e);
    if (a instanceof Zf) return ex(a, e)
}

function rx(a, e, t) {
    var r = a.style;
    if (Ry(r)) {
        var i = Ey(a),
            n = t.shadowCache,
            o = n[i];
        if (!o) {
            var s = a.getGlobalScale(),
                l = s[0],
                u = s[1];
            if (!l || !u) return;
            var v = r.shadowOffsetX || 0,
                h = r.shadowOffsetY || 0,
                c = r.shadowBlur,
                f = _a(r.shadowColor),
                p = f.opacity,
                d = f.color,
                g = c / 2 / l,
                y = c / 2 / u,
                x = g + " " + y;
            o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = Mt("filter", o, {
                id: o,
                x: "-100%",
                y: "-100%",
                width: "300%",
                height: "300%"
            }, [Mt("feDropShadow", "", {
                dx: v / l,
                dy: h / u,
                stdDeviation: x,
                "flood-color": d,
                "flood-opacity": p
            })]), n[i] = o
        }
        e.filter = Ki(o)
    }
}

function Mp(a, e, t, r) {
    var i = a[t],
        n, o = {
            gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
        };
    if (my(i)) n = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
    else if (xy(i)) n = "radialGradient", o.cx = Lt(i.x, .5), o.cy = Lt(i.y, .5), o.r = Lt(i.r, .5);
    else return;
    for (var s = i.colorStops, l = [], u = 0, v = s.length; u < v; ++u) {
        var h = Sy(s[u].offset) * 100 + "%",
            c = s[u].color,
            f = _a(c),
            p = f.color,
            d = f.opacity,
            g = {
                offset: h
            };
        g["stop-color"] = p, d < 1 && (g["stop-opacity"] = d), l.push(Mt("stop", u + "", g))
    }
    var y = Mt(n, "", o, l),
        x = al(y),
        m = r.gradientCache,
        S = m[x];
    S || (S = r.zrId + "-g" + r.gradientIdx++, m[x] = S, o.id = S, r.defs[S] = Mt(n, S, o, l)), e[t] = Ki(S)
}

function Pp(a, e, t, r) {
    var i = a.style[t],
        n = a.getBoundingRect(),
        o = {},
        s = i.repeat,
        l = s === "no-repeat",
        u = s === "repeat-x",
        v = s === "repeat-y",
        h;
    if (_y(i)) {
        var c = i.imageWidth,
            f = i.imageHeight,
            p = void 0,
            d = i.image;
        if (q(d) ? p = d : Dp(d) ? p = d.src : Ip(d) && (p = d.toDataURL()), typeof Image > "u") {
            var g = "Image width/height must been given explictly in svg-ssr renderer.";
            ba(c, g), ba(f, g)
        } else if (c == null || f == null) {
            var y = function (D, I) {
                    if (D) {
                        var L = D.elm,
                            M = c || I.width,
                            P = f || I.height;
                        D.tag === "pattern" && (u ? (P = 1, M /= n.width) : v && (M = 1, P /= n.height)), D.attrs.width = M, D.attrs.height = P, L && (L.setAttribute("width", M), L.setAttribute("height", P))
                    }
                },
                x = by(p, null, a, function (D) {
                    l || y(b, D), y(h, D)
                });
            x && x.width && x.height && (c = c || x.width, f = f || x.height)
        }
        h = Mt("image", "img", {
            href: p,
            width: c,
            height: f
        }), o.width = c, o.height = f
    } else i.svgElement && (h = ot(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
    if (h) {
        var m, S;
        l ? m = S = 1 : u ? (S = 1, m = o.width / n.width) : v ? (m = 1, S = o.height / n.height) : o.patternUnits = "userSpaceOnUse", m != null && !isNaN(m) && (o.width = m), S != null && !isNaN(S) && (o.height = S);
        var _ = Wf(i);
        _ && (o.patternTransform = _);
        var b = Mt("pattern", "", o, [h]),
            w = al(b),
            A = r.patternCache,
            C = A[w];
        C || (C = r.zrId + "-p" + r.patternIdx++, A[w] = C, o.id = C, b = r.defs[C] = Mt("pattern", C, o, [h])), e[t] = Ki(C)
    }
}

function ax(a, e, t) {
    var r = t.clipPathCache,
        i = t.defs,
        n = r[a.id];
    if (!n) {
        n = t.zrId + "-c" + t.clipPathIdx++;
        var o = {
            id: n
        };
        r[a.id] = n, i[n] = Mt("clipPath", n, o, [Lp(a, t)])
    }
    e["clip-path"] = Ki(n)
}

function Fu(a) {
    return document.createTextNode(a)
}

function ar(a, e, t) {
    a.insertBefore(e, t)
}

function Wu(a, e) {
    a.removeChild(e)
}

function $u(a, e) {
    a.appendChild(e)
}

function Rp(a) {
    return a.parentNode
}

function Ep(a) {
    return a.nextSibling
}

function Vn(a, e) {
    a.textContent = e
}
var Zu = 58,
    ix = 120,
    nx = Mt("", "");

function ns(a) {
    return a === void 0
}

function fe(a) {
    return a !== void 0
}

function ox(a, e, t) {
    for (var r = {}, i = e; i <= t; ++i) {
        var n = a[i].key;
        n !== void 0 && (r[n] = i)
    }
    return r
}

function ca(a, e) {
    var t = a.key === e.key,
        r = a.tag === e.tag;
    return r && t
}

function Ia(a) {
    var e, t = a.children,
        r = a.tag;
    if (fe(r)) {
        var i = a.elm = Ap(r);
        if (sl(nx, a), B(t))
            for (e = 0; e < t.length; ++e) {
                var n = t[e];
                n != null && $u(i, Ia(n))
            } else fe(a.text) && !St(a.text) && $u(i, Fu(a.text))
    } else a.elm = Fu(a.text);
    return a.elm
}

function kp(a, e, t, r, i) {
    for (; r <= i; ++r) {
        var n = t[r];
        n != null && ar(a, Ia(n), e)
    }
}

function Mi(a, e, t, r) {
    for (; t <= r; ++t) {
        var i = e[t];
        if (i != null)
            if (fe(i.tag)) {
                var n = Rp(i.elm);
                Wu(n, i.elm)
            } else Wu(a, i.elm)
    }
}

function sl(a, e) {
    var t, r = e.elm,
        i = a && a.attrs || {},
        n = e.attrs || {};
    if (i !== n) {
        for (t in n) {
            var o = n[t],
                s = i[t];
            s !== o && (o === !0 ? r.setAttribute(t, "") : o === !1 ? r.removeAttribute(t) : t === "style" ? r.style.cssText = o : t.charCodeAt(0) !== ix ? r.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? r.setAttributeNS(G0, t, o) : t.charCodeAt(3) === Zu ? r.setAttributeNS(B0, t, o) : t.charCodeAt(5) === Zu ? r.setAttributeNS(wp, t, o) : r.setAttribute(t, o))
        }
        for (t in i) t in n || r.removeAttribute(t)
    }
}

function sx(a, e, t) {
    for (var r = 0, i = 0, n = e.length - 1, o = e[0], s = e[n], l = t.length - 1, u = t[0], v = t[l], h, c, f, p; r <= n && i <= l;) o == null ? o = e[++r] : s == null ? s = e[--n] : u == null ? u = t[++i] : v == null ? v = t[--l] : ca(o, u) ? (Mr(o, u), o = e[++r], u = t[++i]) : ca(s, v) ? (Mr(s, v), s = e[--n], v = t[--l]) : ca(o, v) ? (Mr(o, v), ar(a, o.elm, Ep(s.elm)), o = e[++r], v = t[--l]) : ca(s, u) ? (Mr(s, u), ar(a, s.elm, o.elm), s = e[--n], u = t[++i]) : (ns(h) && (h = ox(e, r, n)), c = h[u.key], ns(c) ? ar(a, Ia(u), o.elm) : (f = e[c], f.tag !== u.tag ? ar(a, Ia(u), o.elm) : (Mr(f, u), e[c] = void 0, ar(a, f.elm, o.elm))), u = t[++i]);
    (r <= n || i <= l) && (r > n ? (p = t[l + 1] == null ? null : t[l + 1].elm, kp(a, p, t, i, l)) : Mi(a, e, r, n))
}

function Mr(a, e) {
    var t = e.elm = a.elm,
        r = a.children,
        i = e.children;
    a !== e && (sl(a, e), ns(e.text) ? fe(r) && fe(i) ? r !== i && sx(t, r, i) : fe(i) ? (fe(a.text) && Vn(t, ""), kp(t, null, i, 0, i.length - 1)) : fe(r) ? Mi(t, r, 0, r.length - 1) : fe(a.text) && Vn(t, "") : a.text !== e.text && (fe(r) && Mi(t, r, 0, r.length - 1), Vn(t, e.text)))
}

function lx(a, e) {
    if (ca(a, e)) Mr(a, e);
    else {
        var t = a.elm,
            r = Rp(t);
        Ia(e), r !== null && (ar(r, e.elm, Ep(t)), Mi(r, [a], 0, 0))
    }
    return e
}
var ux = 0,
    vx = function () {
        function a(e, t, r) {
            if (this.type = "svg", this.refreshHover = Uu(), this.configLayer = Uu(), this.storage = t, this._opts = r = W({}, r), this.root = e, this._id = "zr" + ux++, this._oldVNode = ku(r.width, r.height), e && !r.ssr) {
                var i = this._viewport = document.createElement("div");
                i.style.cssText = "position:relative;overflow:hidden";
                var n = this._svgDom = this._oldVNode.elm = Ap("svg");
                sl(null, this._oldVNode), i.appendChild(n), e.appendChild(i)
            }
            this.resize(r.width, r.height)
        }
        return a.prototype.getType = function () {
            return this.type
        }, a.prototype.getViewportRoot = function () {
            return this._viewport
        }, a.prototype.getViewportRootOffset = function () {
            var e = this.getViewportRoot();
            if (e) return {
                offsetLeft: e.offsetLeft || 0,
                offsetTop: e.offsetTop || 0
            }
        }, a.prototype.getSvgDom = function () {
            return this._svgDom
        }, a.prototype.refresh = function () {
            if (this.root) {
                var e = this.renderToVNode({
                    willUpdate: !0
                });
                e.attrs.style = "position:absolute;left:0;top:0;user-select:none", lx(this._oldVNode, e), this._oldVNode = e
            }
        }, a.prototype.renderOneToVNode = function (e) {
            return Hu(e, is(this._id))
        }, a.prototype.renderToVNode = function (e) {
            e = e || {};
            var t = this.storage.getDisplayList(!0),
                r = this._width,
                i = this._height,
                n = is(this._id);
            n.animation = e.animation, n.willUpdate = e.willUpdate, n.compress = e.compress, n.emphasis = e.emphasis;
            var o = [],
                s = this._bgVNode = hx(r, i, this._backgroundColor, n);
            s && o.push(s);
            var l = e.compress ? null : this._mainVNode = Mt("g", "main", {}, []);
            this._paintList(t, n, l ? l.children : o), l && o.push(l);
            var u = G(wt(n.defs), function (c) {
                return n.defs[c]
            });
            if (u.length && o.push(Mt("defs", "defs", {}, u)), e.animation) {
                var v = W0(n.cssNodes, n.cssAnims, {
                    newline: !0
                });
                if (v) {
                    var h = Mt("style", "stl", {}, [], v);
                    o.push(h)
                }
            }
            return ku(r, i, o, e.useViewBox)
        }, a.prototype.renderToString = function (e) {
            return e = e || {}, al(this.renderToVNode({
                animation: Lt(e.cssAnimation, !0),
                emphasis: Lt(e.cssEmphasis, !0),
                willUpdate: !1,
                compress: !0,
                useViewBox: Lt(e.useViewBox, !0)
            }), {
                newline: !0
            })
        }, a.prototype.setBackgroundColor = function (e) {
            this._backgroundColor = e
        }, a.prototype.getSvgRoot = function () {
            return this._mainVNode && this._mainVNode.elm
        }, a.prototype._paintList = function (e, t, r) {
            for (var i = e.length, n = [], o = 0, s, l, u = 0, v = 0; v < i; v++) {
                var h = e[v];
                if (!h.invisible) {
                    var c = h.__clipPaths,
                        f = c && c.length || 0,
                        p = l && l.length || 0,
                        d = void 0;
                    for (d = Math.max(f - 1, p - 1); d >= 0 && !(c && l && c[d] === l[d]); d--);
                    for (var g = p - 1; g > d; g--) o--, s = n[o - 1];
                    for (var y = d + 1; y < f; y++) {
                        var x = {};
                        ax(c[y], x, t);
                        var m = Mt("g", "clip-g-" + u++, x, []);
                        (s ? s.children : r).push(m), n[o++] = m, s = m
                    }
                    l = c;
                    var S = Hu(h, t);
                    S && (s ? s.children : r).push(S)
                }
            }
        }, a.prototype.resize = function (e, t) {
            var r = this._opts,
                i = this.root,
                n = this._viewport;
            if (e != null && (r.width = e), t != null && (r.height = t), i && n && (n.style.display = "none", e = kr(i, 0, r), t = kr(i, 1, r), n.style.display = ""), this._width !== e || this._height !== t) {
                if (this._width = e, this._height = t, n) {
                    var o = n.style;
                    o.width = e + "px", o.height = t + "px"
                }
                if (Us(this._backgroundColor)) this.refresh();
                else {
                    var s = this._svgDom;
                    s && (s.setAttribute("width", e), s.setAttribute("height", t));
                    var l = this._bgVNode && this._bgVNode.elm;
                    l && (l.setAttribute("width", e), l.setAttribute("height", t))
                }
            }
        }, a.prototype.getWidth = function () {
            return this._width
        }, a.prototype.getHeight = function () {
            return this._height
        }, a.prototype.dispose = function () {
            this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null
        }, a.prototype.clear = function () {
            this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null
        }, a.prototype.toDataURL = function (e) {
            var t = this.renderToString(),
                r = "data:image/svg+xml;";
            return e ? (t = ky(t), t && r + "base64," + t) : r + "charset=UTF-8," + encodeURIComponent(t)
        }, a
    }();

function Uu(a) {
    return function () {}
}

function hx(a, e, t, r) {
    var i;
    if (t && t !== "none")
        if (i = Mt("rect", "bg", {
                width: a,
                height: e,
                x: "0",
                y: "0"
            }), Uf(t)) Mp({
            fill: t
        }, i.attrs, "fill", r);
        else if (Us(t)) Pp({
        style: {
            fill: t
        },
        dirty: pe,
        getBoundingRect: function () {
            return {
                width: a,
                height: e
            }
        }
    }, i.attrs, "fill", r);
    else {
        var n = _a(t),
            o = n.color,
            s = n.opacity;
        i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s)
    }
    return i
}
const cx = vx;

function fx(a) {
    a.registerPainter("svg", cx)
}

function Yu(a, e, t) {
    var r = Zo.createCanvas(),
        i = e.getWidth(),
        n = e.getHeight(),
        o = r.style;
    return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = n + "px", r.setAttribute("data-zr-dom-id", a)), r.width = i * t, r.height = n * t, r
}
var px = function (a) {
    E(e, a);

    function e(t, r, i) {
        var n = a.call(this) || this;
        n.motionBlur = !1, n.lastFrameAlpha = .7, n.dpr = 1, n.virtual = !1, n.config = {}, n.incremental = !1, n.zlevel = 0, n.maxRepaintRectCount = 5, n.__dirty = !0, n.__firstTimePaint = !0, n.__used = !1, n.__drawIndex = 0, n.__startIndex = 0, n.__endIndex = 0, n.__prevStartIndex = null, n.__prevEndIndex = null;
        var o;
        i = i || Xf, typeof t == "string" ? o = Yu(t, r, i) : St(t) && (o = t, t = o.id), n.id = t, n.dom = o;
        var s = o.style;
        return s && (Yf(o), o.onselectstart = function () {
            return !1
        }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), n.painter = r, n.dpr = i, n
    }
    return e.prototype.getElementCount = function () {
        return this.__endIndex - this.__startIndex
    }, e.prototype.afterBrush = function () {
        this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex
    }, e.prototype.initContext = function () {
        this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
    }, e.prototype.setUnpainted = function () {
        this.__firstTimePaint = !0
    }, e.prototype.createBackBuffer = function () {
        var t = this.dpr;
        this.domBack = Yu("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t)
    }, e.prototype.createRepaintRects = function (t, r, i, n) {
        if (this.__firstTimePaint) return this.__firstTimePaint = !1, null;
        var o = [],
            s = this.maxRepaintRectCount,
            l = !1,
            u = new gt(0, 0, 0, 0);

        function v(x) {
            if (!(!x.isFinite() || x.isZero()))
                if (o.length === 0) {
                    var m = new gt(0, 0, 0, 0);
                    m.copy(x), o.push(m)
                } else {
                    for (var S = !1, _ = 1 / 0, b = 0, w = 0; w < o.length; ++w) {
                        var A = o[w];
                        if (A.intersect(x)) {
                            var C = new gt(0, 0, 0, 0);
                            C.copy(A), C.union(x), o[w] = C, S = !0;
                            break
                        } else if (l) {
                            u.copy(x), u.union(A);
                            var D = x.width * x.height,
                                I = A.width * A.height,
                                L = u.width * u.height,
                                M = L - D - I;
                            M < _ && (_ = M, b = w)
                        }
                    }
                    if (l && (o[b].union(x), S = !0), !S) {
                        var m = new gt(0, 0, 0, 0);
                        m.copy(x), o.push(m)
                    }
                    l || (l = o.length >= s)
                }
        }
        for (var h = this.__startIndex; h < this.__endIndex; ++h) {
            var c = t[h];
            if (c) {
                var f = c.shouldBePainted(i, n, !0, !0),
                    p = c.__isRendered && (c.__dirty & $o || !f) ? c.getPrevPaintRect() : null;
                p && v(p);
                var d = f && (c.__dirty & $o || !c.__isRendered) ? c.getPaintRect() : null;
                d && v(d)
            }
        }
        for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
            var c = r[h],
                f = c && c.shouldBePainted(i, n, !0, !0);
            if (c && (!f || !c.__zr) && c.__isRendered) {
                var p = c.getPrevPaintRect();
                p && v(p)
            }
        }
        var g;
        do {
            g = !1;
            for (var h = 0; h < o.length;) {
                if (o[h].isZero()) {
                    o.splice(h, 1);
                    continue
                }
                for (var y = h + 1; y < o.length;) o[h].intersect(o[y]) ? (g = !0, o[h].union(o[y]), o.splice(y, 1)) : y++;
                h++
            }
        } while (g);
        return this._paintRects = o, o
    }, e.prototype.debugGetPaintRects = function () {
        return (this._paintRects || []).slice()
    }, e.prototype.resize = function (t, r) {
        var i = this.dpr,
            n = this.dom,
            o = n.style,
            s = this.domBack;
        o && (o.width = t + "px", o.height = r + "px"), n.width = t * i, n.height = r * i, s && (s.width = t * i, s.height = r * i, i !== 1 && this.ctxBack.scale(i, i))
    }, e.prototype.clear = function (t, r, i) {
        var n = this.dom,
            o = this.ctx,
            s = n.width,
            l = n.height;
        r = r || this.clearColor;
        var u = this.motionBlur && !t,
            v = this.lastFrameAlpha,
            h = this.dpr,
            c = this;
        u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(n, 0, 0, s / h, l / h));
        var f = this.domBack;

        function p(d, g, y, x) {
            if (o.clearRect(d, g, y, x), r && r !== "transparent") {
                var m = void 0;
                if (Vy(r)) {
                    var S = r.global || r.__width === y && r.__height === x;
                    m = S && r.__canvasGradient || Oy(o, r, {
                        x: 0,
                        y: 0,
                        width: y,
                        height: x
                    }), r.__canvasGradient = m, r.__width = y, r.__height = x
                } else zy(r) && (r.scaleX = r.scaleX || h, r.scaleY = r.scaleY || h, m = Ny(o, r, {
                    dirty: function () {
                        c.setUnpainted(), c.painter.refresh()
                    }
                }));
                o.save(), o.fillStyle = m || r, o.fillRect(d, g, y, x), o.restore()
            }
            u && (o.save(), o.globalAlpha = v, o.drawImage(f, d, g, y, x), o.restore())
        }!i || u ? p(0, 0, s, l) : i.length && T(i, function (d) {
            p(d.x * h, d.y * h, d.width * h, d.height * h)
        })
    }, e
}(Ys);
const On = px;
var Xu = 1e5,
    Xe = 314159,
    ri = .01,
    dx = .001;

function gx(a) {
    return a ? a.__builtin__ ? !0 : !(typeof a.resize != "function" || typeof a.refresh != "function") : !1
}

function yx(a, e) {
    var t = document.createElement("div");
    return t.style.cssText = ["position:relative", "width:" + a + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", t
}
var mx = function () {
    function a(e, t, r, i) {
        this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
        var n = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
        this._opts = r = W({}, r || {}), this.dpr = r.devicePixelRatio || Xf, this._singleCanvas = n, this.root = e;
        var o = e.style;
        o && (Yf(e), e.innerHTML = ""), this.storage = t;
        var s = this._zlevelList;
        this._prevDisplayList = [];
        var l = this._layers;
        if (n) {
            var v = e,
                h = v.width,
                c = v.height;
            r.width != null && (h = r.width), r.height != null && (c = r.height), this.dpr = r.devicePixelRatio || 1, v.width = h * this.dpr, v.height = c * this.dpr, this._width = h, this._height = c;
            var f = new On(v, this, this.dpr);
            f.__builtin__ = !0, f.initContext(), l[Xe] = f, f.zlevel = Xe, s.push(Xe), this._domRoot = e
        } else {
            this._width = kr(e, 0, r), this._height = kr(e, 1, r);
            var u = this._domRoot = yx(this._width, this._height);
            e.appendChild(u)
        }
    }
    return a.prototype.getType = function () {
        return "canvas"
    }, a.prototype.isSingleCanvas = function () {
        return this._singleCanvas
    }, a.prototype.getViewportRoot = function () {
        return this._domRoot
    }, a.prototype.getViewportRootOffset = function () {
        var e = this.getViewportRoot();
        if (e) return {
            offsetLeft: e.offsetLeft || 0,
            offsetTop: e.offsetTop || 0
        }
    }, a.prototype.refresh = function (e) {
        var t = this.storage.getDisplayList(!0),
            r = this._prevDisplayList,
            i = this._zlevelList;
        this._redrawId = Math.random(), this._paintList(t, r, e, this._redrawId);
        for (var n = 0; n < i.length; n++) {
            var o = i[n],
                s = this._layers[o];
            if (!s.__builtin__ && s.refresh) {
                var l = n === 0 ? this._backgroundColor : null;
                s.refresh(l)
            }
        }
        return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this
    }, a.prototype.refreshHover = function () {
        this._paintHoverList(this.storage.getDisplayList(!1))
    }, a.prototype._paintHoverList = function (e) {
        var t = e.length,
            r = this._hoverlayer;
        if (r && r.clear(), !!t) {
            for (var i = {
                    inHover: !0,
                    viewWidth: this._width,
                    viewHeight: this._height
                }, n, o = 0; o < t; o++) {
                var s = e[o];
                s.__inHover && (r || (r = this._hoverlayer = this.getLayer(Xu)), n || (n = r.ctx, n.save()), Ja(n, s, i, o === t - 1))
            }
            n && n.restore()
        }
    }, a.prototype.getHoverLayer = function () {
        return this.getLayer(Xu)
    }, a.prototype.paintOne = function (e, t) {
        Gy(e, t)
    }, a.prototype._paintList = function (e, t, r, i) {
        if (this._redrawId === i) {
            r = r || !1, this._updateLayerStatus(e);
            var n = this._doPaintList(e, t, r),
                o = n.finished,
                s = n.needsRefreshHover;
            if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o) this.eachLayer(function (u) {
                u.afterBrush && u.afterBrush()
            });
            else {
                var l = this;
                By(function () {
                    l._paintList(e, t, r, i)
                })
            }
        }
    }, a.prototype._compositeManually = function () {
        var e = this.getLayer(Xe).ctx,
            t = this._domRoot.width,
            r = this._domRoot.height;
        e.clearRect(0, 0, t, r), this.eachBuiltinLayer(function (i) {
            i.virtual && e.drawImage(i.dom, 0, 0, t, r)
        })
    }, a.prototype._doPaintList = function (e, t, r) {
        for (var i = this, n = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
            var l = this._zlevelList[s],
                u = this._layers[l];
            u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && n.push(u)
        }
        for (var v = !0, h = !1, c = function (d) {
                var g = n[d],
                    y = g.ctx,
                    x = o && g.createRepaintRects(e, t, f._width, f._height),
                    m = r ? g.__startIndex : g.__drawIndex,
                    S = !r && g.incremental && Date.now,
                    _ = S && Date.now(),
                    b = g.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
                if (g.__startIndex === g.__endIndex) g.clear(!1, b, x);
                else if (m === g.__startIndex) {
                    var w = e[m];
                    (!w.incremental || !w.notClear || r) && g.clear(!1, b, x)
                }
                m === -1 && (console.error("For some unknown reason. drawIndex is -1"), m = g.__startIndex);
                var A, C = function (M) {
                    var P = {
                        inHover: !1,
                        allClipped: !1,
                        prevEl: null,
                        viewWidth: i._width,
                        viewHeight: i._height
                    };
                    for (A = m; A < g.__endIndex; A++) {
                        var R = e[A];
                        if (R.__inHover && (h = !0), i._doPaintEl(R, g, o, M, P, A === g.__endIndex - 1), S) {
                            var k = Date.now() - _;
                            if (k > 15) break
                        }
                    }
                    P.prevElClipPaths && y.restore()
                };
                if (x)
                    if (x.length === 0) A = g.__endIndex;
                    else
                        for (var D = f.dpr, I = 0; I < x.length; ++I) {
                            var L = x[I];
                            y.save(), y.beginPath(), y.rect(L.x * D, L.y * D, L.width * D, L.height * D), y.clip(), C(L), y.restore()
                        } else y.save(), C(), y.restore();
                g.__drawIndex = A, g.__drawIndex < g.__endIndex && (v = !1)
            }, f = this, p = 0; p < n.length; p++) c(p);
        return Nt.wxa && T(this._layers, function (d) {
            d && d.ctx && d.ctx.draw && d.ctx.draw()
        }), {
            finished: v,
            needsRefreshHover: h
        }
    }, a.prototype._doPaintEl = function (e, t, r, i, n, o) {
        var s = t.ctx;
        if (r) {
            var l = e.getPaintRect();
            (!i || l && l.intersect(i)) && (Ja(s, e, n, o), e.setPrevPaintRect(l))
        } else Ja(s, e, n, o)
    }, a.prototype.getLayer = function (e, t) {
        this._singleCanvas && !this._needsManuallyCompositing && (e = Xe);
        var r = this._layers[e];
        return r || (r = new On("zr_" + e, this, this.dpr), r.zlevel = e, r.__builtin__ = !0, this._layerConfig[e] ? ct(r, this._layerConfig[e], !0) : this._layerConfig[e - ri] && ct(r, this._layerConfig[e - ri], !0), t && (r.virtual = t), this.insertLayer(e, r), r.initContext()), r
    }, a.prototype.insertLayer = function (e, t) {
        var r = this._layers,
            i = this._zlevelList,
            n = i.length,
            o = this._domRoot,
            s = null,
            l = -1;
        if (!r[e] && gx(t)) {
            if (n > 0 && e > i[0]) {
                for (l = 0; l < n - 1 && !(i[l] < e && i[l + 1] > e); l++);
                s = r[i[l]]
            }
            if (i.splice(l + 1, 0, e), r[e] = t, !t.virtual)
                if (s) {
                    var u = s.dom;
                    u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom)
                } else o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
            t.painter || (t.painter = this)
        }
    }, a.prototype.eachLayer = function (e, t) {
        for (var r = this._zlevelList, i = 0; i < r.length; i++) {
            var n = r[i];
            e.call(t, this._layers[n], n)
        }
    }, a.prototype.eachBuiltinLayer = function (e, t) {
        for (var r = this._zlevelList, i = 0; i < r.length; i++) {
            var n = r[i],
                o = this._layers[n];
            o.__builtin__ && e.call(t, o, n)
        }
    }, a.prototype.eachOtherLayer = function (e, t) {
        for (var r = this._zlevelList, i = 0; i < r.length; i++) {
            var n = r[i],
                o = this._layers[n];
            o.__builtin__ || e.call(t, o, n)
        }
    }, a.prototype.getLayers = function () {
        return this._layers
    }, a.prototype._updateLayerStatus = function (e) {
        this.eachBuiltinLayer(function (h, c) {
            h.__dirty = h.__used = !1
        });

        function t(h) {
            n && (n.__endIndex !== h && (n.__dirty = !0), n.__endIndex = h)
        }
        if (this._singleCanvas)
            for (var r = 1; r < e.length; r++) {
                var i = e[r];
                if (i.zlevel !== e[r - 1].zlevel || i.incremental) {
                    this._needsManuallyCompositing = !0;
                    break
                }
            }
        var n = null,
            o = 0,
            s, l;
        for (l = 0; l < e.length; l++) {
            var i = e[l],
                u = i.zlevel,
                v = void 0;
            s !== u && (s = u, o = 0), i.incremental ? (v = this.getLayer(u + dx, this._needsManuallyCompositing), v.incremental = !0, o = 1) : v = this.getLayer(u + (o > 0 ? ri : 0), this._needsManuallyCompositing), v.__builtin__ || Hy("ZLevel " + u + " has been used by unkown layer " + v.id), v !== n && (v.__used = !0, v.__startIndex !== l && (v.__dirty = !0), v.__startIndex = l, v.incremental ? v.__drawIndex = -1 : v.__drawIndex = l, t(l), n = v), i.__dirty & $o && !i.__inHover && (v.__dirty = !0, v.incremental && v.__drawIndex < 0 && (v.__drawIndex = l))
        }
        t(l), this.eachBuiltinLayer(function (h, c) {
            !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex)
        })
    }, a.prototype.clear = function () {
        return this.eachBuiltinLayer(this._clearLayer), this
    }, a.prototype._clearLayer = function (e) {
        e.clear()
    }, a.prototype.setBackgroundColor = function (e) {
        this._backgroundColor = e, T(this._layers, function (t) {
            t.setUnpainted()
        })
    }, a.prototype.configLayer = function (e, t) {
        if (t) {
            var r = this._layerConfig;
            r[e] ? ct(r[e], t, !0) : r[e] = t;
            for (var i = 0; i < this._zlevelList.length; i++) {
                var n = this._zlevelList[i];
                if (n === e || n === e + ri) {
                    var o = this._layers[n];
                    ct(o, r[e], !0)
                }
            }
        }
    }, a.prototype.delLayer = function (e) {
        var t = this._layers,
            r = this._zlevelList,
            i = t[e];
        i && (i.dom.parentNode.removeChild(i.dom), delete t[e], r.splice(ft(r, e), 1))
    }, a.prototype.resize = function (e, t) {
        if (this._domRoot.style) {
            var r = this._domRoot;
            r.style.display = "none";
            var i = this._opts,
                n = this.root;
            if (e != null && (i.width = e), t != null && (i.height = t), e = kr(n, 0, i), t = kr(n, 1, i), r.style.display = "", this._width !== e || t !== this._height) {
                r.style.width = e + "px", r.style.height = t + "px";
                for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
                this.refresh(!0)
            }
            this._width = e, this._height = t
        } else {
            if (e == null || t == null) return;
            this._width = e, this._height = t, this.getLayer(Xe).resize(e, t)
        }
        return this
    }, a.prototype.clearLayer = function (e) {
        var t = this._layers[e];
        t && t.clear()
    }, a.prototype.dispose = function () {
        this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
    }, a.prototype.getRenderedCanvas = function (e) {
        if (e = e || {}, this._singleCanvas && !this._compositeManually) return this._layers[Xe].dom;
        var t = new On("image", this, e.pixelRatio || this.dpr);
        t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
        var r = t.ctx;
        if (e.pixelRatio <= this.dpr) {
            this.refresh();
            var i = t.dom.width,
                n = t.dom.height;
            this.eachLayer(function (h) {
                h.__builtin__ ? r.drawImage(h.dom, 0, 0, i, n) : h.renderToCanvas && (r.save(), h.renderToCanvas(r), r.restore())
            })
        } else
            for (var o = {
                    inHover: !1,
                    viewWidth: this._width,
                    viewHeight: this._height
                }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
                var v = s[l];
                Ja(r, v, o, l === u - 1)
            }
        return t.dom
    }, a.prototype.getWidth = function () {
        return this._width
    }, a.prototype.getHeight = function () {
        return this._height
    }, a
}();
const xx = mx;

function Sx(a) {
    a.registerPainter("canvas", xx)
}
var _x = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.hasSymbolVisual = !0, t
    }
    return e.prototype.getInitialData = function (t) {
        return dr(null, this, {
            useEncodeDefaulter: !0
        })
    }, e.prototype.getLegendIcon = function (t) {
        var r = new U,
            i = Et("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
        r.add(i), i.setStyle(t.lineStyle);
        var n = this.getData().getVisual("symbol"),
            o = this.getData().getVisual("symbolRotate"),
            s = n === "none" ? "circle" : n,
            l = t.itemHeight * .8,
            u = Et(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
        r.add(u), u.setStyle(t.itemStyle);
        var v = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
        return u.rotation = v * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), r
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
        z: 3,
        coordinateSystem: "cartesian2d",
        legendHoverLink: !0,
        clip: !0,
        label: {
            position: "top"
        },
        endLabel: {
            show: !1,
            valueAnimation: !0,
            distance: 8
        },
        lineStyle: {
            width: 2,
            type: "solid"
        },
        emphasis: {
            scale: !0
        },
        step: !1,
        smooth: !1,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: !0,
        showAllSymbol: "auto",
        connectNulls: !1,
        sampling: "none",
        animationEasing: "linear",
        progressive: 0,
        hoverLayerThreshold: 1 / 0,
        universalTransition: {
            divideShape: "clone"
        },
        triggerLineEvent: !1
    }, e
}(Vt);
const bx = _x;
var Ua = function (a) {
    E(e, a);

    function e(t, r, i, n) {
        var o = a.call(this) || this;
        return o.updateData(t, r, i, n), o
    }
    return e.prototype._createSymbol = function (t, r, i, n, o) {
        this.removeAll();
        var s = Et(t, -1, -1, 2, 2, null, o);
        s.attr({
            z2: 100,
            culling: !0,
            scaleX: n[0] / 2,
            scaleY: n[1] / 2
        }), s.drift = wx, this._symbolType = t, this.add(s)
    }, e.prototype.stopSymbolAnimation = function (t) {
        this.childAt(0).stopAnimation(null, t)
    }, e.prototype.getSymbolType = function () {
        return this._symbolType
    }, e.prototype.getSymbolPath = function () {
        return this.childAt(0)
    }, e.prototype.highlight = function () {
        Br(this.childAt(0))
    }, e.prototype.downplay = function () {
        Hr(this.childAt(0))
    }, e.prototype.setZ = function (t, r) {
        var i = this.childAt(0);
        i.zlevel = t, i.z = r
    }, e.prototype.setDraggable = function (t, r) {
        var i = this.childAt(0);
        i.draggable = t, i.cursor = !r && t ? "move" : i.cursor
    }, e.prototype.updateData = function (t, r, i, n) {
        this.silent = !1;
        var o = t.getItemVisual(r, "symbol") || "circle",
            s = t.hostModel,
            l = e.getSymbolSize(t, r),
            u = o !== this._symbolType,
            v = n && n.disableAnimation;
        if (u) {
            var h = t.getItemVisual(r, "symbolKeepAspect");
            this._createSymbol(o, t, r, l, h)
        } else {
            var c = this.childAt(0);
            c.silent = !1;
            var f = {
                scaleX: l[0] / 2,
                scaleY: l[1] / 2
            };
            v ? c.attr(f) : yt(c, f, s, r), gr(c)
        }
        if (this._updateCommon(t, r, l, i, n), u) {
            var c = this.childAt(0);
            if (!v) {
                var f = {
                    scaleX: this._sizeX,
                    scaleY: this._sizeY,
                    style: {
                        opacity: c.style.opacity
                    }
                };
                c.scaleX = c.scaleY = 0, c.style.opacity = 0, Yt(c, f, s, r)
            }
        }
        v && this.childAt(0).stopAnimation("leave")
    }, e.prototype._updateCommon = function (t, r, i, n, o) {
        var s = this.childAt(0),
            l = t.hostModel,
            u, v, h, c, f, p, d, g, y;
        if (n && (u = n.emphasisItemStyle, v = n.blurItemStyle, h = n.selectItemStyle, c = n.focus, f = n.blurScope, d = n.labelStatesModels, g = n.hoverScale, y = n.cursorStyle, p = n.emphasisDisabled), !n || t.hasItemOption) {
            var x = n && n.itemModel ? n.itemModel : t.getItemModel(r),
                m = x.getModel("emphasis");
            u = m.getModel("itemStyle").getItemStyle(), h = x.getModel(["select", "itemStyle"]).getItemStyle(), v = x.getModel(["blur", "itemStyle"]).getItemStyle(), c = m.get("focus"), f = m.get("blurScope"), p = m.get("disabled"), d = Gt(x), g = m.getShallow("scale"), y = x.getShallow("cursor")
        }
        var S = t.getItemVisual(r, "symbolRotate");
        s.attr("rotation", (S || 0) * Math.PI / 180 || 0);
        var _ = jr(t.getItemVisual(r, "symbolOffset"), i);
        _ && (s.x = _[0], s.y = _[1]), y && s.attr("cursor", y);
        var b = t.getItemVisual(r, "style"),
            w = b.fill;
        if (s instanceof ge) {
            var A = s.style;
            s.useStyle(W({
                image: A.image,
                x: A.x,
                y: A.y,
                width: A.width,
                height: A.height
            }, b))
        } else s.__isEmptyBrush ? s.useStyle(W({}, b)) : s.useStyle(b), s.style.decal = null, s.setColor(w, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
        var C = t.getItemVisual(r, "liftZ"),
            D = this._z2;
        C != null ? D == null && (this._z2 = s.z2, s.z2 += C) : D != null && (s.z2 = D, this._z2 = null);
        var I = o && o.useNameLabel;
        Xt(s, d, {
            labelFetcher: l,
            labelDataIndex: r,
            defaultText: L,
            inheritColor: w,
            defaultOpacity: b.opacity
        });

        function L(R) {
            return I ? t.getName(R) : wa(t, R)
        }
        this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
        var M = s.ensureState("emphasis");
        M.style = u, s.ensureState("select").style = h, s.ensureState("blur").style = v;
        var P = g == null || g === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(g) && g > 0 ? +g : 1;
        M.scaleX = this._sizeX * P, M.scaleY = this._sizeY * P, this.setSymbolScale(1), Tt(this, c, f, p)
    }, e.prototype.setSymbolScale = function (t) {
        this.scaleX = this.scaleY = t
    }, e.prototype.fadeOut = function (t, r, i) {
        var n = this.childAt(0),
            o = tt(this).dataIndex,
            s = i && i.animation;
        if (this.silent = n.silent = !0, i && i.fadeLabel) {
            var l = n.getTextContent();
            l && Fr(l, {
                style: {
                    opacity: 0
                }
            }, r, {
                dataIndex: o,
                removeOpt: s,
                cb: function () {
                    n.removeTextContent()
                }
            })
        } else n.removeTextContent();
        Fr(n, {
            style: {
                opacity: 0
            },
            scaleX: 0,
            scaleY: 0
        }, r, {
            dataIndex: o,
            cb: t,
            removeOpt: s
        })
    }, e.getSymbolSize = function (t, r) {
        return Na(t.getItemVisual(r, "symbolSize"))
    }, e
}(U);

function wx(a, e) {
    this.parent.drift(a, e)
}

function zn(a, e, t, r) {
    return e && !isNaN(e[0]) && !isNaN(e[1]) && !(r.isIgnore && r.isIgnore(t)) && !(r.clipShape && !r.clipShape.contain(e[0], e[1])) && a.getItemVisual(t, "symbol") !== "none"
}

function Ku(a) {
    return a != null && !St(a) && (a = {
        isIgnore: a
    }), a || {}
}

function qu(a) {
    var e = a.hostModel,
        t = e.getModel("emphasis");
    return {
        emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
        blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
        selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
        focus: t.get("focus"),
        blurScope: t.get("blurScope"),
        emphasisDisabled: t.get("disabled"),
        hoverScale: t.get("scale"),
        labelStatesModels: Gt(e),
        cursorStyle: e.get("cursor")
    }
}
var Ya = function () {
    function a(e) {
        this.group = new U, this._SymbolCtor = e || Ua
    }
    return a.prototype.updateData = function (e, t) {
        this._progressiveEls = null, t = Ku(t);
        var r = this.group,
            i = e.hostModel,
            n = this._data,
            o = this._SymbolCtor,
            s = t.disableAnimation,
            l = qu(e),
            u = {
                disableAnimation: s
            },
            v = t.getSymbolPoint || function (h) {
                return e.getItemLayout(h)
            };
        n || r.removeAll(), e.diff(n).add(function (h) {
            var c = v(h);
            if (zn(e, c, h, t)) {
                var f = new o(e, h, l, u);
                f.setPosition(c), e.setItemGraphicEl(h, f), r.add(f)
            }
        }).update(function (h, c) {
            var f = n.getItemGraphicEl(c),
                p = v(h);
            if (!zn(e, p, h, t)) {
                r.remove(f);
                return
            }
            var d = e.getItemVisual(h, "symbol") || "circle",
                g = f && f.getSymbolType && f.getSymbolType();
            if (!f || g && g !== d) r.remove(f), f = new o(e, h, l, u), f.setPosition(p);
            else {
                f.updateData(e, h, l, u);
                var y = {
                    x: p[0],
                    y: p[1]
                };
                s ? f.attr(y) : yt(f, y, i)
            }
            r.add(f), e.setItemGraphicEl(h, f)
        }).remove(function (h) {
            var c = n.getItemGraphicEl(h);
            c && c.fadeOut(function () {
                r.remove(c)
            }, i)
        }).execute(), this._getSymbolPoint = v, this._data = e
    }, a.prototype.updateLayout = function () {
        var e = this,
            t = this._data;
        t && t.eachItemGraphicEl(function (r, i) {
            var n = e._getSymbolPoint(i);
            r.setPosition(n), r.markRedraw()
        })
    }, a.prototype.incrementalPrepareUpdate = function (e) {
        this._seriesScope = qu(e), this._data = null, this.group.removeAll()
    }, a.prototype.incrementalUpdate = function (e, t, r) {
        this._progressiveEls = [], r = Ku(r);

        function i(l) {
            l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0)
        }
        for (var n = e.start; n < e.end; n++) {
            var o = t.getItemLayout(n);
            if (zn(t, o, n, r)) {
                var s = new this._SymbolCtor(t, n, this._seriesScope);
                s.traverse(i), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(n, s), this._progressiveEls.push(s)
            }
        }
    }, a.prototype.eachRendered = function (e) {
        Ga(this._progressiveEls || this.group, e)
    }, a.prototype.remove = function (e) {
        var t = this.group,
            r = this._data;
        r && e ? r.eachItemGraphicEl(function (i) {
            i.fadeOut(function () {
                t.remove(i)
            }, r.hostModel)
        }) : t.removeAll()
    }, a
}();

function Vp(a, e, t) {
    var r = a.getBaseAxis(),
        i = a.getOtherAxis(r),
        n = Ax(i, t),
        o = r.dim,
        s = i.dim,
        l = e.mapDimension(s),
        u = e.mapDimension(o),
        v = s === "x" || s === "radius" ? 1 : 0,
        h = G(a.dimensions, function (p) {
            return e.mapDimension(p)
        }),
        c = !1,
        f = e.getCalculationInfo("stackResultDimension");
    return Wr(e, h[0]) && (c = !0, h[0] = f), Wr(e, h[1]) && (c = !0, h[1] = f), {
        dataDimsForPoint: h,
        valueStart: n,
        valueAxisDim: s,
        baseAxisDim: o,
        stacked: !!c,
        valueDim: l,
        baseDim: u,
        baseDataOffset: v,
        stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
    }
}

function Ax(a, e) {
    var t = 0,
        r = a.scale.getExtent();
    return e === "start" ? t = r[0] : e === "end" ? t = r[1] : te(e) && !isNaN(e) ? t = e : r[0] > 0 ? t = r[0] : r[1] < 0 && (t = r[1]), t
}

function Op(a, e, t, r) {
    var i = NaN;
    a.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = a.valueStart);
    var n = a.baseDataOffset,
        o = [];
    return o[n] = t.get(a.baseDim, r), o[1 - n] = i, e.dataToPoint(o)
}

function Tx(a, e) {
    var t = [];
    return e.diff(a).add(function (r) {
        t.push({
            cmd: "+",
            idx: r
        })
    }).update(function (r, i) {
        t.push({
            cmd: "=",
            idx: i,
            idx1: r
        })
    }).remove(function (r) {
        t.push({
            cmd: "-",
            idx: r
        })
    }).execute(), t
}

function Cx(a, e, t, r, i, n, o, s) {
    for (var l = Tx(a, e), u = [], v = [], h = [], c = [], f = [], p = [], d = [], g = Vp(i, e, o), y = a.getLayout("points") || [], x = e.getLayout("points") || [], m = 0; m < l.length; m++) {
        var S = l[m],
            _ = !0,
            b = void 0,
            w = void 0;
        switch (S.cmd) {
            case "=":
                b = S.idx * 2, w = S.idx1 * 2;
                var A = y[b],
                    C = y[b + 1],
                    D = x[w],
                    I = x[w + 1];
                (isNaN(A) || isNaN(C)) && (A = D, C = I), u.push(A, C), v.push(D, I), h.push(t[b], t[b + 1]), c.push(r[w], r[w + 1]), d.push(e.getRawIndex(S.idx1));
                break;
            case "+":
                var L = S.idx,
                    M = g.dataDimsForPoint,
                    P = i.dataToPoint([e.get(M[0], L), e.get(M[1], L)]);
                w = L * 2, u.push(P[0], P[1]), v.push(x[w], x[w + 1]);
                var R = Op(g, i, e, L);
                h.push(R[0], R[1]), c.push(r[w], r[w + 1]), d.push(e.getRawIndex(L));
                break;
            case "-":
                _ = !1
        }
        _ && (f.push(S), p.push(p.length))
    }
    p.sort(function (nt, st) {
        return d[nt] - d[st]
    });
    for (var k = u.length, V = or(k), O = or(k), z = or(k), $ = or(k), Z = [], m = 0; m < p.length; m++) {
        var et = p[m],
            J = m * 2,
            X = et * 2;
        V[J] = u[X], V[J + 1] = u[X + 1], O[J] = v[X], O[J + 1] = v[X + 1], z[J] = h[X], z[J + 1] = h[X + 1], $[J] = c[X], $[J + 1] = c[X + 1], Z[m] = f[et]
    }
    return {
        current: V,
        next: O,
        stackedOnCurrent: z,
        stackedOnNext: $,
        status: Z
    }
}
var De = Math.min,
    Ie = Math.max;

function lr(a, e) {
    return isNaN(a) || isNaN(e)
}

function os(a, e, t, r, i, n, o, s, l) {
    for (var u, v, h, c, f, p, d = t, g = 0; g < r; g++) {
        var y = e[d * 2],
            x = e[d * 2 + 1];
        if (d >= i || d < 0) break;
        if (lr(y, x)) {
            if (l) {
                d += n;
                continue
            }
            break
        }
        if (d === t) a[n > 0 ? "moveTo" : "lineTo"](y, x), h = y, c = x;
        else {
            var m = y - u,
                S = x - v;
            if (m * m + S * S < .5) {
                d += n;
                continue
            }
            if (o > 0) {
                for (var _ = d + n, b = e[_ * 2], w = e[_ * 2 + 1]; b === y && w === x && g < r;) g++, _ += n, d += n, b = e[_ * 2], w = e[_ * 2 + 1], y = e[d * 2], x = e[d * 2 + 1], m = y - u, S = x - v;
                var A = g + 1;
                if (l)
                    for (; lr(b, w) && A < r;) A++, _ += n, b = e[_ * 2], w = e[_ * 2 + 1];
                var C = .5,
                    D = 0,
                    I = 0,
                    L = void 0,
                    M = void 0;
                if (A >= r || lr(b, w)) f = y, p = x;
                else {
                    D = b - u, I = w - v;
                    var P = y - u,
                        R = b - y,
                        k = x - v,
                        V = w - x,
                        O = void 0,
                        z = void 0;
                    if (s === "x") {
                        O = Math.abs(P), z = Math.abs(R);
                        var $ = D > 0 ? 1 : -1;
                        f = y - $ * O * o, p = x, L = y + $ * z * o, M = x
                    } else if (s === "y") {
                        O = Math.abs(k), z = Math.abs(V);
                        var Z = I > 0 ? 1 : -1;
                        f = y, p = x - Z * O * o, L = y, M = x + Z * z * o
                    } else O = Math.sqrt(P * P + k * k), z = Math.sqrt(R * R + V * V), C = z / (z + O), f = y - D * o * (1 - C), p = x - I * o * (1 - C), L = y + D * o * C, M = x + I * o * C, L = De(L, Ie(b, y)), M = De(M, Ie(w, x)), L = Ie(L, De(b, y)), M = Ie(M, De(w, x)), D = L - y, I = M - x, f = y - D * O / z, p = x - I * O / z, f = De(f, Ie(u, y)), p = De(p, Ie(v, x)), f = Ie(f, De(u, y)), p = Ie(p, De(v, x)), D = y - f, I = x - p, L = y + D * z / O, M = x + I * z / O
                }
                a.bezierCurveTo(h, c, f, p, y, x), h = L, c = M
            } else a.lineTo(y, x)
        }
        u = y, v = x, d += n
    }
    return g
}
var zp = function () {
        function a() {
            this.smooth = 0, this.smoothConstraint = !0
        }
        return a
    }(),
    Dx = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "ec-polyline", r
        }
        return e.prototype.getDefaultStyle = function () {
            return {
                stroke: "#000",
                fill: null
            }
        }, e.prototype.getDefaultShape = function () {
            return new zp
        }, e.prototype.buildPath = function (t, r) {
            var i = r.points,
                n = 0,
                o = i.length / 2;
            if (r.connectNulls) {
                for (; o > 0 && lr(i[o * 2 - 2], i[o * 2 - 1]); o--);
                for (; n < o && lr(i[n * 2], i[n * 2 + 1]); n++);
            }
            for (; n < o;) n += os(t, i, n, o, o, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1
        }, e.prototype.getPointOn = function (t, r) {
            this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
            for (var i = this.path, n = i.data, o = Zs.CMD, s, l, u = r === "x", v = [], h = 0; h < n.length;) {
                var c = n[h++],
                    f = void 0,
                    p = void 0,
                    d = void 0,
                    g = void 0,
                    y = void 0,
                    x = void 0,
                    m = void 0;
                switch (c) {
                    case o.M:
                        s = n[h++], l = n[h++];
                        break;
                    case o.L:
                        if (f = n[h++], p = n[h++], m = u ? (t - s) / (f - s) : (t - l) / (p - l), m <= 1 && m >= 0) {
                            var S = u ? (p - l) * m + l : (f - s) * m + s;
                            return u ? [t, S] : [S, t]
                        }
                        s = f, l = p;
                        break;
                    case o.C:
                        f = n[h++], p = n[h++], d = n[h++], g = n[h++], y = n[h++], x = n[h++];
                        var _ = u ? uu(s, f, d, y, t, v) : uu(l, p, g, x, t, v);
                        if (_ > 0)
                            for (var b = 0; b < _; b++) {
                                var w = v[b];
                                if (w <= 1 && w >= 0) {
                                    var S = u ? vu(l, p, g, x, w) : vu(s, f, d, y, w);
                                    return u ? [t, S] : [S, t]
                                }
                            }
                        s = y, l = x;
                        break
                }
            }
        }, e
    }(Pt),
    Ix = function (a) {
        E(e, a);

        function e() {
            return a !== null && a.apply(this, arguments) || this
        }
        return e
    }(zp),
    Np = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "ec-polygon", r
        }
        return e.prototype.getDefaultShape = function () {
            return new Ix
        }, e.prototype.buildPath = function (t, r) {
            var i = r.points,
                n = r.stackedOnPoints,
                o = 0,
                s = i.length / 2,
                l = r.smoothMonotone;
            if (r.connectNulls) {
                for (; s > 0 && lr(i[s * 2 - 2], i[s * 2 - 1]); s--);
                for (; o < s && lr(i[o * 2], i[o * 2 + 1]); o++);
            }
            for (; o < s;) {
                var u = os(t, i, o, s, s, 1, r.smooth, l, r.connectNulls);
                os(t, n, o + u - 1, u, s, -1, r.stackedOnSmooth, l, r.connectNulls), o += u + 1, t.closePath()
            }
        }, e
    }(Pt);

function ju(a, e) {
    if (a.length === e.length) {
        for (var t = 0; t < a.length; t++)
            if (a[t] !== e[t]) return;
        return !0
    }
}

function Ju(a) {
    for (var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, n = 0; n < a.length;) {
        var o = a[n++],
            s = a[n++];
        isNaN(o) || (e = Math.min(o, e), r = Math.max(o, r)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i))
    }
    return [
        [e, t],
        [r, i]
    ]
}

function Qu(a, e) {
    var t = Ju(a),
        r = t[0],
        i = t[1],
        n = Ju(e),
        o = n[0],
        s = n[1];
    return Math.max(Math.abs(r[0] - o[0]), Math.abs(r[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]))
}

function tv(a) {
    return te(a) ? a : a ? .5 : 0
}

function Lx(a, e, t) {
    if (!t.valueDim) return [];
    for (var r = e.count(), i = or(r * 2), n = 0; n < r; n++) {
        var o = Op(t, a, e, n);
        i[n * 2] = o[0], i[n * 2 + 1] = o[1]
    }
    return i
}

function Le(a, e, t, r) {
    var i = e.getBaseAxis(),
        n = i.dim === "x" || i.dim === "radius" ? 0 : 1,
        o = [],
        s = 0,
        l = [],
        u = [],
        v = [],
        h = [];
    if (r) {
        for (s = 0; s < a.length; s += 2) !isNaN(a[s]) && !isNaN(a[s + 1]) && h.push(a[s], a[s + 1]);
        a = h
    }
    for (s = 0; s < a.length - 2; s += 2) switch (v[0] = a[s + 2], v[1] = a[s + 3], u[0] = a[s], u[1] = a[s + 1], o.push(u[0], u[1]), t) {
        case "end":
            l[n] = v[n], l[1 - n] = u[1 - n], o.push(l[0], l[1]);
            break;
        case "middle":
            var c = (u[n] + v[n]) / 2,
                f = [];
            l[n] = f[n] = c, l[1 - n] = u[1 - n], f[1 - n] = v[1 - n], o.push(l[0], l[1]), o.push(f[0], f[1]);
            break;
        default:
            l[n] = u[n], l[1 - n] = v[1 - n], o.push(l[0], l[1])
    }
    return o.push(a[s++], a[s++]), o
}

function Mx(a, e) {
    var t = [],
        r = a.length,
        i, n;

    function o(v, h, c) {
        var f = v.coord,
            p = (c - f) / (h.coord - f),
            d = Uy(p, [v.color, h.color]);
        return {
            coord: c,
            color: d
        }
    }
    for (var s = 0; s < r; s++) {
        var l = a[s],
            u = l.coord;
        if (u < 0) i = l;
        else if (u > e) {
            n ? t.push(o(n, l, e)) : i && t.push(o(i, l, 0), o(i, l, e));
            break
        } else i && (t.push(o(i, l, 0)), i = null), t.push(l), n = l
    }
    return t
}

function Px(a, e, t) {
    var r = a.getVisual("visualMeta");
    if (!(!r || !r.length || !a.count()) && e.type === "cartesian2d") {
        for (var i, n, o = r.length - 1; o >= 0; o--) {
            var s = a.getDimensionInfo(r[o].dimension);
            if (i = s && s.coordDim, i === "x" || i === "y") {
                n = r[o];
                break
            }
        }
        if (n) {
            var l = e.getAxis(i),
                u = G(n.stops, function (m) {
                    return {
                        coord: l.toGlobalCoord(l.dataToCoord(m.value)),
                        color: m.color
                    }
                }),
                v = u.length,
                h = n.outerColors.slice();
            v && u[0].coord > u[v - 1].coord && (u.reverse(), h.reverse());
            var c = Mx(u, i === "x" ? t.getWidth() : t.getHeight()),
                f = c.length;
            if (!f && v) return u[0].coord < 0 ? h[1] ? h[1] : u[v - 1].color : h[0] ? h[0] : u[0].color;
            var p = 10,
                d = c[0].coord - p,
                g = c[f - 1].coord + p,
                y = g - d;
            if (y < .001) return "transparent";
            T(c, function (m) {
                m.offset = (m.coord - d) / y
            }), c.push({
                offset: f ? c[f - 1].offset : .5,
                color: h[1] || "transparent"
            }), c.unshift({
                offset: f ? c[0].offset : .5,
                color: h[0] || "transparent"
            });
            var x = new qi(0, 0, 0, 0, c, !0);
            return x[i] = d, x[i + "2"] = g, x
        }
    }
}

function Rx(a, e, t) {
    var r = a.get("showAllSymbol"),
        i = r === "auto";
    if (!(r && !i)) {
        var n = t.getAxesByScale("ordinal")[0];
        if (n && !(i && Ex(n, e))) {
            var o = e.mapDimension(n.dim),
                s = {};
            return T(n.getViewLabels(), function (l) {
                    var u = n.scale.getRawOrdinalNumber(l.tickValue);
                    s[u] = 1
                }),
                function (l) {
                    return !s.hasOwnProperty(e.get(o, l))
                }
        }
    }
}

function Ex(a, e) {
    var t = a.getExtent(),
        r = Math.abs(t[1] - t[0]) / a.scale.count();
    isNaN(r) && (r = 0);
    for (var i = e.count(), n = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += n)
        if (Ua.getSymbolSize(e, o)[a.isHorizontal() ? 1 : 0] * 1.5 > r) return !1;
    return !0
}

function kx(a, e) {
    return isNaN(a) || isNaN(e)
}

function Vx(a) {
    for (var e = a.length / 2; e > 0 && kx(a[e * 2 - 2], a[e * 2 - 1]); e--);
    return e - 1
}

function ev(a, e) {
    return [a[e * 2], a[e * 2 + 1]]
}

function Ox(a, e, t) {
    for (var r = a.length / 2, i = t === "x" ? 0 : 1, n, o, s = 0, l = -1, u = 0; u < r; u++)
        if (o = a[u * 2 + i], !(isNaN(o) || isNaN(a[u * 2 + 1 - i]))) {
            if (u === 0) {
                n = o;
                continue
            }
            if (n <= e && o >= e || n >= e && o <= e) {
                l = u;
                break
            }
            s = u, n = o
        } return {
        range: [s, l],
        t: (e - n) / (o - n)
    }
}

function Gp(a) {
    if (a.get(["endLabel", "show"])) return !0;
    for (var e = 0; e < Aa.length; e++)
        if (a.get([Aa[e], "endLabel", "show"])) return !0;
    return !1
}

function Nn(a, e, t, r) {
    if (Ba(e, "cartesian2d")) {
        var i = r.getModel("endLabel"),
            n = i.get("valueAnimation"),
            o = r.getData(),
            s = {
                lastFrameIndex: 0
            },
            l = Gp(r) ? function (f, p) {
                a._endLabelOnDuring(f, p, o, s, n, i, e)
            } : null,
            u = e.getBaseAxis().isHorizontal(),
            v = $y(e, t, r, function () {
                var f = a._endLabel;
                f && t && s.originalX != null && f.attr({
                    x: s.originalX,
                    y: s.originalY
                })
            }, l);
        if (!r.get("clip", !0)) {
            var h = v.shape,
                c = Math.max(h.width, h.height);
            u ? (h.y -= c, h.height += c * 2) : (h.x -= c, h.width += c * 2)
        }
        return l && l(1, v), v
    } else return Zy(e, t, r)
}

function zx(a, e) {
    var t = e.getBaseAxis(),
        r = t.isHorizontal(),
        i = t.inverse,
        n = r ? i ? "right" : "left" : "center",
        o = r ? "middle" : i ? "top" : "bottom";
    return {
        normal: {
            align: a.get("align") || n,
            verticalAlign: a.get("verticalAlign") || o
        }
    }
}
var Nx = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.init = function () {
        var t = new U,
            r = new Ya;
        this.group.add(r.group), this._symbolDraw = r, this._lineGroup = t
    }, e.prototype.render = function (t, r, i) {
        var n = this,
            o = t.coordinateSystem,
            s = this.group,
            l = t.getData(),
            u = t.getModel("lineStyle"),
            v = t.getModel("areaStyle"),
            h = l.getLayout("points") || [],
            c = o.type === "polar",
            f = this._coordSys,
            p = this._symbolDraw,
            d = this._polyline,
            g = this._polygon,
            y = this._lineGroup,
            x = !r.ssr && t.get("animation"),
            m = !v.isEmpty(),
            S = v.get("origin"),
            _ = Vp(o, l, S),
            b = m && Lx(o, l, _),
            w = t.get("showSymbol"),
            A = t.get("connectNulls"),
            C = w && !c && Rx(t, l, o),
            D = this._data;
        D && D.eachItemGraphicEl(function (st, it) {
            st.__temp && (s.remove(st), D.setItemGraphicEl(it, null))
        }), w || p.remove(), s.add(y);
        var I = c ? !1 : t.get("step"),
            L;
        o && o.getArea && t.get("clip", !0) && (L = o.getArea(), L.width != null ? (L.x -= .1, L.y -= .1, L.width += .2, L.height += .2) : L.r0 && (L.r0 -= .5, L.r += .5)), this._clipShapeForSymbol = L;
        var M = Px(l, o, i) || l.getVisual("style")[l.getVisual("drawType")];
        if (!(d && f.type === o.type && I === this._step)) w && p.updateData(l, {
            isIgnore: C,
            clipShape: L,
            disableAnimation: !0,
            getSymbolPoint: function (st) {
                return [h[st * 2], h[st * 2 + 1]]
            }
        }), x && this._initSymbolLabelAnimation(l, o, L), I && (h = Le(h, o, I, A), b && (b = Le(b, o, I, A))), d = this._newPolyline(h), m ? g = this._newPolygon(h, b) : g && (y.remove(g), g = this._polygon = null), c || this._initOrUpdateEndLabel(t, o, $r(M)), y.setClipPath(Nn(this, o, !0, t));
        else {
            m && !g ? g = this._newPolygon(h, b) : g && !m && (y.remove(g), g = this._polygon = null), c || this._initOrUpdateEndLabel(t, o, $r(M));
            var P = y.getClipPath();
            if (P) {
                var R = Nn(this, o, !1, t);
                Yt(P, {
                    shape: R.shape
                }, t)
            } else y.setClipPath(Nn(this, o, !0, t));
            w && p.updateData(l, {
                isIgnore: C,
                clipShape: L,
                disableAnimation: !0,
                getSymbolPoint: function (st) {
                    return [h[st * 2], h[st * 2 + 1]]
                }
            }), (!ju(this._stackedOnPoints, b) || !ju(this._points, h)) && (x ? this._doUpdateAnimation(l, b, o, i, I, S, A) : (I && (h = Le(h, o, I, A), b && (b = Le(b, o, I, A))), d.setShape({
                points: h
            }), g && g.setShape({
                points: h,
                stackedOnPoints: b
            })))
        }
        var k = t.getModel("emphasis"),
            V = k.get("focus"),
            O = k.get("blurScope"),
            z = k.get("disabled");
        if (d.useStyle(at(u.getLineStyle(), {
                fill: "none",
                stroke: M,
                lineJoin: "bevel"
            })), ee(d, t, "lineStyle"), d.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
            var $ = d.getState("emphasis").style;
            $.lineWidth = +d.style.lineWidth + 1
        }
        tt(d).seriesIndex = t.seriesIndex, Tt(d, V, O, z);
        var Z = tv(t.get("smooth")),
            et = t.get("smoothMonotone");
        if (d.setShape({
                smooth: Z,
                smoothMonotone: et,
                connectNulls: A
            }), g) {
            var J = l.getCalculationInfo("stackedOnSeries"),
                X = 0;
            g.useStyle(at(v.getAreaStyle(), {
                fill: M,
                opacity: .7,
                lineJoin: "bevel",
                decal: l.getVisual("style").decal
            })), J && (X = tv(J.get("smooth"))), g.setShape({
                smooth: Z,
                stackedOnSmooth: X,
                smoothMonotone: et,
                connectNulls: A
            }), ee(g, t, "areaStyle"), tt(g).seriesIndex = t.seriesIndex, Tt(g, V, O, z)
        }
        var nt = function (st) {
            n._changePolyState(st)
        };
        l.eachItemGraphicEl(function (st) {
            st && (st.onHoverStateChange = nt)
        }), this._polyline.onHoverStateChange = nt, this._data = l, this._coordSys = o, this._stackedOnPoints = b, this._points = h, this._step = I, this._valueOrigin = S, t.get("triggerLineEvent") && (this.packEventData(t, d), g && this.packEventData(t, g))
    }, e.prototype.packEventData = function (t, r) {
        tt(r).eventData = {
            componentType: "series",
            componentSubType: "line",
            componentIndex: t.componentIndex,
            seriesIndex: t.seriesIndex,
            seriesName: t.name,
            seriesType: "line"
        }
    }, e.prototype.highlight = function (t, r, i, n) {
        var o = t.getData(),
            s = Uo(o, n);
        if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
            var l = o.getLayout("points"),
                u = o.getItemGraphicEl(s);
            if (!u) {
                var v = l[s * 2],
                    h = l[s * 2 + 1];
                if (isNaN(v) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(v, h)) return;
                var c = t.get("zlevel") || 0,
                    f = t.get("z") || 0;
                u = new Ua(o, s), u.x = v, u.y = h, u.setZ(c, f);
                var p = u.getSymbolPath().getTextContent();
                p && (p.zlevel = c, p.z = f, p.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u)
            }
            u.highlight()
        } else At.prototype.highlight.call(this, t, r, i, n)
    }, e.prototype.downplay = function (t, r, i, n) {
        var o = t.getData(),
            s = Uo(o, n);
        if (this._changePolyState("normal"), s != null && s >= 0) {
            var l = o.getItemGraphicEl(s);
            l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay())
        } else At.prototype.downplay.call(this, t, r, i, n)
    }, e.prototype._changePolyState = function (t) {
        var r = this._polygon;
        Ti(this._polyline, t), r && Ti(r, t)
    }, e.prototype._newPolyline = function (t) {
        var r = this._polyline;
        return r && this._lineGroup.remove(r), r = new Dx({
            shape: {
                points: t
            },
            segmentIgnoreThreshold: 2,
            z2: 10
        }), this._lineGroup.add(r), this._polyline = r, r
    }, e.prototype._newPolygon = function (t, r) {
        var i = this._polygon;
        return i && this._lineGroup.remove(i), i = new Np({
            shape: {
                points: t,
                stackedOnPoints: r
            },
            segmentIgnoreThreshold: 2
        }), this._lineGroup.add(i), this._polygon = i, i
    }, e.prototype._initSymbolLabelAnimation = function (t, r, i) {
        var n, o, s = r.getBaseAxis(),
            l = s.inverse;
        r.type === "cartesian2d" ? (n = s.isHorizontal(), o = !1) : r.type === "polar" && (n = s.dim === "angle", o = !0);
        var u = t.hostModel,
            v = u.get("animationDuration");
        rt(v) && (v = v(null));
        var h = u.get("animationDelay") || 0,
            c = rt(h) ? h(null) : h;
        t.eachItemGraphicEl(function (f, p) {
            var d = f;
            if (d) {
                var g = [f.x, f.y],
                    y = void 0,
                    x = void 0,
                    m = void 0;
                if (i)
                    if (o) {
                        var S = i,
                            _ = r.pointToCoord(g);
                        n ? (y = S.startAngle, x = S.endAngle, m = -_[1] / 180 * Math.PI) : (y = S.r0, x = S.r, m = _[0])
                    } else {
                        var b = i;
                        n ? (y = b.x, x = b.x + b.width, m = f.x) : (y = b.y + b.height, x = b.y, m = f.y)
                    } var w = x === y ? 0 : (m - y) / (x - y);
                l && (w = 1 - w);
                var A = rt(h) ? h(p) : v * w + c,
                    C = d.getSymbolPath(),
                    D = C.getTextContent();
                d.attr({
                    scaleX: 0,
                    scaleY: 0
                }), d.animateTo({
                    scaleX: 1,
                    scaleY: 1
                }, {
                    duration: 200,
                    setToFinal: !0,
                    delay: A
                }), D && D.animateFrom({
                    style: {
                        opacity: 0
                    }
                }, {
                    duration: 300,
                    delay: A
                }), C.disableLabelAnimation = !0
            }
        })
    }, e.prototype._initOrUpdateEndLabel = function (t, r, i) {
        var n = t.getModel("endLabel");
        if (Gp(t)) {
            var o = t.getData(),
                s = this._polyline,
                l = o.getLayout("points");
            if (!l) {
                s.removeTextContent(), this._endLabel = null;
                return
            }
            var u = this._endLabel;
            u || (u = this._endLabel = new ut({
                z2: 200
            }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
            var v = Vx(l);
            v >= 0 && (Xt(s, Gt(t, "endLabel"), {
                inheritColor: i,
                labelFetcher: t,
                labelDataIndex: v,
                defaultText: function (h, c, f) {
                    return f != null ? Fy(o, f) : wa(o, h)
                },
                enableTextSetter: !0
            }, zx(n, r)), s.textConfig.position = null)
        } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null)
    }, e.prototype._endLabelOnDuring = function (t, r, i, n, o, s, l) {
        var u = this._endLabel,
            v = this._polyline;
        if (u) {
            t < 1 && n.originalX == null && (n.originalX = u.x, n.originalY = u.y);
            var h = i.getLayout("points"),
                c = i.hostModel,
                f = c.get("connectNulls"),
                p = s.get("precision"),
                d = s.get("distance") || 0,
                g = l.getBaseAxis(),
                y = g.isHorizontal(),
                x = g.inverse,
                m = r.shape,
                S = x ? y ? m.x : m.y + m.height : y ? m.x + m.width : m.y,
                _ = (y ? d : 0) * (x ? -1 : 1),
                b = (y ? 0 : -d) * (x ? -1 : 1),
                w = y ? "x" : "y",
                A = Ox(h, S, w),
                C = A.range,
                D = C[1] - C[0],
                I = void 0;
            if (D >= 1) {
                if (D > 1 && !f) {
                    var L = ev(h, C[0]);
                    u.attr({
                        x: L[0] + _,
                        y: L[1] + b
                    }), o && (I = c.getRawValue(C[0]))
                } else {
                    var L = v.getPointOn(S, w);
                    L && u.attr({
                        x: L[0] + _,
                        y: L[1] + b
                    });
                    var M = c.getRawValue(C[0]),
                        P = c.getRawValue(C[1]);
                    o && (I = Wy(i, p, M, P, A.t))
                }
                n.lastFrameIndex = C[0]
            } else {
                var R = t === 1 || n.lastFrameIndex > 0 ? C[0] : 0,
                    L = ev(h, R);
                o && (I = c.getRawValue(R)), u.attr({
                    x: L[0] + _,
                    y: L[1] + b
                })
            }
            if (o) {
                var k = Bf(u);
                typeof k.setLabelText == "function" && k.setLabelText(I)
            }
        }
    }, e.prototype._doUpdateAnimation = function (t, r, i, n, o, s, l) {
        var u = this._polyline,
            v = this._polygon,
            h = t.hostModel,
            c = Cx(this._data, t, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin),
            f = c.current,
            p = c.stackedOnCurrent,
            d = c.next,
            g = c.stackedOnNext;
        if (o && (f = Le(c.current, i, o, l), p = Le(c.stackedOnCurrent, i, o, l), d = Le(c.next, i, o, l), g = Le(c.stackedOnNext, i, o, l)), Qu(f, d) > 3e3 || v && Qu(p, g) > 3e3) {
            u.stopAnimation(), u.setShape({
                points: d
            }), v && (v.stopAnimation(), v.setShape({
                points: d,
                stackedOnPoints: g
            }));
            return
        }
        u.shape.__points = c.current, u.shape.points = f;
        var y = {
            shape: {
                points: d
            }
        };
        c.current !== f && (y.shape.__points = c.next), u.stopAnimation(), yt(u, y, h), v && (v.setShape({
            points: f,
            stackedOnPoints: p
        }), v.stopAnimation(), yt(v, {
            shape: {
                stackedOnPoints: g
            }
        }, h), u.shape.points !== v.shape.points && (v.shape.points = u.shape.points));
        for (var x = [], m = c.status, S = 0; S < m.length; S++) {
            var _ = m[S].cmd;
            if (_ === "=") {
                var b = t.getItemGraphicEl(m[S].idx1);
                b && x.push({
                    el: b,
                    ptIdx: S
                })
            }
        }
        u.animators && u.animators.length && u.animators[0].during(function () {
            v && v.dirtyShape();
            for (var w = u.shape.__points, A = 0; A < x.length; A++) {
                var C = x[A].el,
                    D = x[A].ptIdx * 2;
                C.x = w[D], C.y = w[D + 1], C.markRedraw()
            }
        })
    }, e.prototype.remove = function (t) {
        var r = this.group,
            i = this._data;
        this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function (n, o) {
            n.__temp && (r.remove(n), i.setItemGraphicEl(o, null))
        }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null
    }, e.type = "line", e
}(At);
const Gx = Nx;

function Xa(a, e) {
    return {
        seriesType: a,
        plan: ji(),
        reset: function (t) {
            var r = t.getData(),
                i = t.coordinateSystem,
                n = t.pipelineContext,
                o = e || n.large;
            if (i) {
                var s = G(i.dimensions, function (f) {
                        return r.mapDimension(f)
                    }).slice(0, 2),
                    l = s.length,
                    u = r.getCalculationInfo("stackResultDimension");
                Wr(r, s[0]) && (s[0] = u), Wr(r, s[1]) && (s[1] = u);
                var v = r.getStore(),
                    h = r.getDimensionIndex(s[0]),
                    c = r.getDimensionIndex(s[1]);
                return l && {
                    progress: function (f, p) {
                        for (var d = f.end - f.start, g = o && or(d * l), y = [], x = [], m = f.start, S = 0; m < f.end; m++) {
                            var _ = void 0;
                            if (l === 1) {
                                var b = v.get(h, m);
                                _ = i.dataToPoint(b, null, x)
                            } else y[0] = v.get(h, m), y[1] = v.get(c, m), _ = i.dataToPoint(y, null, x);
                            o ? (g[S++] = _[0], g[S++] = _[1]) : p.setItemLayout(m, _.slice())
                        }
                        o && p.setLayout("points", g)
                    }
                }
            }
        }
    }
}

function Bx(a) {
    a.registerChartView(Gx), a.registerSeriesModel(bx), a.registerLayout(Xa("line", !0)), a.registerVisual({
        seriesType: "line",
        reset: function (e) {
            var t = e.getData(),
                r = e.getModel("lineStyle").getLineStyle();
            r && !r.stroke && (r.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", r)
        }
    }), a.registerProcessor(a.PRIORITY.PROCESSOR.STATISTIC, Yy("line"))
}
var Hx = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.hasSymbolVisual = !0, t
    }
    return e.prototype.getInitialData = function (t, r) {
        return dr(null, this, {
            useEncodeDefaulter: !0
        })
    }, e.prototype.getProgressive = function () {
        var t = this.option.progressive;
        return t ? ? (this.option.large ? 5e3 : this.get("progressive"))
    }, e.prototype.getProgressiveThreshold = function () {
        var t = this.option.progressiveThreshold;
        return t ? ? (this.option.large ? 1e4 : this.get("progressiveThreshold"))
    }, e.prototype.brushSelector = function (t, r, i) {
        return i.point(r.getItemLayout(t))
    }, e.prototype.getZLevelKey = function () {
        return this.getData().count() > this.getProgressiveThreshold() ? this.id : ""
    }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
        coordinateSystem: "cartesian2d",
        z: 2,
        legendHoverLink: !0,
        symbolSize: 10,
        large: !1,
        largeThreshold: 2e3,
        itemStyle: {
            opacity: .8
        },
        emphasis: {
            scale: !0
        },
        clip: !0,
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        },
        universalTransition: {
            divideShape: "clone"
        }
    }, e
}(Vt);
const Fx = Hx;
var Bp = 4,
    Wx = function () {
        function a() {}
        return a
    }(),
    $x = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r._off = 0, r.hoverDataIdx = -1, r
        }
        return e.prototype.getDefaultShape = function () {
            return new Wx
        }, e.prototype.reset = function () {
            this.notClear = !1, this._off = 0
        }, e.prototype.buildPath = function (t, r) {
            var i = r.points,
                n = r.size,
                o = this.symbolProxy,
                s = o.shape,
                l = t.getContext ? t.getContext() : t,
                u = l && n[0] < Bp,
                v = this.softClipShape,
                h;
            if (u) {
                this._ctx = l;
                return
            }
            for (this._ctx = null, h = this._off; h < i.length;) {
                var c = i[h++],
                    f = i[h++];
                isNaN(c) || isNaN(f) || v && !v.contain(c, f) || (s.x = c - n[0] / 2, s.y = f - n[1] / 2, s.width = n[0], s.height = n[1], o.buildPath(t, s, !0))
            }
            this.incremental && (this._off = h, this.notClear = !0)
        }, e.prototype.afterBrush = function () {
            var t = this.shape,
                r = t.points,
                i = t.size,
                n = this._ctx,
                o = this.softClipShape,
                s;
            if (n) {
                for (s = this._off; s < r.length;) {
                    var l = r[s++],
                        u = r[s++];
                    isNaN(l) || isNaN(u) || o && !o.contain(l, u) || n.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1])
                }
                this.incremental && (this._off = s, this.notClear = !0)
            }
        }, e.prototype.findDataIndex = function (t, r) {
            for (var i = this.shape, n = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = n.length / 2 - 1; u >= 0; u--) {
                var v = u * 2,
                    h = n[v] - s / 2,
                    c = n[v + 1] - l / 2;
                if (t >= h && r >= c && t <= h + s && r <= c + l) return u
            }
            return -1
        }, e.prototype.contain = function (t, r) {
            var i = this.transformCoordToLocal(t, r),
                n = this.getBoundingRect();
            if (t = i[0], r = i[1], n.contain(t, r)) {
                var o = this.hoverDataIdx = this.findDataIndex(t, r);
                return o >= 0
            }
            return this.hoverDataIdx = -1, !1
        }, e.prototype.getBoundingRect = function () {
            var t = this._rect;
            if (!t) {
                for (var r = this.shape, i = r.points, n = r.size, o = n[0], s = n[1], l = 1 / 0, u = 1 / 0, v = -1 / 0, h = -1 / 0, c = 0; c < i.length;) {
                    var f = i[c++],
                        p = i[c++];
                    l = Math.min(f, l), v = Math.max(f, v), u = Math.min(p, u), h = Math.max(p, h)
                }
                t = this._rect = new gt(l - o / 2, u - s / 2, v - l + o, h - u + s)
            }
            return t
        }, e
    }(Pt),
    Zx = function () {
        function a() {
            this.group = new U
        }
        return a.prototype.updateData = function (e, t) {
            this._clear();
            var r = this._create();
            r.setShape({
                points: e.getLayout("points")
            }), this._setCommon(r, e, t)
        }, a.prototype.updateLayout = function (e) {
            var t = e.getLayout("points");
            this.group.eachChild(function (r) {
                if (r.startIndex != null) {
                    var i = (r.endIndex - r.startIndex) * 2,
                        n = r.startIndex * 4 * 2;
                    t = new Float32Array(t.buffer, n, i)
                }
                r.setShape("points", t), r.reset()
            })
        }, a.prototype.incrementalPrepareUpdate = function (e) {
            this._clear()
        }, a.prototype.incrementalUpdate = function (e, t, r) {
            var i = this._newAdded[0],
                n = t.getLayout("points"),
                o = i && i.shape.points;
            if (o && o.length < 2e4) {
                var s = o.length,
                    l = new Float32Array(s + n.length);
                l.set(o), l.set(n, s), i.endIndex = e.end, i.setShape({
                    points: l
                })
            } else {
                this._newAdded = [];
                var u = this._create();
                u.startIndex = e.start, u.endIndex = e.end, u.incremental = !0, u.setShape({
                    points: n
                }), this._setCommon(u, t, r)
            }
        }, a.prototype.eachRendered = function (e) {
            this._newAdded[0] && e(this._newAdded[0])
        }, a.prototype._create = function () {
            var e = new $x({
                cursor: "default"
            });
            return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e
        }, a.prototype._setCommon = function (e, t, r) {
            var i = t.hostModel;
            r = r || {};
            var n = t.getVisual("symbolSize");
            e.setShape("size", n instanceof Array ? n : [n, n]), e.softClipShape = r.clipShape || null, e.symbolProxy = Et(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
            var o = e.shape.size[0] < Bp;
            e.useStyle(i.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
            var s = t.getVisual("style"),
                l = s && s.fill;
            l && e.setColor(l);
            var u = tt(e);
            u.seriesIndex = i.seriesIndex, e.on("mousemove", function (v) {
                u.dataIndex = null;
                var h = e.hoverDataIdx;
                h >= 0 && (u.dataIndex = h + (e.startIndex || 0))
            })
        }, a.prototype.remove = function () {
            this._clear()
        }, a.prototype._clear = function () {
            this._newAdded = [], this.group.removeAll()
        }, a
    }(),
    Ux = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            var n = t.getData(),
                o = this._updateSymbolDraw(n, t);
            o.updateData(n, {
                clipShape: this._getClipShape(t)
            }), this._finished = !0
        }, e.prototype.incrementalPrepareRender = function (t, r, i) {
            var n = t.getData(),
                o = this._updateSymbolDraw(n, t);
            o.incrementalPrepareUpdate(n), this._finished = !1
        }, e.prototype.incrementalRender = function (t, r, i) {
            this._symbolDraw.incrementalUpdate(t, r.getData(), {
                clipShape: this._getClipShape(r)
            }), this._finished = t.end === r.getData().count()
        }, e.prototype.updateTransform = function (t, r, i) {
            var n = t.getData();
            if (this.group.dirty(), !this._finished || n.count() > 1e4) return {
                update: !0
            };
            var o = Xa("").reset(t, r, i);
            o.progress && o.progress({
                start: 0,
                end: n.count(),
                count: n.count()
            }, n), this._symbolDraw.updateLayout(n)
        }, e.prototype.eachRendered = function (t) {
            this._symbolDraw && this._symbolDraw.eachRendered(t)
        }, e.prototype._getClipShape = function (t) {
            if (t.get("clip", !0)) {
                var r = t.coordinateSystem;
                return r && r.getArea && r.getArea(.1)
            }
        }, e.prototype._updateSymbolDraw = function (t, r) {
            var i = this._symbolDraw,
                n = r.pipelineContext,
                o = n.large;
            return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new Zx : new Ya, this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i
        }, e.prototype.remove = function (t, r) {
            this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null
        }, e.prototype.dispose = function () {}, e.type = "scatter", e
    }(At);
const Yx = Ux;
var Xx = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
        show: !1,
        z: 0,
        left: "10%",
        top: 60,
        right: "10%",
        bottom: 70,
        containLabel: !1,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 1,
        borderColor: "#ccc"
    }, e
}(Ct);
const Kx = Xx;
var ss = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.getCoordSysModel = function () {
        return this.getReferringComponents("grid", Kt).models[0]
    }, e.type = "cartesian2dAxis", e
}(Ct);
le(ss, Ji);
var qx = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
};

function Yr(a, e, t, r) {
    T(qx, function (i, n) {
        var o = ct(ct({}, Xy[n], !0), r, !0),
            s = function (l) {
                E(u, l);

                function u() {
                    var v = l !== null && l.apply(this, arguments) || this;
                    return v.type = e + "Axis." + n, v
                }
                return u.prototype.mergeDefaultAndTheme = function (v, h) {
                    var c = Ky(this),
                        f = c ? Qi(v) : {},
                        p = h.getTheme();
                    ct(v, p.get(n + "Axis")), ct(v, this.getDefaultOption()), v.type = rv(v), c && tn(v, f, c)
                }, u.prototype.optionUpdated = function () {
                    var v = this.option;
                    v.type === "category" && (this.__ordinalMeta = qy.createByAxisModel(this))
                }, u.prototype.getCategories = function (v) {
                    var h = this.option;
                    if (h.type === "category") return v ? h.data : this.__ordinalMeta.categories
                }, u.prototype.getOrdinalMeta = function () {
                    return this.__ordinalMeta
                }, u.type = e + "Axis." + n, u.defaultOption = o, u
            }(t);
        a.registerComponentModel(s)
    }), a.registerSubTypeDefaulter(e + "Axis", rv)
}

function rv(a) {
    return a.type || (a.data ? "category" : "value")
}
var jx = function () {
    function a(e) {
        this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || ""
    }
    return a.prototype.getAxis = function (e) {
        return this._axes[e]
    }, a.prototype.getAxes = function () {
        return G(this._dimList, function (e) {
            return this._axes[e]
        }, this)
    }, a.prototype.getAxesByScale = function (e) {
        return e = e.toLowerCase(), Dt(this.getAxes(), function (t) {
            return t.scale.type === e
        })
    }, a.prototype.addAxis = function (e) {
        var t = e.dim;
        this._axes[t] = e, this._dimList.push(t)
    }, a
}();
const Jx = jx;
var ls = ["x", "y"];

function av(a) {
    return a.type === "interval" || a.type === "time"
}
var Qx = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = "cartesian2d", t.dimensions = ls, t
        }
        return e.prototype.calcAffineTransform = function () {
            this._transform = this._invTransform = null;
            var t = this.getAxis("x").scale,
                r = this.getAxis("y").scale;
            if (!(!av(t) || !av(r))) {
                var i = t.getExtent(),
                    n = r.getExtent(),
                    o = this.dataToPoint([i[0], n[0]]),
                    s = this.dataToPoint([i[1], n[1]]),
                    l = i[1] - i[0],
                    u = n[1] - n[0];
                if (!(!l || !u)) {
                    var v = (s[0] - o[0]) / l,
                        h = (s[1] - o[1]) / u,
                        c = o[0] - i[0] * v,
                        f = o[1] - n[0] * h,
                        p = this._transform = [v, 0, 0, h, c, f];
                    this._invTransform = $s([], p)
                }
            }
        }, e.prototype.getBaseAxis = function () {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
        }, e.prototype.containPoint = function (t) {
            var r = this.getAxis("x"),
                i = this.getAxis("y");
            return r.contain(r.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]))
        }, e.prototype.containData = function (t) {
            return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
        }, e.prototype.containZone = function (t, r) {
            var i = this.dataToPoint(t),
                n = this.dataToPoint(r),
                o = this.getArea(),
                s = new gt(i[0], i[1], n[0] - i[0], n[1] - i[1]);
            return o.intersect(s)
        }, e.prototype.dataToPoint = function (t, r, i) {
            i = i || [];
            var n = t[0],
                o = t[1];
            if (this._transform && n != null && isFinite(n) && o != null && isFinite(o)) return vr(i, t, this._transform);
            var s = this.getAxis("x"),
                l = this.getAxis("y");
            return i[0] = s.toGlobalCoord(s.dataToCoord(n, r)), i[1] = l.toGlobalCoord(l.dataToCoord(o, r)), i
        }, e.prototype.clampData = function (t, r) {
            var i = this.getAxis("x").scale,
                n = this.getAxis("y").scale,
                o = i.getExtent(),
                s = n.getExtent(),
                l = i.parse(t[0]),
                u = n.parse(t[1]);
            return r = r || [], r[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), r[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), r
        }, e.prototype.pointToData = function (t, r) {
            var i = [];
            if (this._invTransform) return vr(i, t, this._invTransform);
            var n = this.getAxis("x"),
                o = this.getAxis("y");
            return i[0] = n.coordToData(n.toLocalCoord(t[0]), r), i[1] = o.coordToData(o.toLocalCoord(t[1]), r), i
        }, e.prototype.getOtherAxis = function (t) {
            return this.getAxis(t.dim === "x" ? "y" : "x")
        }, e.prototype.getArea = function (t) {
            t = t || 0;
            var r = this.getAxis("x").getGlobalExtent(),
                i = this.getAxis("y").getGlobalExtent(),
                n = Math.min(r[0], r[1]) - t,
                o = Math.min(i[0], i[1]) - t,
                s = Math.max(r[0], r[1]) - n + t,
                l = Math.max(i[0], i[1]) - o + t;
            return new gt(n, o, s, l)
        }, e
    }(Jx),
    tS = function (a) {
        E(e, a);

        function e(t, r, i, n, o) {
            var s = a.call(this, t, r, i) || this;
            return s.index = 0, s.type = n || "value", s.position = o || "bottom", s
        }
        return e.prototype.isHorizontal = function () {
            var t = this.position;
            return t === "top" || t === "bottom"
        }, e.prototype.getGlobalExtent = function (t) {
            var r = this.getExtent();
            return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), t && r[0] > r[1] && r.reverse(), r
        }, e.prototype.pointToData = function (t, r) {
            return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), r)
        }, e.prototype.setCategorySortInfo = function (t) {
            if (this.type !== "category") return !1;
            this.model.option.categorySortInfo = t, this.scale.setSortInfo(t)
        }, e
    }(ye);
const eS = tS;

function us(a, e, t) {
    t = t || {};
    var r = a.coordinateSystem,
        i = e.axis,
        n = {},
        o = i.getAxesOnZeroOf()[0],
        s = i.position,
        l = o ? "onZero" : s,
        u = i.dim,
        v = r.getRect(),
        h = [v.x, v.x + v.width, v.y, v.y + v.height],
        c = {
            left: 0,
            right: 1,
            top: 0,
            bottom: 1,
            onZero: 2
        },
        f = e.get("offset") || 0,
        p = u === "x" ? [h[2] - f, h[3] + f] : [h[0] - f, h[1] + f];
    if (o) {
        var d = o.toGlobalCoord(o.dataToCoord(0));
        p[c.onZero] = Math.max(Math.min(d, p[1]), p[0])
    }
    n.position = [u === "y" ? p[c[l]] : h[0], u === "x" ? p[c[l]] : h[3]], n.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
    var g = {
        top: -1,
        bottom: 1,
        left: -1,
        right: 1
    };
    n.labelDirection = n.tickDirection = n.nameDirection = g[s], n.labelOffset = o ? p[c[s]] - p[c.onZero] : 0, e.get(["axisTick", "inside"]) && (n.tickDirection = -n.tickDirection), Ut(t.labelInside, e.get(["axisLabel", "inside"])) && (n.labelDirection = -n.labelDirection);
    var y = e.get(["axisLabel", "rotate"]);
    return n.labelRotate = l === "top" ? -y : y, n.z2 = 1, n
}

function iv(a) {
    return a.get("coordinateSystem") === "cartesian2d"
}

function nv(a) {
    var e = {
        xAxisModel: null,
        yAxisModel: null
    };
    return T(e, function (t, r) {
        var i = r.replace(/Model$/, ""),
            n = a.getReferringComponents(i, Kt).models[0];
        e[r] = n
    }), e
}
var rS = function () {
    function a(e, t, r) {
        this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = ls, this._initCartesian(e, t, r), this.model = e
    }
    return a.prototype.getRect = function () {
        return this._rect
    }, a.prototype.update = function (e, t) {
        var r = this._axesMap;
        this._updateScale(e, this.model);

        function i(o) {
            var s, l = wt(o),
                u = l.length;
            if (u) {
                for (var v = [], h = u - 1; h >= 0; h--) {
                    var c = +l[h],
                        f = o[c],
                        p = f.model,
                        d = f.scale;
                    Xo(d) && p.get("alignTicks") && p.get("interval") == null ? v.push(f) : (Zr(d, p), Xo(d) && (s = f))
                }
                v.length && (s || (s = v.pop(), Zr(s.scale, s.model)), T(v, function (g) {
                    Qy(g.scale, g.model, s.scale)
                }))
            }
        }
        i(r.x), i(r.y);
        var n = {};
        T(r.x, function (o) {
            ov(r, "y", o, n)
        }), T(r.y, function (o) {
            ov(r, "x", o, n)
        }), this.resize(this.model, t)
    }, a.prototype.resize = function (e, t, r) {
        var i = e.getBoxLayoutParams(),
            n = !r && e.get("containLabel"),
            o = kt(i, {
                width: t.getWidth(),
                height: t.getHeight()
            });
        this._rect = o;
        var s = this._axesList;
        l(), n && (T(s, function (u) {
            if (!u.model.get(["axisLabel", "inside"])) {
                var v = jy(u);
                if (v) {
                    var h = u.isHorizontal() ? "height" : "width",
                        c = u.model.get(["axisLabel", "margin"]);
                    o[h] -= v[h] + c, u.position === "top" ? o.y += v.height + c : u.position === "left" && (o.x += v.width + c)
                }
            }
        }), l()), T(this._coordsList, function (u) {
            u.calcAffineTransform()
        });

        function l() {
            T(s, function (u) {
                var v = u.isHorizontal(),
                    h = v ? [0, o.width] : [0, o.height],
                    c = u.inverse ? 1 : 0;
                u.setExtent(h[c], h[1 - c]), aS(u, v ? o.x : o.y)
            })
        }
    }, a.prototype.getAxis = function (e, t) {
        var r = this._axesMap[e];
        if (r != null) return r[t || 0]
    }, a.prototype.getAxes = function () {
        return this._axesList.slice()
    }, a.prototype.getCartesian = function (e, t) {
        if (e != null && t != null) {
            var r = "x" + e + "y" + t;
            return this._coordsMap[r]
        }
        St(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
        for (var i = 0, n = this._coordsList; i < n.length; i++)
            if (n[i].getAxis("x").index === e || n[i].getAxis("y").index === t) return n[i]
    }, a.prototype.getCartesians = function () {
        return this._coordsList.slice()
    }, a.prototype.convertToPixel = function (e, t, r) {
        var i = this._findConvertTarget(t);
        return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null
    }, a.prototype.convertFromPixel = function (e, t, r) {
        var i = this._findConvertTarget(t);
        return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null
    }, a.prototype._findConvertTarget = function (e) {
        var t = e.seriesModel,
            r = e.xAxisModel || t && t.getReferringComponents("xAxis", Kt).models[0],
            i = e.yAxisModel || t && t.getReferringComponents("yAxis", Kt).models[0],
            n = e.gridModel,
            o = this._coordsList,
            s, l;
        if (t) s = t.coordinateSystem, ft(o, s) < 0 && (s = null);
        else if (r && i) s = this.getCartesian(r.componentIndex, i.componentIndex);
        else if (r) l = this.getAxis("x", r.componentIndex);
        else if (i) l = this.getAxis("y", i.componentIndex);
        else if (n) {
            var u = n.coordinateSystem;
            u === this && (s = this._coordsList[0])
        }
        return {
            cartesian: s,
            axis: l
        }
    }, a.prototype.containPoint = function (e) {
        var t = this._coordsList[0];
        if (t) return t.containPoint(e)
    }, a.prototype._initCartesian = function (e, t, r) {
        var i = this,
            n = this,
            o = {
                left: !1,
                right: !1,
                top: !1,
                bottom: !1
            },
            s = {
                x: {},
                y: {}
            },
            l = {
                x: 0,
                y: 0
            };
        if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
            this._axesMap = {}, this._axesList = [];
            return
        }
        this._axesMap = s, T(s.x, function (v, h) {
            T(s.y, function (c, f) {
                var p = "x" + h + "y" + f,
                    d = new Qx(p);
                d.master = i, d.model = e, i._coordsMap[p] = d, i._coordsList.push(d), d.addAxis(v), d.addAxis(c)
            })
        });

        function u(v) {
            return function (h, c) {
                if (Gn(h, e)) {
                    var f = h.get("position");
                    v === "x" ? f !== "top" && f !== "bottom" && (f = o.bottom ? "top" : "bottom") : f !== "left" && f !== "right" && (f = o.left ? "right" : "left"), o[f] = !0;
                    var p = new eS(v, en(h), [0, 0], h.get("type"), f),
                        d = p.type === "category";
                    p.onBand = d && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = n, p.index = c, n._axesList.push(p), s[v][c] = p, l[v]++
                }
            }
        }
    }, a.prototype._updateScale = function (e, t) {
        T(this._axesList, function (i) {
            if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
                var n = i.model.get("categorySortInfo");
                i.scale.setSortInfo(n)
            }
        }), e.eachSeries(function (i) {
            if (iv(i)) {
                var n = nv(i),
                    o = n.xAxisModel,
                    s = n.yAxisModel;
                if (!Gn(o, t) || !Gn(s, t)) return;
                var l = this.getCartesian(o.componentIndex, s.componentIndex),
                    u = i.getData(),
                    v = l.getAxis("x"),
                    h = l.getAxis("y");
                r(u, v), r(u, h)
            }
        }, this);

        function r(i, n) {
            T(Yo(i, n.dim), function (o) {
                n.scale.unionExtentFromData(i, o)
            })
        }
    }, a.prototype.getTooltipAxes = function (e) {
        var t = [],
            r = [];
        return T(this.getCartesians(), function (i) {
            var n = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(),
                o = i.getOtherAxis(n);
            ft(t, n) < 0 && t.push(n), ft(r, o) < 0 && r.push(o)
        }), {
            baseAxes: t,
            otherAxes: r
        }
    }, a.create = function (e, t) {
        var r = [];
        return e.eachComponent("grid", function (i, n) {
            var o = new a(i, e, t);
            o.name = "grid_" + n, o.resize(i, t, !0), i.coordinateSystem = o, r.push(o)
        }), e.eachSeries(function (i) {
            if (iv(i)) {
                var n = nv(i),
                    o = n.xAxisModel,
                    s = n.yAxisModel,
                    l = o.getCoordSysModel(),
                    u = l.coordinateSystem;
                i.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex)
            }
        }), r
    }, a.dimensions = ls, a
}();

function Gn(a, e) {
    return a.getCoordSysModel() === e
}

function ov(a, e, t, r) {
    t.getAxesOnZeroOf = function () {
        return n ? [n] : []
    };
    var i = a[e],
        n, o = t.model,
        s = o.get(["axisLine", "onZero"]),
        l = o.get(["axisLine", "onZeroAxisIndex"]);
    if (!s) return;
    if (l != null) sv(i[l]) && (n = i[l]);
    else
        for (var u in i)
            if (i.hasOwnProperty(u) && sv(i[u]) && !r[v(i[u])]) {
                n = i[u];
                break
            } n && (r[v(n)] = !0);

    function v(h) {
        return h.dim + "_" + h.index
    }
}

function sv(a) {
    return a && a.type !== "category" && a.type !== "time" && Jy(a)
}

function aS(a, e) {
    var t = a.getExtent(),
        r = t[0] + t[1];
    a.toGlobalCoord = a.dim === "x" ? function (i) {
        return i + e
    } : function (i) {
        return r - i + e
    }, a.toLocalCoord = a.dim === "x" ? function (i) {
        return i - e
    } : function (i) {
        return r - i + e
    }
}
const iS = rS;

function nS(a, e) {
    var t = {
        axesInfo: {},
        seriesInvolved: !1,
        coordSysAxesInfo: {},
        coordSysMap: {}
    };
    return oS(t, a, e), t.seriesInvolved && lS(t, a), t
}

function oS(a, e, t) {
    var r = e.getComponent("tooltip"),
        i = e.getComponent("axisPointer"),
        n = i.get("link", !0) || [],
        o = [];
    T(t.getCoordinateSystems(), function (s) {
        if (!s.axisPointerEnabled) return;
        var l = La(s.model),
            u = a.coordSysAxesInfo[l] = {};
        a.coordSysMap[l] = s;
        var v = s.model,
            h = v.getModel("tooltip", r);
        if (T(s.getAxes(), K(d, !1, null)), s.getTooltipAxes && r && h.get("show")) {
            var c = h.get("trigger") === "axis",
                f = h.get(["axisPointer", "type"]) === "cross",
                p = s.getTooltipAxes(h.get(["axisPointer", "axis"]));
            (c || f) && T(p.baseAxes, K(d, f ? "cross" : !0, c)), f && T(p.otherAxes, K(d, "cross", !1))
        }

        function d(g, y, x) {
            var m = x.model.getModel("axisPointer", i),
                S = m.get("show");
            if (!(!S || S === "auto" && !g && !vs(m))) {
                y == null && (y = m.get("triggerTooltip")), m = g ? sS(x, h, i, e, g, y) : m;
                var _ = m.get("snap"),
                    b = m.get("triggerEmphasis"),
                    w = La(x.model),
                    A = y || _ || x.type === "category",
                    C = a.axesInfo[w] = {
                        key: w,
                        axis: x,
                        coordSys: s,
                        axisPointerModel: m,
                        triggerTooltip: y,
                        triggerEmphasis: b,
                        involveSeries: A,
                        snap: _,
                        useHandle: vs(m),
                        seriesModels: [],
                        linkGroup: null
                    };
                u[w] = C, a.seriesInvolved = a.seriesInvolved || A;
                var D = uS(n, x);
                if (D != null) {
                    var I = o[D] || (o[D] = {
                        axesInfo: {}
                    });
                    I.axesInfo[w] = C, I.mapper = n[D].mapper, C.linkGroup = I
                }
            }
        }
    })
}

function sS(a, e, t, r, i, n) {
    var o = e.getModel("axisPointer"),
        s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"],
        l = {};
    T(s, function (c) {
        l[c] = ot(o.get(c))
    }), l.snap = a.type !== "category" && !!n, o.get("type") === "cross" && (l.type = "line");
    var u = l.label || (l.label = {});
    if (u.show == null && (u.show = !1), i === "cross") {
        var v = o.get(["label", "show"]);
        if (u.show = v ? ? !0, !n) {
            var h = l.lineStyle = o.get("crossStyle");
            h && at(u, h.textStyle)
        }
    }
    return a.model.getModel("axisPointer", new Rt(l, t, r))
}

function lS(a, e) {
    e.eachSeries(function (t) {
        var r = t.coordinateSystem,
            i = t.get(["tooltip", "trigger"], !0),
            n = t.get(["tooltip", "show"], !0);
        !r || i === "none" || i === !1 || i === "item" || n === !1 || t.get(["axisPointer", "show"], !0) === !1 || T(a.coordSysAxesInfo[La(r.model)], function (o) {
            var s = o.axis;
            r.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count())
        })
    })
}

function uS(a, e) {
    for (var t = e.model, r = e.dim, i = 0; i < a.length; i++) {
        var n = a[i] || {};
        if (Bn(n[r + "AxisId"], t.id) || Bn(n[r + "AxisIndex"], t.componentIndex) || Bn(n[r + "AxisName"], t.name)) return i
    }
}

function Bn(a, e) {
    return a === "all" || B(a) && ft(a, e) >= 0 || a === e
}

function vS(a) {
    var e = ll(a);
    if (e) {
        var t = e.axisPointerModel,
            r = e.axis.scale,
            i = t.option,
            n = t.get("status"),
            o = t.get("value");
        o != null && (o = r.parse(o));
        var s = vs(t);
        n == null && (i.status = s ? "show" : "hide");
        var l = r.getExtent().slice();
        l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show")
    }
}

function ll(a) {
    var e = (a.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return e && e.axesInfo[La(a)]
}

function hS(a) {
    var e = ll(a);
    return e && e.axisPointerModel
}

function vs(a) {
    return !!a.get(["handle", "show"])
}

function La(a) {
    return a.type + "||" + a.id
}
var lv = {},
    xr = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i, n) {
            this.axisPointerClass && vS(t), a.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, !0)
        }, e.prototype.updateAxisPointer = function (t, r, i, n) {
            this._doUpdateAxisPointerClass(t, i, !1)
        }, e.prototype.remove = function (t, r) {
            var i = this._axisPointer;
            i && i.remove(r)
        }, e.prototype.dispose = function (t, r) {
            this._disposeAxisPointer(r), a.prototype.dispose.apply(this, arguments)
        }, e.prototype._doUpdateAxisPointerClass = function (t, r, i) {
            var n = e.getAxisPointerClass(this.axisPointerClass);
            if (n) {
                var o = hS(t);
                o ? (this._axisPointer || (this._axisPointer = new n)).render(t, o, r, i) : this._disposeAxisPointer(r)
            }
        }, e.prototype._disposeAxisPointer = function (t) {
            this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null
        }, e.registerAxisPointerClass = function (t, r) {
            lv[t] = r
        }, e.getAxisPointerClass = function (t) {
            return t && lv[t]
        }, e.type = "axis", e
    }(It),
    hs = xt();

function Hp(a, e, t, r) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
        var n = t.getModel("splitArea"),
            o = n.getModel("areaStyle"),
            s = o.get("color"),
            l = r.coordinateSystem.getRect(),
            u = i.getTicksCoords({
                tickModel: n,
                clamp: !0
            });
        if (u.length) {
            var v = s.length,
                h = hs(a).splitAreaColors,
                c = Q(),
                f = 0;
            if (h)
                for (var p = 0; p < u.length; p++) {
                    var d = h.get(u[p].tickValue);
                    if (d != null) {
                        f = (d + (v - 1) * p) % v;
                        break
                    }
                }
            var g = i.toGlobalCoord(u[0].coord),
                y = o.getAreaStyle();
            s = B(s) ? s : [s];
            for (var p = 1; p < u.length; p++) {
                var x = i.toGlobalCoord(u[p].coord),
                    m = void 0,
                    S = void 0,
                    _ = void 0,
                    b = void 0;
                i.isHorizontal() ? (m = g, S = l.y, _ = x - m, b = l.height, g = m + _) : (m = l.x, S = g, _ = l.width, b = x - S, g = S + b);
                var w = u[p - 1].tickValue;
                w != null && c.set(w, f), e.add(new pt({
                    anid: w != null ? "area_" + w : null,
                    shape: {
                        x: m,
                        y: S,
                        width: _,
                        height: b
                    },
                    style: at({
                        fill: s[f]
                    }, y),
                    autoBatch: !0,
                    silent: !0
                })), f = (f + 1) % v
            }
            hs(a).splitAreaColors = c
        }
    }
}

function Fp(a) {
    hs(a).splitAreaColors = null
}
var cS = ["axisLine", "axisTickLabel", "axisName"],
    fS = ["splitArea", "splitLine", "minorSplitLine"],
    Wp = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t
        }
        return e.prototype.render = function (t, r, i, n) {
            this.group.removeAll();
            var o = this._axisGroup;
            if (this._axisGroup = new U, this.group.add(this._axisGroup), !!t.get("show")) {
                var s = t.getCoordSysModel(),
                    l = us(s, t),
                    u = new ze(t, W({
                        handleAutoShown: function (h) {
                            for (var c = s.coordinateSystem.getCartesians(), f = 0; f < c.length; f++)
                                if (Xo(c[f].getOtherAxis(t.axis).scale)) return !0;
                            return !1
                        }
                    }, l));
                T(cS, u.add, u), this._axisGroup.add(u.getGroup()), T(fS, function (h) {
                    t.get([h, "show"]) && pS[h](this, this._axisGroup, t, s)
                }, this);
                var v = n && n.type === "changeAxisOrder" && n.isInitSort;
                v || rn(o, this._axisGroup, t), a.prototype.render.call(this, t, r, i, n)
            }
        }, e.prototype.remove = function () {
            Fp(this)
        }, e.type = "cartesianAxis", e
    }(xr),
    pS = {
        splitLine: function (a, e, t, r) {
            var i = t.axis;
            if (!i.scale.isBlank()) {
                var n = t.getModel("splitLine"),
                    o = n.getModel("lineStyle"),
                    s = o.get("color");
                s = B(s) ? s : [s];
                for (var l = r.coordinateSystem.getRect(), u = i.isHorizontal(), v = 0, h = i.getTicksCoords({
                        tickModel: n
                    }), c = [], f = [], p = o.getLineStyle(), d = 0; d < h.length; d++) {
                    var g = i.toGlobalCoord(h[d].coord);
                    u ? (c[0] = g, c[1] = l.y, f[0] = g, f[1] = l.y + l.height) : (c[0] = l.x, c[1] = g, f[0] = l.x + l.width, f[1] = g);
                    var y = v++ % s.length,
                        x = h[d].tickValue,
                        m = new Jt({
                            anid: x != null ? "line_" + h[d].tickValue : null,
                            autoBatch: !0,
                            shape: {
                                x1: c[0],
                                y1: c[1],
                                x2: f[0],
                                y2: f[1]
                            },
                            style: at({
                                stroke: s[y]
                            }, p),
                            silent: !0
                        });
                    Ko(m.shape, p.lineWidth), e.add(m)
                }
            }
        },
        minorSplitLine: function (a, e, t, r) {
            var i = t.axis,
                n = t.getModel("minorSplitLine"),
                o = n.getModel("lineStyle"),
                s = r.coordinateSystem.getRect(),
                l = i.isHorizontal(),
                u = i.getMinorTicksCoords();
            if (u.length)
                for (var v = [], h = [], c = o.getLineStyle(), f = 0; f < u.length; f++)
                    for (var p = 0; p < u[f].length; p++) {
                        var d = i.toGlobalCoord(u[f][p].coord);
                        l ? (v[0] = d, v[1] = s.y, h[0] = d, h[1] = s.y + s.height) : (v[0] = s.x, v[1] = d, h[0] = s.x + s.width, h[1] = d);
                        var g = new Jt({
                            anid: "minor_line_" + u[f][p].tickValue,
                            autoBatch: !0,
                            shape: {
                                x1: v[0],
                                y1: v[1],
                                x2: h[0],
                                y2: h[1]
                            },
                            style: c,
                            silent: !0
                        });
                        Ko(g.shape, c.lineWidth), e.add(g)
                    }
        },
        splitArea: function (a, e, t, r) {
            Hp(a, e, t, r)
        }
    },
    $p = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.type = "xAxis", e
    }(Wp),
    dS = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = $p.type, t
        }
        return e.type = "yAxis", e
    }(Wp),
    gS = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = "grid", t
        }
        return e.prototype.render = function (t, r) {
            this.group.removeAll(), t.get("show") && this.group.add(new pt({
                shape: t.coordinateSystem.getRect(),
                style: at({
                    fill: t.get("backgroundColor")
                }, t.getItemStyle()),
                silent: !0,
                z2: -1
            }))
        }, e.type = "grid", e
    }(It),
    uv = {
        offset: 0
    };

function Zp(a) {
    a.registerComponentView(gS), a.registerComponentModel(Kx), a.registerCoordinateSystem("cartesian2d", iS), Yr(a, "x", ss, uv), Yr(a, "y", ss, uv), a.registerComponentView($p), a.registerComponentView(dS), a.registerPreprocessor(function (e) {
        e.xAxis && e.yAxis && !e.grid && (e.grid = {})
    })
}

function yS(a) {
    j(Zp), a.registerSeriesModel(Fx), a.registerChartView(Yx), a.registerLayout(Xa("scatter"))
}
var vv = "\0_ec_interaction_mutex";

function mS(a, e, t) {
    var r = ul(a);
    r[e] = t
}

function xS(a, e, t) {
    var r = ul(a),
        i = r[e];
    i === t && (r[e] = null)
}

function hv(a, e) {
    return !!ul(a)[e]
}

function ul(a) {
    return a[vv] || (a[vv] = {})
}
an({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
}, pe);
var SS = function (a) {
    E(e, a);

    function e(t) {
        var r = a.call(this) || this;
        r._zr = t;
        var i = F(r._mousedownHandler, r),
            n = F(r._mousemoveHandler, r),
            o = F(r._mouseupHandler, r),
            s = F(r._mousewheelHandler, r),
            l = F(r._pinchHandler, r);
        return r.enable = function (u, v) {
            this.disable(), this._opt = at(ot(v) || {}, {
                zoomOnMouseWheel: !0,
                moveOnMouseMove: !0,
                moveOnMouseWheel: !1,
                preventDefaultMouseMove: !0
            }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", n), t.on("mouseup", o)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l))
        }, r.disable = function () {
            t.off("mousedown", i), t.off("mousemove", n), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l)
        }, r
    }
    return e.prototype.isDragging = function () {
        return this._dragging
    }, e.prototype.isPinching = function () {
        return this._pinching
    }, e.prototype.setPointerChecker = function (t) {
        this.pointerChecker = t
    }, e.prototype.dispose = function () {
        this.disable()
    }, e.prototype._mousedownHandler = function (t) {
        if (!hu(t)) {
            for (var r = t.target; r;) {
                if (r.draggable) return;
                r = r.__hostTarget || r.parent
            }
            var i = t.offsetX,
                n = t.offsetY;
            this.pointerChecker && this.pointerChecker(t, i, n) && (this._x = i, this._y = n, this._dragging = !0)
        }
    }, e.prototype._mousemoveHandler = function (t) {
        if (!(!this._dragging || !Si("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || hv(this._zr, "globalPan"))) {
            var r = t.offsetX,
                i = t.offsetY,
                n = this._x,
                o = this._y,
                s = r - n,
                l = i - o;
            this._x = r, this._y = i, this._opt.preventDefaultMouseMove && Ne(t.event), Up(this, "pan", "moveOnMouseMove", t, {
                dx: s,
                dy: l,
                oldX: n,
                oldY: o,
                newX: r,
                newY: i,
                isAvailableBehavior: null
            })
        }
    }, e.prototype._mouseupHandler = function (t) {
        hu(t) || (this._dragging = !1)
    }, e.prototype._mousewheelHandler = function (t) {
        var r = Si("zoomOnMouseWheel", t, this._opt),
            i = Si("moveOnMouseWheel", t, this._opt),
            n = t.wheelDelta,
            o = Math.abs(n),
            s = t.offsetX,
            l = t.offsetY;
        if (!(n === 0 || !r && !i)) {
            if (r) {
                var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1,
                    v = n > 0 ? u : 1 / u;
                Hn(this, "zoom", "zoomOnMouseWheel", t, {
                    scale: v,
                    originX: s,
                    originY: l,
                    isAvailableBehavior: null
                })
            }
            if (i) {
                var h = Math.abs(n),
                    c = (n > 0 ? 1 : -1) * (h > 3 ? .4 : h > 1 ? .15 : .05);
                Hn(this, "scrollMove", "moveOnMouseWheel", t, {
                    scrollDelta: c,
                    originX: s,
                    originY: l,
                    isAvailableBehavior: null
                })
            }
        }
    }, e.prototype._pinchHandler = function (t) {
        if (!hv(this._zr, "globalPan")) {
            var r = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
            Hn(this, "zoom", null, t, {
                scale: r,
                originX: t.pinchX,
                originY: t.pinchY,
                isAvailableBehavior: null
            })
        }
    }, e
}(Ys);

function Hn(a, e, t, r, i) {
    a.pointerChecker && a.pointerChecker(r, i.originX, i.originY) && (Ne(r.event), Up(a, e, t, r, i))
}

function Up(a, e, t, r, i) {
    i.isAvailableBehavior = F(Si, null, t, r), a.trigger(e, i)
}

function Si(a, e, t) {
    var r = t[a];
    return !a || r && (!q(r) || e.event[r + "Key"])
}
const Ka = SS;

function vl(a, e, t) {
    var r = a.target;
    r.x += e, r.y += t, r.dirty()
}

function hl(a, e, t, r) {
    var i = a.target,
        n = a.zoomLimit,
        o = a.zoom = a.zoom || 1;
    if (o *= e, n) {
        var s = n.min || 0,
            l = n.max || 1 / 0;
        o = Math.max(Math.min(l, o), s)
    }
    var u = o / a.zoom;
    a.zoom = o, i.x -= (t - i.x) * (u - 1), i.y -= (r - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty()
}
var _S = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
};

function yn(a, e, t) {
    var r = e.getComponentByElement(a.topTarget),
        i = r && r.coordinateSystem;
    return r && r !== t && !_S.hasOwnProperty(r.mainType) && i && i.model !== t
}

function Yp(a) {
    if (q(a)) {
        var e = new DOMParser;
        a = e.parseFromString(a, "text/xml")
    }
    var t = a;
    for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1;) t = t.nextSibling;
    return t
}
var Fn, Pi = {
        fill: "fill",
        stroke: "stroke",
        "stroke-width": "lineWidth",
        opacity: "opacity",
        "fill-opacity": "fillOpacity",
        "stroke-opacity": "strokeOpacity",
        "stroke-dasharray": "lineDash",
        "stroke-dashoffset": "lineDashOffset",
        "stroke-linecap": "lineCap",
        "stroke-linejoin": "lineJoin",
        "stroke-miterlimit": "miterLimit",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "font-style": "fontStyle",
        "font-weight": "fontWeight",
        "text-anchor": "textAlign",
        visibility: "visibility",
        display: "display"
    },
    cv = wt(Pi),
    Ri = {
        "alignment-baseline": "textBaseline",
        "stop-color": "stopColor"
    },
    fv = wt(Ri),
    bS = function () {
        function a() {
            this._defs = {}, this._root = null
        }
        return a.prototype.parse = function (e, t) {
            t = t || {};
            var r = Yp(e);
            this._defsUsePending = [];
            var i = new U;
            this._root = i;
            var n = [],
                o = r.getAttribute("viewBox") || "",
                s = parseFloat(r.getAttribute("width") || t.width),
                l = parseFloat(r.getAttribute("height") || t.height);
            isNaN(s) && (s = null), isNaN(l) && (l = null), jt(r, i, null, !0, !1);
            for (var u = r.firstChild; u;) this._parseNode(u, i, n, null, !1, !1), u = u.nextSibling;
            TS(this._defs, this._defsUsePending), this._defsUsePending = [];
            var v, h;
            if (o) {
                var c = mn(o);
                c.length >= 4 && (v = {
                    x: parseFloat(c[0] || 0),
                    y: parseFloat(c[1] || 0),
                    width: parseFloat(c[2]),
                    height: parseFloat(c[3])
                })
            }
            if (v && s != null && l != null && (h = Kp(v, {
                    x: 0,
                    y: 0,
                    width: s,
                    height: l
                }), !t.ignoreViewBox)) {
                var f = i;
                i = new U, i.add(f), f.scaleX = f.scaleY = h.scale, f.x = h.x, f.y = h.y
            }
            return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new pt({
                shape: {
                    x: 0,
                    y: 0,
                    width: s,
                    height: l
                }
            })), {
                root: i,
                width: s,
                height: l,
                viewBoxRect: v,
                viewBoxTransform: h,
                named: n
            }
        }, a.prototype._parseNode = function (e, t, r, i, n, o) {
            var s = e.nodeName.toLowerCase(),
                l, u = i;
            if (s === "defs" && (n = !0), s === "text" && (o = !0), s === "defs" || s === "switch") l = t;
            else {
                if (!n) {
                    var v = Fn[s];
                    if (v && N(Fn, s)) {
                        l = v.call(this, e, t);
                        var h = e.getAttribute("name");
                        if (h) {
                            var c = {
                                name: h,
                                namedFrom: null,
                                svgNodeTagLower: s,
                                el: l
                            };
                            r.push(c), s === "g" && (u = c)
                        } else i && r.push({
                            name: i.name,
                            namedFrom: i,
                            svgNodeTagLower: s,
                            el: l
                        });
                        t.add(l)
                    }
                }
                var f = pv[s];
                if (f && N(pv, s)) {
                    var p = f.call(this, e),
                        d = e.getAttribute("id");
                    d && (this._defs[d] = p)
                }
            }
            if (l && l.isGroup)
                for (var g = e.firstChild; g;) g.nodeType === 1 ? this._parseNode(g, l, r, u, n, o) : g.nodeType === 3 && o && this._parseText(g, l), g = g.nextSibling
        }, a.prototype._parseText = function (e, t) {
            var r = new Zf({
                style: {
                    text: e.textContent
                },
                silent: !0,
                x: this._textX || 0,
                y: this._textY || 0
            });
            re(t, r), jt(e, r, this._defsUsePending, !1, !1), wS(r, t);
            var i = r.style,
                n = i.fontSize;
            n && n < 9 && (i.fontSize = 9, r.scaleX *= n / 9, r.scaleY *= n / 9);
            var o = (i.fontSize || i.fontFamily) && [i.fontStyle, i.fontWeight, (i.fontSize || 12) + "px", i.fontFamily || "sans-serif"].join(" ");
            i.font = o;
            var s = r.getBoundingRect();
            return this._textX += s.width, t.add(r), r
        }, a.internalField = function () {
            Fn = {
                g: function (e, t) {
                    var r = new U;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r
                },
                rect: function (e, t) {
                    var r = new pt;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r.setShape({
                        x: parseFloat(e.getAttribute("x") || "0"),
                        y: parseFloat(e.getAttribute("y") || "0"),
                        width: parseFloat(e.getAttribute("width") || "0"),
                        height: parseFloat(e.getAttribute("height") || "0")
                    }), r.silent = !0, r
                },
                circle: function (e, t) {
                    var r = new nn;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r.setShape({
                        cx: parseFloat(e.getAttribute("cx") || "0"),
                        cy: parseFloat(e.getAttribute("cy") || "0"),
                        r: parseFloat(e.getAttribute("r") || "0")
                    }), r.silent = !0, r
                },
                line: function (e, t) {
                    var r = new Jt;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r.setShape({
                        x1: parseFloat(e.getAttribute("x1") || "0"),
                        y1: parseFloat(e.getAttribute("y1") || "0"),
                        x2: parseFloat(e.getAttribute("x2") || "0"),
                        y2: parseFloat(e.getAttribute("y2") || "0")
                    }), r.silent = !0, r
                },
                ellipse: function (e, t) {
                    var r = new tm;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r.setShape({
                        cx: parseFloat(e.getAttribute("cx") || "0"),
                        cy: parseFloat(e.getAttribute("cy") || "0"),
                        rx: parseFloat(e.getAttribute("rx") || "0"),
                        ry: parseFloat(e.getAttribute("ry") || "0")
                    }), r.silent = !0, r
                },
                polygon: function (e, t) {
                    var r = e.getAttribute("points"),
                        i;
                    r && (i = yv(r));
                    var n = new de({
                        shape: {
                            points: i || []
                        },
                        silent: !0
                    });
                    return re(t, n), jt(e, n, this._defsUsePending, !1, !1), n
                },
                polyline: function (e, t) {
                    var r = e.getAttribute("points"),
                        i;
                    r && (i = yv(r));
                    var n = new $e({
                        shape: {
                            points: i || []
                        },
                        silent: !0
                    });
                    return re(t, n), jt(e, n, this._defsUsePending, !1, !1), n
                },
                image: function (e, t) {
                    var r = new ge;
                    return re(t, r), jt(e, r, this._defsUsePending, !1, !1), r.setStyle({
                        image: e.getAttribute("xlink:href") || e.getAttribute("href"),
                        x: +e.getAttribute("x"),
                        y: +e.getAttribute("y"),
                        width: +e.getAttribute("width"),
                        height: +e.getAttribute("height")
                    }), r.silent = !0, r
                },
                text: function (e, t) {
                    var r = e.getAttribute("x") || "0",
                        i = e.getAttribute("y") || "0",
                        n = e.getAttribute("dx") || "0",
                        o = e.getAttribute("dy") || "0";
                    this._textX = parseFloat(r) + parseFloat(n), this._textY = parseFloat(i) + parseFloat(o);
                    var s = new U;
                    return re(t, s), jt(e, s, this._defsUsePending, !1, !0), s
                },
                tspan: function (e, t) {
                    var r = e.getAttribute("x"),
                        i = e.getAttribute("y");
                    r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i));
                    var n = e.getAttribute("dx") || "0",
                        o = e.getAttribute("dy") || "0",
                        s = new U;
                    return re(t, s), jt(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(n), this._textY += parseFloat(o), s
                },
                path: function (e, t) {
                    var r = e.getAttribute("d") || "",
                        i = em(r);
                    return re(t, i), jt(e, i, this._defsUsePending, !1, !1), i.silent = !0, i
                }
            }
        }(), a
    }(),
    pv = {
        lineargradient: function (a) {
            var e = parseInt(a.getAttribute("x1") || "0", 10),
                t = parseInt(a.getAttribute("y1") || "0", 10),
                r = parseInt(a.getAttribute("x2") || "10", 10),
                i = parseInt(a.getAttribute("y2") || "0", 10),
                n = new qi(e, t, r, i);
            return dv(a, n), gv(a, n), n
        },
        radialgradient: function (a) {
            var e = parseInt(a.getAttribute("cx") || "0", 10),
                t = parseInt(a.getAttribute("cy") || "0", 10),
                r = parseInt(a.getAttribute("r") || "0", 10),
                i = new rm(e, t, r);
            return dv(a, i), gv(a, i), i
        }
    };

function dv(a, e) {
    var t = a.getAttribute("gradientUnits");
    t === "userSpaceOnUse" && (e.global = !0)
}

function gv(a, e) {
    for (var t = a.firstChild; t;) {
        if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
            var r = t.getAttribute("offset"),
                i = void 0;
            r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0;
            var n = {};
            Xp(t, n, n);
            var o = n.stopColor || t.getAttribute("stop-color") || "#000000";
            e.colorStops.push({
                offset: i,
                color: o
            })
        }
        t = t.nextSibling
    }
}

function re(a, e) {
    a && a.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), at(e.__inheritedStyle, a.__inheritedStyle))
}

function yv(a) {
    for (var e = mn(a), t = [], r = 0; r < e.length; r += 2) {
        var i = parseFloat(e[r]),
            n = parseFloat(e[r + 1]);
        t.push([i, n])
    }
    return t
}

function jt(a, e, t, r, i) {
    var n = e,
        o = n.__inheritedStyle = n.__inheritedStyle || {},
        s = {};
    a.nodeType === 1 && (IS(a, e), Xp(a, o, s), r || LS(a, o, s)), n.style = n.style || {}, o.fill != null && (n.style.fill = mv(n, "fill", o.fill, t)), o.stroke != null && (n.style.stroke = mv(n, "stroke", o.stroke, t)), T(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function (l) {
        o[l] != null && (n.style[l] = parseFloat(o[l]))
    }), T(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign"], function (l) {
        o[l] != null && (n.style[l] = o[l])
    }), i && (n.__selfStyle = s), o.lineDash && (n.style.lineDash = G(mn(o.lineDash), function (l) {
        return parseFloat(l)
    })), (o.visibility === "hidden" || o.visibility === "collapse") && (n.invisible = !0), o.display === "none" && (n.ignore = !0)
}

function wS(a, e) {
    var t = e.__selfStyle;
    if (t) {
        var r = t.textBaseline,
            i = r;
        !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), a.style.textBaseline = i
    }
    var n = e.__inheritedStyle;
    if (n) {
        var o = n.textAlign,
            s = o;
        o && (o === "middle" && (s = "center"), a.style.textAlign = s)
    }
}
var AS = /^url\(\s*#(.*?)\)/;

function mv(a, e, t, r) {
    var i = t && t.match(AS);
    if (i) {
        var n = Kf(i[1]);
        r.push([a, e, n]);
        return
    }
    return t === "none" && (t = null), t
}

function TS(a, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r[0].style[r[1]] = a[r[2]]
    }
}
var CS = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;

function mn(a) {
    return a.match(CS) || []
}
var DS = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g,
    Wn = Math.PI / 180;

function IS(a, e) {
    var t = a.getAttribute("transform");
    if (t) {
        t = t.replace(/,/g, " ");
        var r = [],
            i = null;
        t.replace(DS, function (h, c, f) {
            return r.push(c, f), ""
        });
        for (var n = r.length - 1; n > 0; n -= 2) {
            var o = r[n],
                s = r[n - 1],
                l = mn(o);
            switch (i = i || yr(), s) {
                case "translate":
                    Ge(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
                    break;
                case "scale":
                    qf(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
                    break;
                case "rotate":
                    Ha(i, i, -parseFloat(l[0]) * Wn, [parseFloat(l[1] || "0"), parseFloat(l[2] || "0")]);
                    break;
                case "skewX":
                    var u = Math.tan(parseFloat(l[0]) * Wn);
                    Wo(i, [1, 0, u, 1, 0, 0], i);
                    break;
                case "skewY":
                    var v = Math.tan(parseFloat(l[0]) * Wn);
                    Wo(i, [1, v, 0, 1, 0, 0], i);
                    break;
                case "matrix":
                    i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
                    break
            }
        }
        e.setLocalTransform(i)
    }
}
var xv = /([^\s:;]+)\s*:\s*([^:;]+)/g;

function Xp(a, e, t) {
    var r = a.getAttribute("style");
    if (r) {
        xv.lastIndex = 0;
        for (var i;
            (i = xv.exec(r)) != null;) {
            var n = i[1],
                o = N(Pi, n) ? Pi[n] : null;
            o && (e[o] = i[2]);
            var s = N(Ri, n) ? Ri[n] : null;
            s && (t[s] = i[2])
        }
    }
}

function LS(a, e, t) {
    for (var r = 0; r < cv.length; r++) {
        var i = cv[r],
            n = a.getAttribute(i);
        n != null && (e[Pi[i]] = n)
    }
    for (var r = 0; r < fv.length; r++) {
        var i = fv[r],
            n = a.getAttribute(i);
        n != null && (t[Ri[i]] = n)
    }
}

function Kp(a, e) {
    var t = e.width / a.width,
        r = e.height / a.height,
        i = Math.min(t, r);
    return {
        scale: i,
        x: -(a.x + a.width / 2) * i + (e.x + e.width / 2),
        y: -(a.y + a.height / 2) * i + (e.y + e.height / 2)
    }
}

function MS(a, e) {
    var t = new bS;
    return t.parse(a, e)
}
var PS = Q(["rect", "circle", "line", "ellipse", "polygon", "polyline", "path", "text", "tspan", "g"]),
    RS = function () {
        function a(e, t) {
            this.type = "geoSVG", this._usedGraphicMap = Q(), this._freedGraphics = [], this._mapName = e, this._parsedXML = Yp(t)
        }
        return a.prototype.load = function () {
            var e = this._firstGraphic;
            if (!e) {
                e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
                var t = kS(e.named),
                    r = t.regions,
                    i = t.regionsMap;
                this._regions = r, this._regionsMap = i
            }
            return {
                boundingRect: this._boundingRect,
                regions: this._regions,
                regionsMap: this._regionsMap
            }
        }, a.prototype._buildGraphic = function (e) {
            var t, r;
            try {
                t = e && MS(e, {
                    ignoreViewBox: !0,
                    ignoreRootClip: !0
                }) || {}, r = t.root, ba(r != null)
            } catch (g) {
                throw new Error(`Invalid svg format
` + g.message)
            }
            var i = new U;
            i.add(r), i.isGeoSVGGraphicRoot = !0;
            var n = t.width,
                o = t.height,
                s = t.viewBoxRect,
                l = this._boundingRect;
            if (!l) {
                var u = void 0,
                    v = void 0,
                    h = void 0,
                    c = void 0;
                if (n != null ? (u = 0, h = n) : s && (u = s.x, h = s.width), o != null ? (v = 0, c = o) : s && (v = s.y, c = s.height), u == null || v == null) {
                    var f = r.getBoundingRect();
                    u == null && (u = f.x, h = f.width), v == null && (v = f.y, c = f.height)
                }
                l = this._boundingRect = new gt(u, v, h, c)
            }
            if (s) {
                var p = Kp(s, l);
                r.scaleX = r.scaleY = p.scale, r.x = p.x, r.y = p.y
            }
            i.setClipPath(new pt({
                shape: l.plain()
            }));
            var d = [];
            return T(t.named, function (g) {
                PS.get(g.svgNodeTagLower) != null && (d.push(g), ES(g.el))
            }), {
                root: i,
                boundingRect: l,
                named: d
            }
        }, a.prototype.useGraphic = function (e) {
            var t = this._usedGraphicMap,
                r = t.get(e);
            return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, r), r)
        }, a.prototype.freeGraphic = function (e) {
            var t = this._usedGraphicMap,
                r = t.get(e);
            r && (t.removeKey(e), this._freedGraphics.push(r))
        }, a
    }();

function ES(a) {
    a.silent = !1, a.isGroup && a.traverse(function (e) {
        e.silent = !1
    })
}

function kS(a) {
    var e = [],
        t = Q();
    return T(a, function (r) {
        if (r.namedFrom == null) {
            var i = new T0(r.name, r.el);
            e.push(i), t.set(r.name, i)
        }
    }), {
        regions: e,
        regionsMap: t
    }
}
var cs = [126, 25],
    Sv = "å—æµ·è¯¸å²›",
    je = [
        [
            [0, 3.5],
            [7, 11.2],
            [15, 11.9],
            [30, 7],
            [42, .7],
            [52, .7],
            [56, 7.7],
            [59, .7],
            [64, .7],
            [64, 0],
            [5, 0],
            [0, 3.5]
        ],
        [
            [13, 16.1],
            [19, 14.7],
            [16, 21.7],
            [11, 23.1],
            [13, 16.1]
        ],
        [
            [12, 32.2],
            [14, 38.5],
            [15, 38.5],
            [13, 32.2],
            [12, 32.2]
        ],
        [
            [16, 47.6],
            [12, 53.2],
            [13, 53.2],
            [18, 47.6],
            [16, 47.6]
        ],
        [
            [6, 64.4],
            [8, 70],
            [9, 70],
            [8, 64.4],
            [6, 64.4]
        ],
        [
            [23, 82.6],
            [29, 79.8],
            [30, 79.8],
            [25, 82.6],
            [23, 82.6]
        ],
        [
            [37, 70.7],
            [43, 62.3],
            [44, 62.3],
            [39, 70.7],
            [37, 70.7]
        ],
        [
            [48, 51.1],
            [51, 45.5],
            [53, 45.5],
            [50, 51.1],
            [48, 51.1]
        ],
        [
            [51, 35],
            [51, 28.7],
            [53, 28.7],
            [53, 35],
            [51, 35]
        ],
        [
            [52, 22.4],
            [55, 17.5],
            [56, 17.5],
            [53, 22.4],
            [52, 22.4]
        ],
        [
            [58, 12.6],
            [62, 7],
            [63, 7],
            [60, 12.6],
            [58, 12.6]
        ],
        [
            [0, 3.5],
            [0, 93.1],
            [64, 93.1],
            [64, 0],
            [63, 0],
            [63, 92.4],
            [1, 92.4],
            [1, 3.5],
            [0, 3.5]
        ]
    ];
for (var Ke = 0; Ke < je.length; Ke++)
    for (var _r = 0; _r < je[Ke].length; _r++) je[Ke][_r][0] /= 10.5, je[Ke][_r][1] /= -10.5 / .75, je[Ke][_r][0] += cs[0], je[Ke][_r][1] += cs[1];

function VS(a, e) {
    if (a === "china") {
        for (var t = 0; t < e.length; t++)
            if (e[t].name === Sv) return;
        e.push(new mp(Sv, G(je, function (r) {
            return {
                type: "polygon",
                exterior: r
            }
        }), cs))
    }
}
var OS = {
    å— æµ· è¯¸ å²›: [32, 80],
    å¹¿ ä¸ œ: [0, -10],
    é¦™ æ¸¯: [10, 5],
    æ¾³ é—¨: [-10, 10],
    å¤© æ´¥: [5, 5]
};

function zS(a, e) {
    if (a === "china") {
        var t = OS[e.name];
        if (t) {
            var r = e.getCenter();
            r[0] += t[0] / 10.5, r[1] += -t[1] / (10.5 / .75), e.setCenter(r)
        }
    }
}
var NS = [
    [
        [123.45165252685547, 25.73527164402261],
        [123.49731445312499, 25.73527164402261],
        [123.49731445312499, 25.750734064600884],
        [123.45165252685547, 25.750734064600884],
        [123.45165252685547, 25.73527164402261]
    ]
];

function GS(a, e) {
    a === "china" && e.name === "å°æ¹¾" && e.geometries.push({
        type: "polygon",
        exterior: NS[0]
    })
}
var BS = "name",
    HS = function () {
        function a(e, t, r) {
            this.type = "geoJSON", this._parsedMap = Q(), this._mapName = e, this._specialAreas = r, this._geoJSON = WS(t)
        }
        return a.prototype.load = function (e, t) {
            t = t || BS;
            var r = this._parsedMap.get(t);
            if (!r) {
                var i = this._parseToRegions(t);
                r = this._parsedMap.set(t, {
                    regions: i,
                    boundingRect: FS(i)
                })
            }
            var n = Q(),
                o = [];
            return T(r.regions, function (s) {
                var l = s.name;
                e && N(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), n.set(l, s)
            }), {
                regions: o,
                boundingRect: r.boundingRect || new gt(0, 0, 0, 0),
                regionsMap: n
            }
        }, a.prototype._parseToRegions = function (e) {
            var t = this._mapName,
                r = this._geoJSON,
                i;
            try {
                i = r ? D0(r, e) : []
            } catch (n) {
                throw new Error(`Invalid geoJson format
` + n.message)
            }
            return VS(t, i), T(i, function (n) {
                var o = n.name;
                zS(t, n), GS(t, n);
                var s = this._specialAreas && this._specialAreas[o];
                s && n.transformTo(s.left, s.top, s.width, s.height)
            }, this), i
        }, a.prototype.getMapForUser = function () {
            return {
                geoJson: this._geoJSON,
                geoJSON: this._geoJSON,
                specialAreas: this._specialAreas
            }
        }, a
    }();

function FS(a) {
    for (var e, t = 0; t < a.length; t++) {
        var r = a[t].getBoundingRect();
        e = e || r.clone(), e.union(r)
    }
    return e
}

function WS(a) {
    return q(a) ? typeof JSON < "u" && JSON.parse ? JSON.parse(a) : new Function("return (" + a + ");")() : a
}
var ta = Q();
const Ce = {
    registerMap: function (a, e, t) {
        if (e.svg) {
            var r = new RS(a, e.svg);
            ta.set(a, r)
        } else {
            var i = e.geoJson || e.geoJSON;
            i && !e.features ? t = e.specialAreas : i = e;
            var r = new HS(a, i, t);
            ta.set(a, r)
        }
    },
    getGeoResource: function (a) {
        return ta.get(a)
    },
    getMapForUser: function (a) {
        var e = ta.get(a);
        return e && e.type === "geoJSON" && e.getMapForUser()
    },
    load: function (a, e, t) {
        var r = ta.get(a);
        if (r) return r.load(e, t)
    }
};
var cl = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"],
    $S = Q(cl),
    ZS = Q(cl.concat(["g"])),
    US = Q(cl.concat(["g"])),
    qp = xt();

function ai(a) {
    var e = a.getItemStyle(),
        t = a.get("areaColor");
    return t != null && (e.fill = t), e
}

function _v(a) {
    var e = a.style;
    e && (e.stroke = e.stroke || e.fill, e.fill = null)
}
var YS = function () {
    function a(e) {
        var t = new U;
        this.uid = jf("ec_map_draw"), this._controller = new Ka(e.getZr()), this._controllerHost = {
            target: t
        }, this.group = t, t.add(this._regionsGroup = new U), t.add(this._svgGroup = new U)
    }
    return a.prototype.draw = function (e, t, r, i, n) {
        var o = e.mainType === "geo",
            s = e.getData && e.getData();
        o && t.eachComponent({
            mainType: "series",
            subType: "map"
        }, function (y) {
            !s && y.getHostGeoModel() === e && (s = y.getData())
        });
        var l = e.coordinateSystem,
            u = this._regionsGroup,
            v = this.group,
            h = l.getTransformInfo(),
            c = h.raw,
            f = h.roam,
            p = !u.childAt(0) || n;
        p ? (v.x = f.x, v.y = f.y, v.scaleX = f.scaleX, v.scaleY = f.scaleY, v.dirty()) : yt(v, f, e);
        var d = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0,
            g = {
                api: r,
                geo: l,
                mapOrGeoModel: e,
                data: s,
                isVisualEncodedByVisualMap: d,
                isGeo: o,
                transformInfoRaw: c
            };
        l.resourceType === "geoJSON" ? this._buildGeoJSON(g) : l.resourceType === "geoSVG" && this._buildSVG(g), this._updateController(e, t, r), this._updateMapSelectHandler(e, u, r, i)
    }, a.prototype._buildGeoJSON = function (e) {
        var t = this._regionsGroupByName = Q(),
            r = Q(),
            i = this._regionsGroup,
            n = e.transformInfoRaw,
            o = e.mapOrGeoModel,
            s = e.data,
            l = e.geo.projection,
            u = l && l.stream;

        function v(f, p) {
            return p && (f = p(f)), f && [f[0] * n.scaleX + n.x, f[1] * n.scaleY + n.y]
        }

        function h(f) {
            for (var p = [], d = !u && l && l.project, g = 0; g < f.length; ++g) {
                var y = v(f[g], d);
                y && p.push(y)
            }
            return p
        }

        function c(f) {
            return {
                shape: {
                    points: h(f)
                }
            }
        }
        i.removeAll(), T(e.geo.regions, function (f) {
            var p = f.name,
                d = t.get(p),
                g = r.get(p) || {},
                y = g.dataIdx,
                x = g.regionModel;
            d || (d = t.set(p, new U), i.add(d), y = s ? s.indexOfName(p) : null, x = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(y) : null, r.set(p, {
                dataIdx: y,
                regionModel: x
            }));
            var m = [],
                S = [];
            T(f.geometries, function (w) {
                if (w.type === "polygon") {
                    var A = [w.exterior].concat(w.interiors || []);
                    u && (A = Dv(A, u)), T(A, function (D) {
                        m.push(new de(c(D)))
                    })
                } else {
                    var C = w.points;
                    u && (C = Dv(C, u, !0)), T(C, function (D) {
                        S.push(new $e(c(D)))
                    })
                }
            });
            var _ = v(f.getCenter(), l && l.project);

            function b(w, A) {
                if (w.length) {
                    var C = new Ff({
                        culling: !0,
                        segmentIgnoreThreshold: 1,
                        shape: {
                            paths: w
                        }
                    });
                    d.add(C), bv(e, C, y, x), wv(e, C, p, x, o, y, _), A && (_v(C), T(C.states, _v))
                }
            }
            b(m), b(S, !0)
        }), t.each(function (f, p) {
            var d = r.get(p),
                g = d.dataIdx,
                y = d.regionModel;
            Av(e, f, p, y, o, g), Tv(e, f, p, y, o), Cv(e, f, p, y, o)
        }, this)
    }, a.prototype._buildSVG = function (e) {
        var t = e.geo.map,
            r = e.transformInfoRaw;
        this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
        var i = this._svgDispatcherMap = Q(),
            n = !1;
        T(this._svgGraphicRecord.named, function (o) {
            var s = o.name,
                l = e.mapOrGeoModel,
                u = e.data,
                v = o.svgNodeTagLower,
                h = o.el,
                c = u ? u.indexOfName(s) : null,
                f = l.getRegionModel(s);
            if ($S.get(v) != null && h instanceof hr && bv(e, h, c, f), h instanceof hr && (h.culling = !0), h.z2EmphasisLift = 0, !o.namedFrom && (US.get(v) != null && wv(e, h, s, f, l, c, null), Av(e, h, s, f, l, c), Tv(e, h, s, f, l), ZS.get(v) != null)) {
                var p = Cv(e, h, s, f, l);
                p === "self" && (n = !0);
                var d = i.get(s) || i.set(s, []);
                d.push(h)
            }
        }, this), this._enableBlurEntireSVG(n, e)
    }, a.prototype._enableBlurEntireSVG = function (e, t) {
        if (e && t.isGeo) {
            var r = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(),
                i = r.opacity;
            this._svgGraphicRecord.root.traverse(function (n) {
                if (!n.isGroup) {
                    Ur(n);
                    var o = n.ensureState("blur").style || {};
                    o.opacity == null && i != null && (o.opacity = i), n.ensureState("emphasis")
                }
            })
        }
    }, a.prototype.remove = function () {
        this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null
    }, a.prototype.findHighDownDispatchers = function (e, t) {
        if (e == null) return [];
        var r = t.coordinateSystem;
        if (r.resourceType === "geoJSON") {
            var i = this._regionsGroupByName;
            if (i) {
                var n = i.get(e);
                return n ? [n] : []
            }
        } else if (r.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || []
    }, a.prototype._svgResourceChanged = function (e) {
        return this._svgMapName !== e
    }, a.prototype._useSVG = function (e) {
        var t = Ce.getGeoResource(e);
        if (t && t.type === "geoSVG") {
            var r = t.useGraphic(this.uid);
            this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = e
        }
    }, a.prototype._freeSVG = function () {
        var e = this._svgMapName;
        if (e != null) {
            var t = Ce.getGeoResource(e);
            t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null
        }
    }, a.prototype._updateController = function (e, t, r) {
        var i = e.coordinateSystem,
            n = this._controller,
            o = this._controllerHost;
        o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), n.enable(e.get("roam") || !1);
        var s = e.mainType;

        function l() {
            var u = {
                type: "geoRoam",
                componentType: s
            };
            return u[s + "Id"] = e.id, u
        }
        n.off("pan").on("pan", function (u) {
            this._mouseDownFlag = !1, vl(o, u.dx, u.dy), r.dispatchAction(W(l(), {
                dx: u.dx,
                dy: u.dy,
                animation: {
                    duration: 0
                }
            }))
        }, this), n.off("zoom").on("zoom", function (u) {
            this._mouseDownFlag = !1, hl(o, u.scale, u.originX, u.originY), r.dispatchAction(W(l(), {
                zoom: u.scale,
                originX: u.originX,
                originY: u.originY,
                animation: {
                    duration: 0
                }
            }))
        }, this), n.setPointerChecker(function (u, v, h) {
            return i.containPoint([v, h]) && !yn(u, r, e)
        })
    }, a.prototype.resetForLabelLayout = function () {
        this.group.traverse(function (e) {
            var t = e.getTextContent();
            t && (t.ignore = qp(t).ignore)
        })
    }, a.prototype._updateMapSelectHandler = function (e, t, r, i) {
        var n = this;
        t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function () {
            n._mouseDownFlag = !0
        }), t.on("click", function (o) {
            n._mouseDownFlag && (n._mouseDownFlag = !1)
        }))
    }, a
}();

function bv(a, e, t, r) {
    var i = r.getModel("itemStyle"),
        n = r.getModel(["emphasis", "itemStyle"]),
        o = r.getModel(["blur", "itemStyle"]),
        s = r.getModel(["select", "itemStyle"]),
        l = ai(i),
        u = ai(n),
        v = ai(s),
        h = ai(o),
        c = a.data;
    if (c) {
        var f = c.getItemVisual(t, "style"),
            p = c.getItemVisual(t, "decal");
        a.isVisualEncodedByVisualMap && f.fill && (l.fill = f.fill), p && (l.decal = on(p, a.api))
    }
    e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = v, e.ensureState("blur").style = h, Ur(e)
}

function wv(a, e, t, r, i, n, o) {
    var s = a.data,
        l = a.isGeo,
        u = s && isNaN(s.get(s.mapDimension("value"), n)),
        v = s && s.getItemLayout(n);
    if (l || u || v && v.showLabel) {
        var h = l ? t : n,
            c = void 0;
        (!s || n >= 0) && (c = i);
        var f = o ? {
            normal: {
                align: "center",
                verticalAlign: "middle"
            }
        } : null;
        Xt(e, Gt(r), {
            labelFetcher: c,
            labelDataIndex: h,
            defaultText: t
        }, f);
        var p = e.getTextContent();
        if (p && (qp(p).ignore = p.ignore, e.textConfig && o)) {
            var d = e.getBoundingRect().clone();
            e.textConfig.layoutRect = d, e.textConfig.position = [(o[0] - d.x) / d.width * 100 + "%", (o[1] - d.y) / d.height * 100 + "%"]
        }
        e.disableLabelAnimation = !0
    } else e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null
}

function Av(a, e, t, r, i, n) {
    a.data ? a.data.setItemGraphicEl(n, e) : tt(e).eventData = {
        componentType: "geo",
        componentIndex: i.componentIndex,
        geoIndex: i.componentIndex,
        name: t,
        region: r && r.option || {}
    }
}

function Tv(a, e, t, r, i) {
    a.data || sn({
        el: e,
        componentModel: i,
        itemName: t,
        itemTooltipOption: r.get("tooltip")
    })
}

function Cv(a, e, t, r, i) {
    e.highDownSilentOnTouch = !!i.get("selectedMode");
    var n = r.getModel("emphasis"),
        o = n.get("focus");
    return Tt(e, o, n.get("blurScope"), n.get("disabled")), a.isGeo && am(e, i, t), o
}

function Dv(a, e, t) {
    var r = [],
        i;

    function n() {
        i = []
    }

    function o() {
        i.length && (r.push(i), i = [])
    }
    var s = e({
        polygonStart: n,
        polygonEnd: o,
        lineStart: n,
        lineEnd: o,
        point: function (l, u) {
            isFinite(l) && isFinite(u) && i.push([l, u])
        },
        sphere: function () {}
    });
    return !t && s.polygonStart(), T(a, function (l) {
        s.lineStart();
        for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1]);
        s.lineEnd()
    }), !t && s.polygonEnd(), r
}
const jp = YS;
var XS = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i, n) {
        if (!(n && n.type === "mapToggleSelect" && n.from === this.uid)) {
            var o = this.group;
            if (o.removeAll(), !t.getHostGeoModel()) {
                if (this._mapDraw && n && n.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), n && n.type === "geoRoam" && n.componentType === "series" && n.seriesId === t.id) {
                    var s = this._mapDraw;
                    s && o.add(s.group)
                } else if (t.needsDrawMap) {
                    var s = this._mapDraw || new jp(i);
                    o.add(s.group), s.draw(t, r, i, this, n), this._mapDraw = s
                } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
                t.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(t, r, i)
            }
        }
    }, e.prototype.remove = function () {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll()
    }, e.prototype.dispose = function () {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null
    }, e.prototype._renderSymbols = function (t, r, i) {
        var n = t.originalData,
            o = this.group;
        n.each(n.mapDimension("value"), function (s, l) {
            if (!isNaN(s)) {
                var u = n.getItemLayout(l);
                if (!(!u || !u.point)) {
                    var v = u.point,
                        h = u.offset,
                        c = new nn({
                            style: {
                                fill: t.getData().getVisual("style").fill
                            },
                            shape: {
                                cx: v[0] + h * 9,
                                cy: v[1],
                                r: 3
                            },
                            silent: !0,
                            z2: 8 + (h ? 0 : Fa + 1)
                        });
                    if (!h) {
                        var f = t.mainSeries.getData(),
                            p = n.getName(l),
                            d = f.indexOfName(p),
                            g = n.getItemModel(l),
                            y = g.getModel("label"),
                            x = f.getItemGraphicEl(d);
                        Xt(c, Gt(g), {
                            labelFetcher: {
                                getFormattedLabel: function (m, S) {
                                    return t.getFormattedLabel(d, S)
                                }
                            },
                            defaultText: p
                        }), c.disableLabelAnimation = !0, y.get("position") || c.setTextConfig({
                            position: "bottom"
                        }), x.onHoverStateChange = function (m) {
                            Ti(c, m)
                        }
                    }
                    o.add(c)
                }
            }
        })
    }, e.type = "map", e
}(At);
const KS = XS;
var qS = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function (r) {
            if (r != null) {
                var i = this.getData().getName(r),
                    n = this.coordinateSystem,
                    o = n.getRegion(i);
                return o && n.dataToPoint(o.getCenter())
            }
        }, t
    }
    return e.prototype.getInitialData = function (t) {
        for (var r = ln(this, {
                coordDimensions: ["value"],
                encodeDefaulter: K(Jf, this)
            }), i = Q(), n = [], o = 0, s = r.count(); o < s; o++) {
            var l = r.getName(o);
            i.set(l, !0)
        }
        var u = Ce.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
        return T(u.regions, function (v) {
            var h = v.name;
            i.get(h) || n.push(h)
        }), r.appendValues([], n), r
    }, e.prototype.getHostGeoModel = function () {
        var t = this.option.geoIndex;
        return t != null ? this.ecModel.getComponent("geo", t) : null
    }, e.prototype.getMapType = function () {
        return (this.getHostGeoModel() || this).option.map
    }, e.prototype.getRawValue = function (t) {
        var r = this.getData();
        return r.get(r.mapDimension("value"), t)
    }, e.prototype.getRegionModel = function (t) {
        var r = this.getData();
        return r.getItemModel(r.indexOfName(t))
    }, e.prototype.formatTooltip = function (t, r, i) {
        for (var n = this.getData(), o = this.getRawValue(t), s = n.getName(t), l = this.seriesGroup, u = [], v = 0; v < l.length; v++) {
            var h = l[v].originalData.indexOfName(s),
                c = n.mapDimension("value");
            isNaN(l[v].originalData.get(c, h)) || u.push(l[v].name)
        }
        return qt("section", {
            header: u.join(", "),
            noHeader: !u.length,
            blocks: [qt("nameValue", {
                name: s,
                value: o
            })]
        })
    }, e.prototype.setZoom = function (t) {
        this.option.zoom = t
    }, e.prototype.setCenter = function (t) {
        this.option.center = t
    }, e.prototype.getLegendIcon = function (t) {
        var r = t.icon || "roundRect",
            i = Et(r, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
        return i.setStyle(t.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
        z: 2,
        coordinateSystem: "geo",
        map: "",
        left: "center",
        top: "center",
        aspectScale: null,
        showLegendSymbol: !0,
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        selectedMode: !0,
        label: {
            show: !1,
            color: "#000"
        },
        itemStyle: {
            borderWidth: .5,
            borderColor: "#444",
            areaColor: "#eee"
        },
        emphasis: {
            label: {
                show: !0,
                color: "rgb(100,0,0)"
            },
            itemStyle: {
                areaColor: "rgba(255,215,0,0.8)"
            }
        },
        select: {
            label: {
                show: !0,
                color: "rgb(100,0,0)"
            },
            itemStyle: {
                color: "rgba(255,215,0,0.8)"
            }
        },
        nameProperty: "name"
    }, e
}(Vt);
const jS = qS;

function JS(a, e) {
    var t = {};
    return T(a, function (r) {
        r.each(r.mapDimension("value"), function (i, n) {
            var o = "ec-" + r.getName(n);
            t[o] = t[o] || [], isNaN(i) || t[o].push(i)
        })
    }), a[0].map(a[0].mapDimension("value"), function (r, i) {
        for (var n = "ec-" + a[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = t[n].length, v = 0; v < u; v++) s = Math.min(s, t[n][v]), l = Math.max(l, t[n][v]), o += t[n][v];
        var h;
        return e === "min" ? h = s : e === "max" ? h = l : e === "average" ? h = o / u : h = o, u === 0 ? NaN : h
    })
}

function QS(a) {
    var e = {};
    a.eachSeriesByType("map", function (t) {
        var r = t.getHostGeoModel(),
            i = r ? "o" + r.id : "i" + t.getMapType();
        (e[i] = e[i] || []).push(t)
    }), T(e, function (t, r) {
        for (var i = JS(G(t, function (o) {
                return o.getData()
            }), t[0].get("mapValueCalculation")), n = 0; n < t.length; n++) t[n].originalData = t[n].getData();
        for (var n = 0; n < t.length; n++) t[n].seriesGroup = t, t[n].needsDrawMap = n === 0 && !t[n].getHostGeoModel(), t[n].setData(i.cloneShallow()), t[n].mainSeries = t[0]
    })
}

function t1(a) {
    var e = {};
    a.eachSeriesByType("map", function (t) {
        var r = t.getMapType();
        if (!(t.getHostGeoModel() || e[r])) {
            var i = {};
            T(t.seriesGroup, function (o) {
                var s = o.coordinateSystem,
                    l = o.originalData;
                o.get("showLegendSymbol") && a.getComponent("legend") && l.each(l.mapDimension("value"), function (u, v) {
                    var h = l.getName(v),
                        c = s.getRegion(h);
                    if (!(!c || isNaN(u))) {
                        var f = i[h] || 0,
                            p = s.dataToPoint(c.getCenter());
                        i[h] = f + 1, l.setItemLayout(v, {
                            point: p,
                            offset: f
                        })
                    }
                })
            });
            var n = t.getData();
            n.each(function (o) {
                var s = n.getName(o),
                    l = n.getItemLayout(o) || {};
                l.showLabel = !i[s], n.setItemLayout(o, l)
            }), e[r] = !0
        }
    })
}
var Iv = vr,
    qa = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this) || this;
            return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Er, r._rawTransformable = new Er, r.name = t, r
        }
        return e.prototype.setBoundingRect = function (t, r, i, n) {
            return this._rect = new gt(t, r, i, n), this._rect
        }, e.prototype.getBoundingRect = function () {
            return this._rect
        }, e.prototype.setViewRect = function (t, r, i, n) {
            this._transformTo(t, r, i, n), this._viewRect = new gt(t, r, i, n)
        }, e.prototype._transformTo = function (t, r, i, n) {
            var o = this.getBoundingRect(),
                s = this._rawTransformable;
            s.transform = o.calculateTransform(new gt(t, r, i, n));
            var l = s.parent;
            s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform()
        }, e.prototype.setCenter = function (t, r) {
            t && (this._center = [H(t[0], r.getWidth()), H(t[1], r.getHeight())], this._updateCenterAndZoom())
        }, e.prototype.setZoom = function (t) {
            t = t || 1;
            var r = this.zoomLimit;
            r && (r.max != null && (t = Math.min(r.max, t)), r.min != null && (t = Math.max(r.min, t))), this._zoom = t, this._updateCenterAndZoom()
        }, e.prototype.getDefaultCenter = function () {
            var t = this.getBoundingRect(),
                r = t.x + t.width / 2,
                i = t.y + t.height / 2;
            return [r, i]
        }, e.prototype.getCenter = function () {
            return this._center || this.getDefaultCenter()
        }, e.prototype.getZoom = function () {
            return this._zoom || 1
        }, e.prototype.getRoamTransform = function () {
            return this._roamTransformable.getLocalTransform()
        }, e.prototype._updateCenterAndZoom = function () {
            var t = this._rawTransformable.getLocalTransform(),
                r = this._roamTransformable,
                i = this.getDefaultCenter(),
                n = this.getCenter(),
                o = this.getZoom();
            n = vr([], n, t), i = vr([], i, t), r.originX = n[0], r.originY = n[1], r.x = i[0] - n[0], r.y = i[1] - n[1], r.scaleX = r.scaleY = o, this._updateTransform()
        }, e.prototype._updateTransform = function () {
            var t = this._roamTransformable,
                r = this._rawTransformable;
            r.parent = t, t.updateTransform(), r.updateTransform(), im(this.transform || (this.transform = []), r.transform || yr()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], $s(this.invTransform, this.transform), this.decomposeTransform()
        }, e.prototype.getTransformInfo = function () {
            var t = this._rawTransformable,
                r = this._roamTransformable,
                i = new Er;
            return i.transform = r.transform, i.decomposeTransform(), {
                roam: {
                    x: i.x,
                    y: i.y,
                    scaleX: i.scaleX,
                    scaleY: i.scaleY
                },
                raw: {
                    x: t.x,
                    y: t.y,
                    scaleX: t.scaleX,
                    scaleY: t.scaleY
                }
            }
        }, e.prototype.getViewRect = function () {
            return this._viewRect
        }, e.prototype.getViewRectAfterRoam = function () {
            var t = this.getBoundingRect().clone();
            return t.applyTransform(this.transform), t
        }, e.prototype.dataToPoint = function (t, r, i) {
            var n = r ? this._rawTransform : this.transform;
            return i = i || [], n ? Iv(i, t, n) : Ft(i, t)
        }, e.prototype.pointToData = function (t) {
            var r = this.invTransform;
            return r ? Iv([], t, r) : [t[0], t[1]]
        }, e.prototype.convertToPixel = function (t, r, i) {
            var n = Lv(r);
            return n === this ? n.dataToPoint(i) : null
        }, e.prototype.convertFromPixel = function (t, r, i) {
            var n = Lv(r);
            return n === this ? n.pointToData(i) : null
        }, e.prototype.containPoint = function (t) {
            return this.getViewRectAfterRoam().contain(t[0], t[1])
        }, e.dimensions = ["x", "y"], e
    }(Er);

function Lv(a) {
    var e = a.seriesModel;
    return e ? e.coordinateSystem : null
}
var e1 = {
        geoJSON: {
            aspectScale: .75,
            invertLongitute: !0
        },
        geoSVG: {
            aspectScale: 1,
            invertLongitute: !1
        }
    },
    Jp = ["lng", "lat"],
    Qp = function (a) {
        E(e, a);

        function e(t, r, i) {
            var n = a.call(this, t) || this;
            n.dimensions = Jp, n.type = "geo", n._nameCoordMap = Q(), n.map = r;
            var o = i.projection,
                s = Ce.load(r, i.nameMap, i.nameProperty),
                l = Ce.getGeoResource(r);
            n.resourceType = l ? l.type : null;
            var u = n.regions = s.regions,
                v = e1[l.type];
            n._regionsMap = s.regionsMap, n.regions = s.regions, n.projection = o;
            var h;
            if (o)
                for (var c = 0; c < u.length; c++) {
                    var f = u[c].getBoundingRect(o);
                    h = h || f.clone(), h.union(f)
                } else h = s.boundingRect;
            return n.setBoundingRect(h.x, h.y, h.width, h.height), n.aspectScale = o ? 1 : Lt(i.aspectScale, v.aspectScale), n._invertLongitute = o ? !1 : v.invertLongitute, n
        }
        return e.prototype._transformTo = function (t, r, i, n) {
            var o = this.getBoundingRect(),
                s = this._invertLongitute;
            o = o.clone(), s && (o.y = -o.y - o.height);
            var l = this._rawTransformable;
            l.transform = o.calculateTransform(new gt(t, r, i, n));
            var u = l.parent;
            l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform()
        }, e.prototype.getRegion = function (t) {
            return this._regionsMap.get(t)
        }, e.prototype.getRegionByCoord = function (t) {
            for (var r = this.regions, i = 0; i < r.length; i++) {
                var n = r[i];
                if (n.type === "geoJSON" && n.contain(t)) return r[i]
            }
        }, e.prototype.addGeoCoord = function (t, r) {
            this._nameCoordMap.set(t, r)
        }, e.prototype.getGeoCoord = function (t) {
            var r = this._regionsMap.get(t);
            return this._nameCoordMap.get(t) || r && r.getCenter()
        }, e.prototype.dataToPoint = function (t, r, i) {
            if (q(t) && (t = this.getGeoCoord(t)), t) {
                var n = this.projection;
                return n && (t = n.project(t)), t && this.projectedToPoint(t, r, i)
            }
        }, e.prototype.pointToData = function (t) {
            var r = this.projection;
            return r && (t = r.unproject(t)), t && this.pointToProjected(t)
        }, e.prototype.pointToProjected = function (t) {
            return a.prototype.pointToData.call(this, t)
        }, e.prototype.projectedToPoint = function (t, r, i) {
            return a.prototype.dataToPoint.call(this, t, r, i)
        }, e.prototype.convertToPixel = function (t, r, i) {
            var n = Mv(r);
            return n === this ? n.dataToPoint(i) : null
        }, e.prototype.convertFromPixel = function (t, r, i) {
            var n = Mv(r);
            return n === this ? n.pointToData(i) : null
        }, e
    }(qa);
le(Qp, qa);

function Mv(a) {
    var e = a.geoModel,
        t = a.seriesModel;
    return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", Kt).models[0] || {}).coordinateSystem : null
}
const Pv = Qp;

function Rv(a, e) {
    var t = a.get("boundingCoords");
    if (t != null) {
        var r = t[0],
            i = t[1];
        if (isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])) {
            var n = this.projection;
            if (n) {
                var o = r[0],
                    s = r[1],
                    l = i[0],
                    u = i[1];
                r = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
                var v = function (b, w, A, C) {
                    for (var D = A - b, I = C - w, L = 0; L <= 100; L++) {
                        var M = L / 100,
                            P = n.project([b + D * M, w + I * M]);
                        Of(r, r, P), zf(i, i, P)
                    }
                };
                v(o, s, l, s), v(l, s, l, u), v(l, u, o, u), v(o, u, l, s)
            }
            this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1])
        }
    }
    var h = this.getBoundingRect(),
        c = a.get("layoutCenter"),
        f = a.get("layoutSize"),
        p = e.getWidth(),
        d = e.getHeight(),
        g = h.width / h.height * this.aspectScale,
        y = !1,
        x, m;
    c && f && (x = [H(c[0], p), H(c[1], d)], m = H(f, Math.min(p, d)), !isNaN(x[0]) && !isNaN(x[1]) && !isNaN(m) && (y = !0));
    var S;
    if (y) S = {}, g > 1 ? (S.width = m, S.height = m / g) : (S.height = m, S.width = m * g), S.y = x[1] - S.height / 2, S.x = x[0] - S.width / 2;
    else {
        var _ = a.getBoxLayoutParams();
        _.aspect = g, S = kt(_, {
            width: p,
            height: d
        })
    }
    this.setViewRect(S.x, S.y, S.width, S.height), this.setCenter(a.get("center"), e), this.setZoom(a.get("zoom"))
}

function r1(a, e) {
    T(e.get("geoCoord"), function (t, r) {
        a.addGeoCoord(r, t)
    })
}
var a1 = function () {
        function a() {
            this.dimensions = Jp
        }
        return a.prototype.create = function (e, t) {
            var r = [];

            function i(o) {
                return {
                    nameProperty: o.get("nameProperty"),
                    aspectScale: o.get("aspectScale"),
                    projection: o.get("projection")
                }
            }
            e.eachComponent("geo", function (o, s) {
                var l = o.get("map"),
                    u = new Pv(l + s, l, W({
                        nameMap: o.get("nameMap")
                    }, i(o)));
                u.zoomLimit = o.get("scaleLimit"), r.push(u), o.coordinateSystem = u, u.model = o, u.resize = Rv, u.resize(o, t)
            }), e.eachSeries(function (o) {
                var s = o.get("coordinateSystem");
                if (s === "geo") {
                    var l = o.get("geoIndex") || 0;
                    o.coordinateSystem = r[l]
                }
            });
            var n = {};
            return e.eachSeriesByType("map", function (o) {
                if (!o.getHostGeoModel()) {
                    var s = o.getMapType();
                    n[s] = n[s] || [], n[s].push(o)
                }
            }), T(n, function (o, s) {
                var l = G(o, function (v) {
                        return v.get("nameMap")
                    }),
                    u = new Pv(s, s, W({
                        nameMap: Xs(l)
                    }, i(o[0])));
                u.zoomLimit = Ut.apply(null, G(o, function (v) {
                    return v.get("scaleLimit")
                })), r.push(u), u.resize = Rv, u.resize(o[0], t), T(o, function (v) {
                    v.coordinateSystem = u, r1(u, v)
                })
            }), r
        }, a.prototype.getFilledRegions = function (e, t, r, i) {
            for (var n = (e || []).slice(), o = Q(), s = 0; s < n.length; s++) o.set(n[s].name, n[s]);
            var l = Ce.load(t, r, i);
            return T(l.regions, function (u) {
                var v = u.name;
                !o.get(v) && n.push({
                    name: v
                })
            }), n
        }, a
    }(),
    i1 = new a1;
const td = i1;
var n1 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function (t, r, i) {
        var n = Ce.getGeoResource(t.map);
        if (n && n.type === "geoJSON") {
            var o = t.itemStyle = t.itemStyle || {};
            "color" in o || (o.color = "#eee")
        }
        this.mergeDefaultAndTheme(t, i), un(t, "label", ["show"])
    }, e.prototype.optionUpdated = function () {
        var t = this,
            r = this.option;
        r.regions = td.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty);
        var i = {};
        this._optionModelMap = Qf(r.regions || [], function (n, o) {
            var s = o.name;
            return s && (n.set(s, new Rt(o, t, t.ecModel)), o.selected && (i[s] = !0)), n
        }, Q()), r.selectedMap || (r.selectedMap = i)
    }, e.prototype.getRegionModel = function (t) {
        return this._optionModelMap.get(t) || new Rt(null, this, this.ecModel)
    }, e.prototype.getFormattedLabel = function (t, r) {
        var i = this.getRegionModel(t),
            n = r === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]),
            o = {
                name: t
            };
        if (rt(n)) return o.status = r, n(o);
        if (q(n)) return n.replace("{a}", t ? ? "")
    }, e.prototype.setZoom = function (t) {
        this.option.zoom = t
    }, e.prototype.setCenter = function (t) {
        this.option.center = t
    }, e.prototype.select = function (t) {
        var r = this.option,
            i = r.selectedMode;
        if (i) {
            i !== "multiple" && (r.selectedMap = null);
            var n = r.selectedMap || (r.selectedMap = {});
            n[t] = !0
        }
    }, e.prototype.unSelect = function (t) {
        var r = this.option.selectedMap;
        r && (r[t] = !1)
    }, e.prototype.toggleSelected = function (t) {
        this[this.isSelected(t) ? "unSelect" : "select"](t)
    }, e.prototype.isSelected = function (t) {
        var r = this.option.selectedMap;
        return !!(r && r[t])
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
        z: 0,
        show: !0,
        left: "center",
        top: "center",
        aspectScale: null,
        silent: !1,
        map: "",
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        label: {
            show: !1,
            color: "#000"
        },
        itemStyle: {
            borderWidth: .5,
            borderColor: "#444"
        },
        emphasis: {
            label: {
                show: !0,
                color: "rgb(100,0,0)"
            },
            itemStyle: {
                color: "rgba(255,215,0,0.8)"
            }
        },
        select: {
            label: {
                show: !0,
                color: "rgb(100,0,0)"
            },
            itemStyle: {
                color: "rgba(255,215,0,0.8)"
            }
        },
        regions: []
    }, e
}(Ct);
const o1 = n1;

function Ev(a, e) {
    return a.pointToProjected ? a.pointToProjected(e) : a.pointToData(e)
}

function fl(a, e, t, r) {
    var i = a.getZoom(),
        n = a.getCenter(),
        o = e.zoom,
        s = a.projectedToPoint ? a.projectedToPoint(n) : a.dataToPoint(n);
    if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, a.setCenter(Ev(a, s), r)), o != null) {
        if (t) {
            var l = t.min || 0,
                u = t.max || 1 / 0;
            o = Math.max(Math.min(i * o, u), l) / i
        }
        a.scaleX *= o, a.scaleY *= o;
        var v = (e.originX - a.x) * (o - 1),
            h = (e.originY - a.y) * (o - 1);
        a.x -= v, a.y -= h, a.updateTransform(), a.setCenter(Ev(a, s), r), a.setZoom(o * i)
    }
    return {
        center: a.getCenter(),
        zoom: a.getZoom()
    }
}
var s1 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.focusBlurEnabled = !0, t
    }
    return e.prototype.init = function (t, r) {
        this._api = r
    }, e.prototype.render = function (t, r, i, n) {
        if (this._model = t, !t.get("show")) {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
            return
        }
        this._mapDraw || (this._mapDraw = new jp(i));
        var o = this._mapDraw;
        o.draw(t, r, i, this, n), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, r, i)
    }, e.prototype._handleRegionClick = function (t) {
        var r;
        Ks(t.target, function (i) {
            return (r = tt(i).eventData) != null
        }, !0), r && this._api.dispatchAction({
            type: "geoToggleSelect",
            geoId: this._model.id,
            name: r.name
        })
    }, e.prototype.updateSelectStatus = function (t, r, i) {
        var n = this;
        this._mapDraw.group.traverse(function (o) {
            var s = tt(o).eventData;
            if (s) return n._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0
        })
    }, e.prototype.findHighDownDispatchers = function (t) {
        return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model)
    }, e.prototype.dispose = function () {
        this._mapDraw && this._mapDraw.remove()
    }, e.type = "geo", e
}(It);
const l1 = s1;

function u1(a, e, t) {
    Ce.registerMap(a, e, t)
}

function ed(a) {
    a.registerCoordinateSystem("geo", td), a.registerComponentModel(o1), a.registerComponentView(l1), a.registerImpl("registerMap", u1), a.registerImpl("getMap", function (t) {
        return Ce.getMapForUser(t)
    });

    function e(t, r) {
        r.update = "geo:updateSelectStatus", a.registerAction(r, function (i, n) {
            var o = {},
                s = [];
            return n.eachComponent({
                mainType: "geo",
                query: i
            }, function (l) {
                l[t](i.name);
                var u = l.coordinateSystem;
                T(u.regions, function (h) {
                    o[h.name] = l.isSelected(h.name) || !1
                });
                var v = [];
                T(o, function (h, c) {
                    o[c] && v.push(c)
                }), s.push({
                    geoIndex: l.componentIndex,
                    name: v
                })
            }), {
                selected: o,
                allSelected: s,
                name: i.name
            }
        })
    }
    e("toggleSelected", {
        type: "geoToggleSelect",
        event: "geoselectchanged"
    }), e("select", {
        type: "geoSelect",
        event: "geoselected"
    }), e("unSelect", {
        type: "geoUnSelect",
        event: "geounselected"
    }), a.registerAction({
        type: "geoRoam",
        event: "geoRoam",
        update: "updateTransform"
    }, function (t, r, i) {
        var n = t.componentType || "series";
        r.eachComponent({
            mainType: n,
            query: t
        }, function (o) {
            var s = o.coordinateSystem;
            if (s.type === "geo") {
                var l = fl(s, t, o.get("scaleLimit"), i);
                o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), n === "series" && T(o.seriesGroup, function (u) {
                    u.setCenter(l.center), u.setZoom(l.zoom)
                })
            }
        })
    })
}

function v1(a) {
    j(ed), a.registerChartView(KS), a.registerSeriesModel(jS), a.registerLayout(t1), a.registerProcessor(a.PRIORITY.PROCESSOR.STATISTIC, QS), nm("map", a.registerAction)
}

function h1(a) {
    var e = a;
    e.hierNode = {
        defaultAncestor: null,
        ancestor: e,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: 0,
        thread: null
    };
    for (var t = [e], r, i; r = t.pop();)
        if (i = r.children, r.isExpand && i.length)
            for (var n = i.length, o = n - 1; o >= 0; o--) {
                var s = i[o];
                s.hierNode = {
                    defaultAncestor: null,
                    ancestor: s,
                    prelim: 0,
                    modifier: 0,
                    change: 0,
                    shift: 0,
                    i: o,
                    thread: null
                }, t.push(s)
            }
}

function c1(a, e) {
    var t = a.isExpand ? a.children : [],
        r = a.parentNode.children,
        i = a.hierNode.i ? r[a.hierNode.i - 1] : null;
    if (t.length) {
        d1(a);
        var n = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
        i ? (a.hierNode.prelim = i.hierNode.prelim + e(a, i), a.hierNode.modifier = a.hierNode.prelim - n) : a.hierNode.prelim = n
    } else i && (a.hierNode.prelim = i.hierNode.prelim + e(a, i));
    a.parentNode.hierNode.defaultAncestor = g1(a, i, a.parentNode.hierNode.defaultAncestor || r[0], e)
}

function f1(a) {
    var e = a.hierNode.prelim + a.parentNode.hierNode.modifier;
    a.setLayout({
        x: e
    }, !0), a.hierNode.modifier += a.parentNode.hierNode.modifier
}

function kv(a) {
    return arguments.length ? a : x1
}

function fa(a, e) {
    return a -= Math.PI / 2, {
        x: e * Math.cos(a),
        y: e * Math.sin(a)
    }
}

function p1(a, e) {
    return kt(a.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
    })
}

function d1(a) {
    for (var e = a.children, t = e.length, r = 0, i = 0; --t >= 0;) {
        var n = e[t];
        n.hierNode.prelim += r, n.hierNode.modifier += r, i += n.hierNode.change, r += n.hierNode.shift + i
    }
}

function g1(a, e, t, r) {
    if (e) {
        for (var i = a, n = a, o = n.parentNode.children[0], s = e, l = i.hierNode.modifier, u = n.hierNode.modifier, v = o.hierNode.modifier, h = s.hierNode.modifier; s = $n(s), n = Zn(n), s && n;) {
            i = $n(i), o = Zn(o), i.hierNode.ancestor = a;
            var c = s.hierNode.prelim + h - n.hierNode.prelim - u + r(s, n);
            c > 0 && (m1(y1(s, a, t), a, c), u += c, l += c), h += s.hierNode.modifier, u += n.hierNode.modifier, l += i.hierNode.modifier, v += o.hierNode.modifier
        }
        s && !$n(i) && (i.hierNode.thread = s, i.hierNode.modifier += h - l), n && !Zn(o) && (o.hierNode.thread = n, o.hierNode.modifier += u - v, t = a)
    }
    return t
}

function $n(a) {
    var e = a.children;
    return e.length && a.isExpand ? e[e.length - 1] : a.hierNode.thread
}

function Zn(a) {
    var e = a.children;
    return e.length && a.isExpand ? e[0] : a.hierNode.thread
}

function y1(a, e, t) {
    return a.hierNode.ancestor.parentNode === e.parentNode ? a.hierNode.ancestor : t
}

function m1(a, e, t) {
    var r = t / (e.hierNode.i - a.hierNode.i);
    e.hierNode.change -= r, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, a.hierNode.change += r
}

function x1(a, e) {
    return a.parentNode === e.parentNode ? 1 : 2
}
var S1 = function () {
        function a() {
            this.parentPoint = [], this.childPoints = []
        }
        return a
    }(),
    _1 = function (a) {
        E(e, a);

        function e(t) {
            return a.call(this, t) || this
        }
        return e.prototype.getDefaultStyle = function () {
            return {
                stroke: "#000",
                fill: null
            }
        }, e.prototype.getDefaultShape = function () {
            return new S1
        }, e.prototype.buildPath = function (t, r) {
            var i = r.childPoints,
                n = i.length,
                o = r.parentPoint,
                s = i[0],
                l = i[n - 1];
            if (n === 1) {
                t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
                return
            }
            var u = r.orient,
                v = u === "TB" || u === "BT" ? 0 : 1,
                h = 1 - v,
                c = H(r.forkPosition, 1),
                f = [];
            f[v] = o[v], f[h] = o[h] + (l[h] - o[h]) * c, t.moveTo(o[0], o[1]), t.lineTo(f[0], f[1]), t.moveTo(s[0], s[1]), f[v] = s[v], t.lineTo(f[0], f[1]), f[v] = l[v], t.lineTo(f[0], f[1]), t.lineTo(l[0], l[1]);
            for (var p = 1; p < n - 1; p++) {
                var d = i[p];
                t.moveTo(d[0], d[1]), f[v] = d[v], t.lineTo(f[0], f[1])
            }
        }, e
    }(Pt),
    b1 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._mainGroup = new U, t
        }
        return e.prototype.init = function (t, r) {
            this._controller = new Ka(r.getZr()), this._controllerHost = {
                target: this.group
            }, this.group.add(this._mainGroup)
        }, e.prototype.render = function (t, r, i) {
            var n = t.getData(),
                o = t.layoutInfo,
                s = this._mainGroup,
                l = t.get("layout");
            l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, i), this._updateController(t, r, i);
            var u = this._data;
            n.diff(u).add(function (v) {
                Vv(n, v) && Ov(n, v, null, s, t)
            }).update(function (v, h) {
                var c = u.getItemGraphicEl(h);
                if (!Vv(n, v)) {
                    c && Nv(u, h, c, s, t);
                    return
                }
                Ov(n, v, c, s, t)
            }).remove(function (v) {
                var h = u.getItemGraphicEl(v);
                h && Nv(u, v, h, s, t)
            }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && n.eachItemGraphicEl(function (v, h) {
                v.off("click").on("click", function () {
                    i.dispatchAction({
                        type: "treeExpandAndCollapse",
                        seriesId: t.id,
                        dataIndex: h
                    })
                })
            }), this._data = n
        }, e.prototype._updateViewCoordSys = function (t, r) {
            var i = t.getData(),
                n = [];
            i.each(function (h) {
                var c = i.getItemLayout(h);
                c && !isNaN(c.x) && !isNaN(c.y) && n.push([+c.x, +c.y])
            });
            var o = [],
                s = [];
            vn(n, o, s);
            var l = this._min,
                u = this._max;
            s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
            var v = t.coordinateSystem = new qa;
            v.zoomLimit = t.get("scaleLimit"), v.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), v.setCenter(t.get("center"), r), v.setZoom(t.get("zoom")), this.group.attr({
                x: v.x,
                y: v.y,
                scaleX: v.scaleX,
                scaleY: v.scaleY
            }), this._min = o, this._max = s
        }, e.prototype._updateController = function (t, r, i) {
            var n = this,
                o = this._controller,
                s = this._controllerHost,
                l = this.group;
            o.setPointerChecker(function (u, v, h) {
                var c = l.getBoundingRect();
                return c.applyTransform(l.transform), c.contain(v, h) && !yn(u, i, t)
            }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function (u) {
                vl(s, u.dx, u.dy), i.dispatchAction({
                    seriesId: t.id,
                    type: "treeRoam",
                    dx: u.dx,
                    dy: u.dy
                })
            }).on("zoom", function (u) {
                hl(s, u.scale, u.originX, u.originY), i.dispatchAction({
                    seriesId: t.id,
                    type: "treeRoam",
                    zoom: u.scale,
                    originX: u.originX,
                    originY: u.originY
                }), n._updateNodeAndLinkScale(t), i.updateLabelLayout()
            })
        }, e.prototype._updateNodeAndLinkScale = function (t) {
            var r = t.getData(),
                i = this._getNodeGlobalScale(t);
            r.eachItemGraphicEl(function (n, o) {
                n.setSymbolScale(i)
            })
        }, e.prototype._getNodeGlobalScale = function (t) {
            var r = t.coordinateSystem;
            if (r.type !== "view") return 1;
            var i = this._nodeScaleRatio,
                n = r.scaleX || 1,
                o = r.getZoom(),
                s = (o - 1) * i + 1;
            return s / n
        }, e.prototype.dispose = function () {
            this._controller && this._controller.dispose(), this._controllerHost = null
        }, e.prototype.remove = function () {
            this._mainGroup.removeAll(), this._data = null
        }, e.type = "tree", e
    }(At);

function Vv(a, e) {
    var t = a.getItemLayout(e);
    return t && !isNaN(t.x) && !isNaN(t.y)
}

function Ov(a, e, t, r, i) {
    var n = !t,
        o = a.tree.getNodeByDataIndex(e),
        s = o.getModel(),
        l = o.getVisual("style").fill,
        u = o.isExpand === !1 && o.children.length !== 0 ? l : "#fff",
        v = a.tree.root,
        h = o.parentNode === v ? o : o.parentNode || o,
        c = a.getItemGraphicEl(h.dataIndex),
        f = h.getLayout(),
        p = c ? {
            x: c.__oldX,
            y: c.__oldY,
            rawX: c.__radialOldRawX,
            rawY: c.__radialOldRawY
        } : f,
        d = o.getLayout();
    n ? (t = new Ua(a, e, null, {
        symbolInnerColor: u,
        useNameLabel: !0
    }), t.x = p.x, t.y = p.y) : t.updateData(a, e, null, {
        symbolInnerColor: u,
        useNameLabel: !0
    }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = d.rawX, t.__radialRawY = d.rawY, r.add(t), a.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, yt(t, {
        x: d.x,
        y: d.y
    }, i);
    var g = t.getSymbolPath();
    if (i.get("layout") === "radial") {
        var y = v.children[0],
            x = y.getLayout(),
            m = y.children.length,
            S = void 0,
            _ = void 0;
        if (d.x === x.x && o.isExpand === !0 && y.children.length) {
            var b = {
                x: (y.children[0].getLayout().x + y.children[m - 1].getLayout().x) / 2,
                y: (y.children[0].getLayout().y + y.children[m - 1].getLayout().y) / 2
            };
            S = Math.atan2(b.y - x.y, b.x - x.x), S < 0 && (S = Math.PI * 2 + S), _ = b.x < x.x, _ && (S = S - Math.PI)
        } else S = Math.atan2(d.y - x.y, d.x - x.x), S < 0 && (S = Math.PI * 2 + S), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (_ = d.x < x.x, _ && (S = S - Math.PI)) : (_ = d.x > x.x, _ || (S = S - Math.PI));
        var w = _ ? "left" : "right",
            A = s.getModel("label"),
            C = A.get("rotate"),
            D = C * (Math.PI / 180),
            I = g.getTextContent();
        I && (g.setTextConfig({
            position: A.get("position") || w,
            rotation: C == null ? -S : D,
            origin: "center"
        }), I.setStyle("verticalAlign", "middle"))
    }
    var L = s.get(["emphasis", "focus"]),
        M = L === "relative" ? qo(o.getAncestorsIndices(), o.getDescendantIndices()) : L === "ancestor" ? o.getAncestorsIndices() : L === "descendant" ? o.getDescendantIndices() : null;
    M && (tt(t).focus = M), w1(i, o, v, t, p, f, d, r), t.__edge && (t.onHoverStateChange = function (P) {
        if (P !== "blur") {
            var R = o.parentNode && a.getItemGraphicEl(o.parentNode.dataIndex);
            R && R.hoverState === om || Ti(t.__edge, P)
        }
    })
}

function w1(a, e, t, r, i, n, o, s) {
    var l = e.getModel(),
        u = a.get("edgeShape"),
        v = a.get("layout"),
        h = a.getOrient(),
        c = a.get(["lineStyle", "curveness"]),
        f = a.get("edgeForkPosition"),
        p = l.getModel("lineStyle").getLineStyle(),
        d = r.__edge;
    if (u === "curve") e.parentNode && e.parentNode !== t && (d || (d = r.__edge = new tp({
        shape: fs(v, h, c, i, i)
    })), yt(d, {
        shape: fs(v, h, c, n, o)
    }, a));
    else if (u === "polyline" && v === "orthogonal" && e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) {
        for (var g = e.children, y = [], x = 0; x < g.length; x++) {
            var m = g[x].getLayout();
            y.push([m.x, m.y])
        }
        d || (d = r.__edge = new _1({
            shape: {
                parentPoint: [o.x, o.y],
                childPoints: [
                    [o.x, o.y]
                ],
                orient: h,
                forkPosition: f
            }
        })), yt(d, {
            shape: {
                parentPoint: [o.x, o.y],
                childPoints: y
            }
        }, a)
    }
    d && !(u === "polyline" && !e.isExpand) && (d.useStyle(at({
        strokeNoScale: !0,
        fill: null
    }, p)), ee(d, l, "lineStyle"), Ur(d), s.add(d))
}

function zv(a, e, t, r, i) {
    var n = e.tree.root,
        o = rd(n, a),
        s = o.source,
        l = o.sourceLayout,
        u = e.getItemGraphicEl(a.dataIndex);
    if (u) {
        var v = e.getItemGraphicEl(s.dataIndex),
            h = v.__edge,
            c = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? h : void 0),
            f = r.get("edgeShape"),
            p = r.get("layout"),
            d = r.get("orient"),
            g = r.get(["lineStyle", "curveness"]);
        c && (f === "curve" ? Fr(c, {
            shape: fs(p, d, g, l, l),
            style: {
                opacity: 0
            }
        }, r, {
            cb: function () {
                t.remove(c)
            },
            removeOpt: i
        }) : f === "polyline" && r.get("layout") === "orthogonal" && Fr(c, {
            shape: {
                parentPoint: [l.x, l.y],
                childPoints: [
                    [l.x, l.y]
                ]
            },
            style: {
                opacity: 0
            }
        }, r, {
            cb: function () {
                t.remove(c)
            },
            removeOpt: i
        }))
    }
}

function rd(a, e) {
    for (var t = e.parentNode === a ? e : e.parentNode || e, r; r = t.getLayout(), r == null;) t = t.parentNode === a ? t : t.parentNode || t;
    return {
        source: t,
        sourceLayout: r
    }
}

function Nv(a, e, t, r, i) {
    var n = a.tree.getNodeByDataIndex(e),
        o = a.tree.root,
        s = rd(o, n).sourceLayout,
        l = {
            duration: i.get("animationDurationUpdate"),
            easing: i.get("animationEasingUpdate")
        };
    Fr(t, {
        x: s.x + 1,
        y: s.y + 1
    }, i, {
        cb: function () {
            r.remove(t), a.setItemGraphicEl(e, null)
        },
        removeOpt: l
    }), t.fadeOut(null, a.hostModel, {
        fadeLabel: !0,
        animation: l
    }), n.children.forEach(function (u) {
        zv(u, a, r, i, l)
    }), zv(n, a, r, i, l)
}

function fs(a, e, t, r, i) {
    var n, o, s, l, u, v, h, c;
    if (a === "radial") {
        u = r.rawX, h = r.rawY, v = i.rawX, c = i.rawY;
        var f = fa(u, h),
            p = fa(u, h + (c - h) * t),
            d = fa(v, c + (h - c) * t),
            g = fa(v, c);
        return {
            x1: f.x || 0,
            y1: f.y || 0,
            x2: g.x || 0,
            y2: g.y || 0,
            cpx1: p.x || 0,
            cpy1: p.y || 0,
            cpx2: d.x || 0,
            cpy2: d.y || 0
        }
    } else u = r.x, h = r.y, v = i.x, c = i.y, (e === "LR" || e === "RL") && (n = u + (v - u) * t, o = h, s = v + (u - v) * t, l = c), (e === "TB" || e === "BT") && (n = u, o = h + (c - h) * t, s = v, l = c + (h - c) * t);
    return {
        x1: u,
        y1: h,
        x2: v,
        y2: c,
        cpx1: n,
        cpy1: o,
        cpx2: s,
        cpy2: l
    }
}
const A1 = b1;
var se = xt();

function ad(a) {
    var e = a.mainData,
        t = a.datas;
    t || (t = {
        main: e
    }, a.datasAttr = {
        main: "data"
    }), a.datas = a.mainData = null, id(e, t, a), T(t, function (r) {
        T(e.TRANSFERABLE_METHODS, function (i) {
            r.wrapMethod(i, K(T1, a))
        })
    }), e.wrapMethod("cloneShallow", K(D1, a)), T(e.CHANGABLE_METHODS, function (r) {
        e.wrapMethod(r, K(C1, a))
    }), ba(t[e.dataType] === e)
}

function T1(a, e) {
    if (M1(this)) {
        var t = W({}, se(this).datas);
        t[this.dataType] = e, id(e, t, a)
    } else pl(e, this.dataType, se(this).mainData, a);
    return e
}

function C1(a, e) {
    return a.struct && a.struct.update(), e
}

function D1(a, e) {
    return T(se(e).datas, function (t, r) {
        t !== e && pl(t.cloneShallow(), r, e, a)
    }), e
}

function I1(a) {
    var e = se(this).mainData;
    return a == null || e == null ? e : se(e).datas[a]
}

function L1() {
    var a = se(this).mainData;
    return a == null ? [{
        data: a
    }] : G(wt(se(a).datas), function (e) {
        return {
            type: e,
            data: se(a).datas[e]
        }
    })
}

function M1(a) {
    return se(a).mainData === a
}

function id(a, e, t) {
    se(a).datas = {}, T(e, function (r, i) {
        pl(r, i, a, t)
    })
}

function pl(a, e, t, r) {
    se(t).datas[e] = a, se(a).mainData = t, a.dataType = e, r.struct && (a[r.structAttr] = r.struct, r.struct[r.datasAttr[e]] = a), a.getLinkedData = I1, a.getLinkedDataAll = L1
}
var P1 = function () {
        function a(e, t) {
            this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t
        }
        return a.prototype.isRemoved = function () {
            return this.dataIndex < 0
        }, a.prototype.eachNode = function (e, t, r) {
            rt(e) && (r = t, t = e, e = null), e = e || {}, q(e) && (e = {
                order: e
            });
            var i = e.order || "preorder",
                n = this[e.attr || "children"],
                o;
            i === "preorder" && (o = t.call(r, this));
            for (var s = 0; !o && s < n.length; s++) n[s].eachNode(e, t, r);
            i === "postorder" && t.call(r, this)
        }, a.prototype.updateDepthAndHeight = function (e) {
            var t = 0;
            this.depth = e;
            for (var r = 0; r < this.children.length; r++) {
                var i = this.children[r];
                i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height)
            }
            this.height = t + 1
        }, a.prototype.getNodeById = function (e) {
            if (this.getId() === e) return this;
            for (var t = 0, r = this.children, i = r.length; t < i; t++) {
                var n = r[t].getNodeById(e);
                if (n) return n
            }
        }, a.prototype.contains = function (e) {
            if (e === this) return !0;
            for (var t = 0, r = this.children, i = r.length; t < i; t++) {
                var n = r[t].contains(e);
                if (n) return n
            }
        }, a.prototype.getAncestors = function (e) {
            for (var t = [], r = e ? this : this.parentNode; r;) t.push(r), r = r.parentNode;
            return t.reverse(), t
        }, a.prototype.getAncestorsIndices = function () {
            for (var e = [], t = this; t;) e.push(t.dataIndex), t = t.parentNode;
            return e.reverse(), e
        }, a.prototype.getDescendantIndices = function () {
            var e = [];
            return this.eachNode(function (t) {
                e.push(t.dataIndex)
            }), e
        }, a.prototype.getValue = function (e) {
            var t = this.hostTree.data;
            return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex)
        }, a.prototype.setLayout = function (e, t) {
            this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t)
        }, a.prototype.getLayout = function () {
            return this.hostTree.data.getItemLayout(this.dataIndex)
        }, a.prototype.getModel = function (e) {
            if (!(this.dataIndex < 0)) {
                var t = this.hostTree,
                    r = t.data.getItemModel(this.dataIndex);
                return r.getModel(e)
            }
        }, a.prototype.getLevelModel = function () {
            return (this.hostTree.levelModels || [])[this.depth]
        }, a.prototype.setVisual = function (e, t) {
            this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t)
        }, a.prototype.getVisual = function (e) {
            return this.hostTree.data.getItemVisual(this.dataIndex, e)
        }, a.prototype.getRawIndex = function () {
            return this.hostTree.data.getRawIndex(this.dataIndex)
        }, a.prototype.getId = function () {
            return this.hostTree.data.getId(this.dataIndex)
        }, a.prototype.getChildIndex = function () {
            if (this.parentNode) {
                for (var e = this.parentNode.children, t = 0; t < e.length; ++t)
                    if (e[t] === this) return t;
                return -1
            }
            return -1
        }, a.prototype.isAncestorOf = function (e) {
            for (var t = e.parentNode; t;) {
                if (t === this) return !0;
                t = t.parentNode
            }
            return !1
        }, a.prototype.isDescendantOf = function (e) {
            return e !== this && e.isAncestorOf(this)
        }, a
    }(),
    dl = function () {
        function a(e) {
            this.type = "tree", this._nodes = [], this.hostModel = e
        }
        return a.prototype.eachNode = function (e, t, r) {
            this.root.eachNode(e, t, r)
        }, a.prototype.getNodeByDataIndex = function (e) {
            var t = this.data.getRawIndex(e);
            return this._nodes[t]
        }, a.prototype.getNodeById = function (e) {
            return this.root.getNodeById(e)
        }, a.prototype.update = function () {
            for (var e = this.data, t = this._nodes, r = 0, i = t.length; r < i; r++) t[r].dataIndex = -1;
            for (var r = 0, i = e.count(); r < i; r++) t[e.getRawIndex(r)].dataIndex = r
        }, a.prototype.clearLayouts = function () {
            this.data.clearItemLayouts()
        }, a.createTree = function (e, t, r) {
            var i = new a(t),
                n = [],
                o = 1;
            s(e);

            function s(v, h) {
                var c = v.value;
                o = Math.max(o, B(c) ? c.length : 1), n.push(v);
                var f = new P1(Se(v.name, ""), i);
                h ? R1(f, h) : i.root = f, i._nodes.push(f);
                var p = v.children;
                if (p)
                    for (var d = 0; d < p.length; d++) s(p[d], f)
            }
            i.root.updateDepthAndHeight(0);
            var l = qs(n, {
                    coordDimensions: ["value"],
                    dimensionsCount: o
                }).dimensions,
                u = new Qt(l, t);
            return u.initData(n), r && r(u), ad({
                mainData: u,
                struct: i,
                structAttr: "tree"
            }), i.update(), i
        }, a
    }();

function R1(a, e) {
    var t = e.children;
    a.parentNode !== e && (t.push(a), a.parentNode = e)
}

function Ma(a, e, t) {
    if (a && ft(e, a.type) >= 0) {
        var r = t.getData().tree.root,
            i = a.targetNode;
        if (q(i) && (i = r.getNodeById(i)), i && r.contains(i)) return {
            node: i
        };
        var n = a.targetNodeId;
        if (n != null && (i = r.getNodeById(n))) return {
            node: i
        }
    }
}

function nd(a) {
    for (var e = []; a;) a = a.parentNode, a && e.push(a);
    return e.reverse()
}

function gl(a, e) {
    var t = nd(a);
    return ft(t, e) >= 0
}

function xn(a, e) {
    for (var t = []; a;) {
        var r = a.dataIndex;
        t.push({
            name: a.name,
            dataIndex: r,
            value: e.getRawValue(r)
        }), a = a.parentNode
    }
    return t.reverse(), t
}
var E1 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t
    }
    return e.prototype.getInitialData = function (t) {
        var r = {
                name: t.name,
                children: t.data
            },
            i = t.leaves || {},
            n = new Rt(i, this, this.ecModel),
            o = dl.createTree(r, this, s);

        function s(h) {
            h.wrapMethod("getItemModel", function (c, f) {
                var p = o.getNodeByDataIndex(f);
                return p && p.children.length && p.isExpand || (c.parentModel = n), c
            })
        }
        var l = 0;
        o.eachNode("preorder", function (h) {
            h.depth > l && (l = h.depth)
        });
        var u = t.expandAndCollapse,
            v = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
        return o.root.eachNode("preorder", function (h) {
            var c = h.hostTree.data.getRawDataItem(h.dataIndex);
            h.isExpand = c && c.collapsed != null ? !c.collapsed : h.depth <= v
        }), o.data
    }, e.prototype.getOrient = function () {
        var t = this.get("orient");
        return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t
    }, e.prototype.setZoom = function (t) {
        this.option.zoom = t
    }, e.prototype.setCenter = function (t) {
        this.option.center = t
    }, e.prototype.formatTooltip = function (t, r, i) {
        for (var n = this.getData().tree, o = n.root.children[0], s = n.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== o;) u = s.parentNode.name + "." + u, s = s.parentNode;
        return qt("nameValue", {
            name: u,
            value: l,
            noValue: isNaN(l) || l == null
        })
    }, e.prototype.getDataParams = function (t) {
        var r = a.prototype.getDataParams.apply(this, arguments),
            i = this.getData().tree.getNodeByDataIndex(t);
        return r.treeAncestors = xn(i, this), r.collapsed = !i.isExpand, r
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
        z: 2,
        coordinateSystem: "view",
        left: "12%",
        top: "12%",
        right: "12%",
        bottom: "12%",
        layout: "orthogonal",
        edgeShape: "curve",
        edgeForkPosition: "50%",
        roam: !1,
        nodeScaleRatio: .4,
        center: null,
        zoom: 1,
        orient: "LR",
        symbol: "emptyCircle",
        symbolSize: 7,
        expandAndCollapse: !0,
        initialTreeDepth: 2,
        lineStyle: {
            color: "#ccc",
            width: 1.5,
            curveness: .5
        },
        itemStyle: {
            color: "lightsteelblue",
            borderWidth: 1.5
        },
        label: {
            show: !0
        },
        animationEasing: "linear",
        animationDuration: 700,
        animationDurationUpdate: 500
    }, e
}(Vt);
const k1 = E1;

function V1(a, e, t) {
    for (var r = [a], i = [], n; n = r.pop();)
        if (i.push(n), n.isExpand) {
            var o = n.children;
            if (o.length)
                for (var s = 0; s < o.length; s++) r.push(o[s])
        } for (; n = i.pop();) e(n, t)
}

function ea(a, e) {
    for (var t = [a], r; r = t.pop();)
        if (e(r), r.isExpand) {
            var i = r.children;
            if (i.length)
                for (var n = i.length - 1; n >= 0; n--) t.push(i[n])
        }
}

function O1(a, e) {
    a.eachSeriesByType("tree", function (t) {
        z1(t, e)
    })
}

function z1(a, e) {
    var t = p1(a, e);
    a.layoutInfo = t;
    var r = a.get("layout"),
        i = 0,
        n = 0,
        o = null;
    r === "radial" ? (i = 2 * Math.PI, n = Math.min(t.height, t.width) / 2, o = kv(function (m, S) {
        return (m.parentNode === S.parentNode ? 1 : 2) / m.depth
    })) : (i = t.width, n = t.height, o = kv());
    var s = a.getData().tree.root,
        l = s.children[0];
    if (l) {
        h1(s), V1(l, c1, o), s.hierNode.modifier = -l.hierNode.prelim, ea(l, f1);
        var u = l,
            v = l,
            h = l;
        ea(l, function (m) {
            var S = m.getLayout().x;
            S < u.getLayout().x && (u = m), S > v.getLayout().x && (v = m), m.depth > h.depth && (h = m)
        });
        var c = u === v ? 1 : o(u, v) / 2,
            f = c - u.getLayout().x,
            p = 0,
            d = 0,
            g = 0,
            y = 0;
        if (r === "radial") p = i / (v.getLayout().x + c + f), d = n / (h.depth - 1 || 1), ea(l, function (m) {
            g = (m.getLayout().x + f) * p, y = (m.depth - 1) * d;
            var S = fa(g, y);
            m.setLayout({
                x: S.x,
                y: S.y,
                rawX: g,
                rawY: y
            }, !0)
        });
        else {
            var x = a.getOrient();
            x === "RL" || x === "LR" ? (d = n / (v.getLayout().x + c + f), p = i / (h.depth - 1 || 1), ea(l, function (m) {
                y = (m.getLayout().x + f) * d, g = x === "LR" ? (m.depth - 1) * p : i - (m.depth - 1) * p, m.setLayout({
                    x: g,
                    y
                }, !0)
            })) : (x === "TB" || x === "BT") && (p = i / (v.getLayout().x + c + f), d = n / (h.depth - 1 || 1), ea(l, function (m) {
                g = (m.getLayout().x + f) * p, y = x === "TB" ? (m.depth - 1) * d : n - (m.depth - 1) * d, m.setLayout({
                    x: g,
                    y
                }, !0)
            }))
        }
    }
}

function N1(a) {
    a.eachSeriesByType("tree", function (e) {
        var t = e.getData(),
            r = t.tree;
        r.eachNode(function (i) {
            var n = i.getModel(),
                o = n.getModel("itemStyle").getItemStyle(),
                s = t.ensureUniqueItemVisual(i.dataIndex, "style");
            W(s, o)
        })
    })
}

function G1(a) {
    a.registerAction({
        type: "treeExpandAndCollapse",
        event: "treeExpandAndCollapse",
        update: "update"
    }, function (e, t) {
        t.eachComponent({
            mainType: "series",
            subType: "tree",
            query: e
        }, function (r) {
            var i = e.dataIndex,
                n = r.getData().tree,
                o = n.getNodeByDataIndex(i);
            o.isExpand = !o.isExpand
        })
    }), a.registerAction({
        type: "treeRoam",
        event: "treeRoam",
        update: "none"
    }, function (e, t, r) {
        t.eachComponent({
            mainType: "series",
            subType: "tree",
            query: e
        }, function (i) {
            var n = i.coordinateSystem,
                o = fl(n, e, void 0, r);
            i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
        })
    })
}

function B1(a) {
    a.registerChartView(A1), a.registerSeriesModel(k1), a.registerLayout(O1), a.registerVisual(N1), G1(a)
}
var Gv = ["treemapZoomToNode", "treemapRender", "treemapMove"];

function H1(a) {
    for (var e = 0; e < Gv.length; e++) a.registerAction({
        type: Gv[e],
        update: "updateView"
    }, pe);
    a.registerAction({
        type: "treemapRootToNode",
        update: "updateView"
    }, function (t, r) {
        r.eachComponent({
            mainType: "series",
            subType: "treemap",
            query: t
        }, i);

        function i(n, o) {
            var s = ["treemapZoomToNode", "treemapRootToNode"],
                l = Ma(t, s, n);
            if (l) {
                var u = n.getViewRoot();
                u && (t.direction = gl(u, l.node) ? "rollUp" : "drillDown"), n.resetViewRoot(l.node)
            }
        }
    })
}

function od(a) {
    var e = a.getData(),
        t = e.tree,
        r = {};
    t.eachNode(function (i) {
        for (var n = i; n && n.depth > 1;) n = n.parentNode;
        var o = jo(a.ecModel, n.name || n.dataIndex + "", r);
        i.setVisual("decal", o)
    })
}
var F1 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.preventUsingHoverLayer = !0, t
    }
    return e.prototype.getInitialData = function (t, r) {
        var i = {
            name: t.name,
            children: t.data
        };
        sd(i);
        var n = t.levels || [],
            o = this.designatedVisualItemStyle = {},
            s = new Rt({
                itemStyle: o
            }, this, r);
        n = t.levels = W1(n, r);
        var l = G(n || [], function (h) {
                return new Rt(h, s, r)
            }, this),
            u = dl.createTree(i, this, v);

        function v(h) {
            h.wrapMethod("getItemModel", function (c, f) {
                var p = u.getNodeByDataIndex(f),
                    d = p ? l[p.depth] : null;
                return c.parentModel = d || s, c
            })
        }
        return u.data
    }, e.prototype.optionUpdated = function () {
        this.resetViewRoot()
    }, e.prototype.formatTooltip = function (t, r, i) {
        var n = this.getData(),
            o = this.getRawValue(t),
            s = n.getName(t);
        return qt("nameValue", {
            name: s,
            value: o
        })
    }, e.prototype.getDataParams = function (t) {
        var r = a.prototype.getDataParams.apply(this, arguments),
            i = this.getData().tree.getNodeByDataIndex(t);
        return r.treeAncestors = xn(i, this), r.treePathInfo = r.treeAncestors, r
    }, e.prototype.setLayoutInfo = function (t) {
        this.layoutInfo = this.layoutInfo || {}, W(this.layoutInfo, t)
    }, e.prototype.mapIdToIndex = function (t) {
        var r = this._idIndexMap;
        r || (r = this._idIndexMap = Q(), this._idIndexMapCount = 0);
        var i = r.get(t);
        return i == null && r.set(t, i = this._idIndexMapCount++), i
    }, e.prototype.getViewRoot = function () {
        return this._viewRoot
    }, e.prototype.resetViewRoot = function (t) {
        t ? this._viewRoot = t : t = this._viewRoot;
        var r = this.getRawData().tree.root;
        (!t || t !== r && !r.contains(t)) && (this._viewRoot = r)
    }, e.prototype.enableAriaDecal = function () {
        od(this)
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
        progressive: 0,
        left: "center",
        top: "middle",
        width: "80%",
        height: "80%",
        sort: !0,
        clipWindow: "origin",
        squareRatio: .5 * (1 + Math.sqrt(5)),
        leafDepth: null,
        drillDownIcon: "â–¶",
        zoomToNodeRatio: .32 * .32,
        roam: !0,
        nodeClick: "zoomToNode",
        animation: !0,
        animationDurationUpdate: 900,
        animationEasing: "quinticInOut",
        breadcrumb: {
            show: !0,
            height: 22,
            left: "center",
            top: "bottom",
            emptyItemWidth: 25,
            itemStyle: {
                color: "rgba(0,0,0,0.7)",
                textStyle: {
                    color: "#fff"
                }
            },
            emphasis: {
                itemStyle: {
                    color: "rgba(0,0,0,0.9)"
                }
            }
        },
        label: {
            show: !0,
            distance: 0,
            padding: 5,
            position: "inside",
            color: "#fff",
            overflow: "truncate"
        },
        upperLabel: {
            show: !1,
            position: [0, "50%"],
            height: 20,
            overflow: "truncate",
            verticalAlign: "middle"
        },
        itemStyle: {
            color: null,
            colorAlpha: null,
            colorSaturation: null,
            borderWidth: 0,
            gapWidth: 0,
            borderColor: "#fff",
            borderColorSaturation: null
        },
        emphasis: {
            upperLabel: {
                show: !0,
                position: [0, "50%"],
                overflow: "truncate",
                verticalAlign: "middle"
            }
        },
        visualDimension: 0,
        visualMin: null,
        visualMax: null,
        color: [],
        colorAlpha: null,
        colorSaturation: null,
        colorMappingBy: "index",
        visibleMin: 10,
        childrenVisibleMin: null,
        levels: []
    }, e
}(Vt);

function sd(a) {
    var e = 0;
    T(a.children, function (r) {
        sd(r);
        var i = r.value;
        B(i) && (i = i[0]), e += i
    });
    var t = a.value;
    B(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), B(a.value) ? a.value[0] = t : a.value = t
}

function W1(a, e) {
    var t = Wt(e.get("color")),
        r = Wt(e.get(["aria", "decal", "decals"]));
    if (t) {
        a = a || [];
        var i, n;
        T(a, function (s) {
            var l = new Rt(s),
                u = l.get("color"),
                v = l.get("decal");
            (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || v && v !== "none") && (n = !0)
        });
        var o = a[0] || (a[0] = {});
        return i || (o.color = t.slice()), !n && r && (o.decal = r.slice()), a
    }
}
const $1 = F1;
var Z1 = 8,
    Bv = 8,
    Un = 5,
    U1 = function () {
        function a(e) {
            this.group = new U, e.add(this.group)
        }
        return a.prototype.render = function (e, t, r, i) {
            var n = e.getModel("breadcrumb"),
                o = this.group;
            if (o.removeAll(), !(!n.get("show") || !r)) {
                var s = n.getModel("itemStyle"),
                    l = n.getModel("emphasis"),
                    u = s.getModel("textStyle"),
                    v = l.getModel(["itemStyle", "textStyle"]),
                    h = {
                        pos: {
                            left: n.get("left"),
                            right: n.get("right"),
                            top: n.get("top"),
                            bottom: n.get("bottom")
                        },
                        box: {
                            width: t.getWidth(),
                            height: t.getHeight()
                        },
                        emptyItemWidth: n.get("emptyItemWidth"),
                        totalWidth: 0,
                        renderList: []
                    };
                this._prepare(r, h, u), this._renderContent(e, h, s, l, u, v, i), hn(o, h.pos, h.box)
            }
        }, a.prototype._prepare = function (e, t, r) {
            for (var i = e; i; i = i.parentNode) {
                var n = Se(i.getModel().get("name"), ""),
                    o = r.getTextRect(n),
                    s = Math.max(o.width + Z1 * 2, t.emptyItemWidth);
                t.totalWidth += s + Bv, t.renderList.push({
                    node: i,
                    text: n,
                    width: s
                })
            }
        }, a.prototype._renderContent = function (e, t, r, i, n, o, s) {
            for (var l = 0, u = t.emptyItemWidth, v = e.get(["breadcrumb", "height"]), h = sm(t.pos, t.box), c = t.totalWidth, f = t.renderList, p = i.getModel("itemStyle").getItemStyle(), d = f.length - 1; d >= 0; d--) {
                var g = f[d],
                    y = g.node,
                    x = g.width,
                    m = g.text;
                c > h.width && (c -= x - u, x = u, m = null);
                var S = new de({
                    shape: {
                        points: Y1(l, 0, x, v, d === f.length - 1, d === 0)
                    },
                    style: at(r.getItemStyle(), {
                        lineJoin: "bevel"
                    }),
                    textContent: new ut({
                        style: mt(n, {
                            text: m
                        })
                    }),
                    textConfig: {
                        position: "inside"
                    },
                    z2: Fa * 1e4,
                    onclick: K(s, y)
                });
                S.disableLabelAnimation = !0, S.getTextContent().ensureState("emphasis").style = mt(o, {
                    text: m
                }), S.ensureState("emphasis").style = p, Tt(S, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(S), X1(S, e, y), l += x + Bv
            }
        }, a.prototype.remove = function () {
            this.group.removeAll()
        }, a
    }();

function Y1(a, e, t, r, i, n) {
    var o = [
        [i ? a : a - Un, e],
        [a + t, e],
        [a + t, e + r],
        [i ? a : a - Un, e + r]
    ];
    return !n && o.splice(2, 0, [a + t + Un, e + r / 2]), !i && o.push([a, e + r / 2]), o
}

function X1(a, e, t) {
    tt(a).eventData = {
        componentType: "series",
        componentSubType: "treemap",
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: "treemap",
        selfType: "breadcrumb",
        nodeData: {
            dataIndex: t && t.dataIndex,
            name: t && t.name
        },
        treePathInfo: t && xn(t, e)
    }
}
const K1 = U1;
var q1 = function () {
    function a() {
        this._storage = [], this._elExistsMap = {}
    }
    return a.prototype.add = function (e, t, r, i, n) {
        return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({
            el: e,
            target: t,
            duration: r,
            delay: i,
            easing: n
        }), !0)
    }, a.prototype.finished = function (e) {
        return this._finishedCallback = e, this
    }, a.prototype.start = function () {
        for (var e = this, t = this._storage.length, r = function () {
                t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback())
            }, i = 0, n = this._storage.length; i < n; i++) {
            var o = this._storage[i];
            o.el.animateTo(o.target, {
                duration: o.duration,
                delay: o.delay,
                easing: o.easing,
                setToFinal: !0,
                done: r,
                aborted: r
            })
        }
        return this
    }, a
}();

function j1() {
    return new q1
}
var ps = U,
    Hv = pt,
    Fv = 3,
    Wv = "label",
    $v = "upperLabel",
    J1 = Fa * 10,
    Q1 = Fa * 2,
    t_ = Fa * 3,
    Je = ep([
        ["fill", "color"],
        ["stroke", "strokeColor"],
        ["lineWidth", "strokeWidth"],
        ["shadowBlur"],
        ["shadowOffsetX"],
        ["shadowOffsetY"],
        ["shadowColor"]
    ]),
    Zv = function (a) {
        var e = Je(a);
        return e.stroke = e.fill = e.lineWidth = null, e
    },
    Ei = xt(),
    e_ = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._state = "ready", t._storage = ra(), t
        }
        return e.prototype.render = function (t, r, i, n) {
            var o = r.findComponents({
                mainType: "series",
                subType: "treemap",
                query: n
            });
            if (!(ft(o, t) < 0)) {
                this.seriesModel = t, this.api = i, this.ecModel = r;
                var s = ["treemapZoomToNode", "treemapRootToNode"],
                    l = Ma(n, s, t),
                    u = n && n.type,
                    v = t.layoutInfo,
                    h = !this._oldTree,
                    c = this._storage,
                    f = u === "treemapRootToNode" && l && c ? {
                        rootNodeGroup: c.nodeGroup[l.node.getRawIndex()],
                        direction: n.direction
                    } : null,
                    p = this._giveContainerGroup(v),
                    d = t.get("animation"),
                    g = this._doRender(p, t, f);
                d && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, g, t, f) : g.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l)
            }
        }, e.prototype._giveContainerGroup = function (t) {
            var r = this._containerGroup;
            return r || (r = this._containerGroup = new ps, this._initEvents(r), this.group.add(r)), r.x = t.x, r.y = t.y, r
        }, e.prototype._doRender = function (t, r, i) {
            var n = r.getData().tree,
                o = this._oldTree,
                s = ra(),
                l = ra(),
                u = this._storage,
                v = [];

            function h(g, y, x, m) {
                return r_(r, l, u, i, s, v, g, y, x, m)
            }
            f(n.root ? [n.root] : [], o && o.root ? [o.root] : [], t, n === o || !o, 0);
            var c = p(u);
            return this._oldTree = n, this._storage = l, {
                lastsForAnimation: s,
                willDeleteEls: c,
                renderFinally: d
            };

            function f(g, y, x, m, S) {
                m ? (y = g, T(g, function (w, A) {
                    !w.isRemoved() && b(A, A)
                })) : new Be(y, g, _, _).add(b).update(b).remove(K(b, null)).execute();

                function _(w) {
                    return w.getId()
                }

                function b(w, A) {
                    var C = w != null ? g[w] : null,
                        D = A != null ? y[A] : null,
                        I = h(C, D, x, S);
                    I && f(C && C.viewChildren || [], D && D.viewChildren || [], I, m, S + 1)
                }
            }

            function p(g) {
                var y = ra();
                return g && T(g, function (x, m) {
                    var S = y[m];
                    T(x, function (_) {
                        _ && (S.push(_), Ei(_).willDelete = !0)
                    })
                }), y
            }

            function d() {
                T(c, function (g) {
                    T(g, function (y) {
                        y.parent && y.parent.remove(y)
                    })
                }), T(v, function (g) {
                    g.invisible = !0, g.dirty()
                })
            }
        }, e.prototype._doAnimation = function (t, r, i, n) {
            var o = i.get("animationDurationUpdate"),
                s = i.get("animationEasing"),
                l = (rt(o) ? 0 : o) || 0,
                u = (rt(s) ? null : s) || "cubicOut",
                v = j1();
            T(r.willDeleteEls, function (h, c) {
                T(h, function (f, p) {
                    if (!f.invisible) {
                        var d = f.parent,
                            g, y = Ei(d);
                        if (n && n.direction === "drillDown") g = d === n.rootNodeGroup ? {
                            shape: {
                                x: 0,
                                y: 0,
                                width: y.nodeWidth,
                                height: y.nodeHeight
                            },
                            style: {
                                opacity: 0
                            }
                        } : {
                            style: {
                                opacity: 0
                            }
                        };
                        else {
                            var x = 0,
                                m = 0;
                            y.willDelete || (x = y.nodeWidth / 2, m = y.nodeHeight / 2), g = c === "nodeGroup" ? {
                                x,
                                y: m,
                                style: {
                                    opacity: 0
                                }
                            } : {
                                shape: {
                                    x,
                                    y: m,
                                    width: 0,
                                    height: 0
                                },
                                style: {
                                    opacity: 0
                                }
                            }
                        }
                        g && v.add(f, g, l, 0, u)
                    }
                })
            }), T(this._storage, function (h, c) {
                T(h, function (f, p) {
                    var d = r.lastsForAnimation[c][p],
                        g = {};
                    d && (f instanceof U ? d.oldX != null && (g.x = f.x, g.y = f.y, f.x = d.oldX, f.y = d.oldY) : (d.oldShape && (g.shape = W({}, f.shape), f.setShape(d.oldShape)), d.fadein ? (f.setStyle("opacity", 0), g.style = {
                        opacity: 1
                    }) : f.style.opacity !== 1 && (g.style = {
                        opacity: 1
                    })), v.add(f, g, l, 0, u))
                })
            }, this), this._state = "animating", v.finished(F(function () {
                this._state = "ready", r.renderFinally()
            }, this)).start()
        }, e.prototype._resetController = function (t) {
            var r = this._controller;
            r || (r = this._controller = new Ka(t.getZr()), r.enable(this.seriesModel.get("roam")), r.on("pan", F(this._onPan, this)), r.on("zoom", F(this._onZoom, this)));
            var i = new gt(0, 0, t.getWidth(), t.getHeight());
            r.setPointerChecker(function (n, o, s) {
                return i.contain(o, s)
            })
        }, e.prototype._clearController = function () {
            var t = this._controller;
            t && (t.dispose(), t = null)
        }, e.prototype._onPan = function (t) {
            if (this._state !== "animating" && (Math.abs(t.dx) > Fv || Math.abs(t.dy) > Fv)) {
                var r = this.seriesModel.getData().tree.root;
                if (!r) return;
                var i = r.getLayout();
                if (!i) return;
                this.api.dispatchAction({
                    type: "treemapMove",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: i.x + t.dx,
                        y: i.y + t.dy,
                        width: i.width,
                        height: i.height
                    }
                })
            }
        }, e.prototype._onZoom = function (t) {
            var r = t.originX,
                i = t.originY;
            if (this._state !== "animating") {
                var n = this.seriesModel.getData().tree.root;
                if (!n) return;
                var o = n.getLayout();
                if (!o) return;
                var s = new gt(o.x, o.y, o.width, o.height),
                    l = this.seriesModel.layoutInfo;
                r -= l.x, i -= l.y;
                var u = yr();
                Ge(u, u, [-r, -i]), qf(u, u, [t.scale, t.scale]), Ge(u, u, [r, i]), s.applyTransform(u), this.api.dispatchAction({
                    type: "treemapRender",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: s.x,
                        y: s.y,
                        width: s.width,
                        height: s.height
                    }
                })
            }
        }, e.prototype._initEvents = function (t) {
            var r = this;
            t.on("click", function (i) {
                if (r._state === "ready") {
                    var n = r.seriesModel.get("nodeClick", !0);
                    if (n) {
                        var o = r.findTarget(i.offsetX, i.offsetY);
                        if (o) {
                            var s = o.node;
                            if (s.getLayout().isLeafRoot) r._rootToNode(o);
                            else if (n === "zoomToNode") r._zoomToNode(o);
                            else if (n === "link") {
                                var l = s.hostTree.data.getItemModel(s.dataIndex),
                                    u = l.get("link", !0),
                                    v = l.get("target", !0) || "blank";
                                u && Ci(u, v)
                            }
                        }
                    }
                }
            }, this)
        }, e.prototype._renderBreadcrumb = function (t, r, i) {
            var n = this;
            i || (i = t.get("leafDepth", !0) != null ? {
                node: t.getViewRoot()
            } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = {
                node: t.getData().tree.root
            })), (this._breadcrumb || (this._breadcrumb = new K1(this.group))).render(t, r, i.node, function (o) {
                n._state !== "animating" && (gl(t.getViewRoot(), o) ? n._rootToNode({
                    node: o
                }) : n._zoomToNode({
                    node: o
                }))
            })
        }, e.prototype.remove = function () {
            this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = ra(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove()
        }, e.prototype.dispose = function () {
            this._clearController()
        }, e.prototype._zoomToNode = function (t) {
            this.api.dispatchAction({
                type: "treemapZoomToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        }, e.prototype._rootToNode = function (t) {
            this.api.dispatchAction({
                type: "treemapRootToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        }, e.prototype.findTarget = function (t, r) {
            var i, n = this.seriesModel.getViewRoot();
            return n.eachNode({
                attr: "viewChildren",
                order: "preorder"
            }, function (o) {
                var s = this._storage.background[o.getRawIndex()];
                if (s) {
                    var l = s.transformCoordToLocal(t, r),
                        u = s.shape;
                    if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) i = {
                        node: o,
                        offsetX: l[0],
                        offsetY: l[1]
                    };
                    else return !1
                }
            }, this), i
        }, e.type = "treemap", e
    }(At);

function ra() {
    return {
        nodeGroup: [],
        background: [],
        content: []
    }
}

function r_(a, e, t, r, i, n, o, s, l, u) {
    if (!o) return;
    var v = o.getLayout(),
        h = a.getData(),
        c = o.getModel();
    if (h.setItemGraphicEl(o.dataIndex, null), !v || !v.isInView) return;
    var f = v.width,
        p = v.height,
        d = v.borderWidth,
        g = v.invisible,
        y = o.getRawIndex(),
        x = s && s.getRawIndex(),
        m = o.viewChildren,
        S = v.upperHeight,
        _ = m && m.length,
        b = c.getModel("itemStyle"),
        w = c.getModel(["emphasis", "itemStyle"]),
        A = c.getModel(["blur", "itemStyle"]),
        C = c.getModel(["select", "itemStyle"]),
        D = b.get("borderRadius") || 0,
        I = X("nodeGroup", ps);
    if (!I) return;
    if (l.add(I), I.x = v.x || 0, I.y = v.y || 0, I.markRedraw(), Ei(I).nodeWidth = f, Ei(I).nodeHeight = p, v.isAboveViewRoot) return I;
    var L = X("background", Hv, u, Q1);
    L && z(I, L, _ && v.upperLabelHeight);
    var M = c.getModel("emphasis"),
        P = M.get("focus"),
        R = M.get("blurScope"),
        k = M.get("disabled"),
        V = P === "ancestor" ? o.getAncestorsIndices() : P === "descendant" ? o.getDescendantIndices() : P;
    if (_) cu(I) && va(I, !1), L && (va(L, !k), h.setItemGraphicEl(o.dataIndex, L), fu(L, V, R));
    else {
        var O = X("content", Hv, u, t_);
        O && $(I, O), L.disableMorphing = !0, L && cu(L) && va(L, !1), va(I, !k), h.setItemGraphicEl(o.dataIndex, I), fu(I, V, R)
    }
    return I;

    function z(it, Y, vt) {
        var lt = tt(Y);
        if (lt.dataIndex = o.dataIndex, lt.seriesIndex = a.seriesIndex, Y.setShape({
                x: 0,
                y: 0,
                width: f,
                height: p,
                r: D
            }), g) Z(Y);
        else {
            Y.invisible = !1;
            var dt = o.getVisual("style"),
                zt = dt.stroke,
                Bt = Zv(b);
            Bt.fill = zt;
            var _t = Je(w);
            _t.fill = w.get("borderColor");
            var $t = Je(A);
            $t.fill = A.get("borderColor");
            var Zt = Je(C);
            if (Zt.fill = C.get("borderColor"), vt) {
                var ue = f - 2 * d;
                et(Y, zt, dt.opacity, {
                    x: d,
                    y: 0,
                    width: ue,
                    height: S
                })
            } else Y.removeTextContent();
            Y.setStyle(Bt), Y.ensureState("emphasis").style = _t, Y.ensureState("blur").style = $t, Y.ensureState("select").style = Zt, Ur(Y)
        }
        it.add(Y)
    }

    function $(it, Y) {
        var vt = tt(Y);
        vt.dataIndex = o.dataIndex, vt.seriesIndex = a.seriesIndex;
        var lt = Math.max(f - 2 * d, 0),
            dt = Math.max(p - 2 * d, 0);
        if (Y.culling = !0, Y.setShape({
                x: d,
                y: d,
                width: lt,
                height: dt,
                r: D
            }), g) Z(Y);
        else {
            Y.invisible = !1;
            var zt = o.getVisual("style"),
                Bt = zt.fill,
                _t = Zv(b);
            _t.fill = Bt, _t.decal = zt.decal;
            var $t = Je(w),
                Zt = Je(A),
                ue = Je(C);
            et(Y, Bt, zt.opacity, null), Y.setStyle(_t), Y.ensureState("emphasis").style = $t, Y.ensureState("blur").style = Zt, Y.ensureState("select").style = ue, Ur(Y)
        }
        it.add(Y)
    }

    function Z(it) {
        !it.invisible && n.push(it)
    }

    function et(it, Y, vt, lt) {
        var dt = c.getModel(lt ? $v : Wv),
            zt = Se(c.get("name"), null),
            Bt = dt.getShallow("show");
        Xt(it, Gt(c, lt ? $v : Wv), {
            defaultText: Bt ? zt : null,
            inheritColor: Y,
            defaultOpacity: vt,
            labelFetcher: a,
            labelDataIndex: o.dataIndex
        });
        var _t = it.getTextContent();
        if (_t) {
            var $t = _t.style,
                Zt = lm($t.padding || 0);
            lt && (it.setTextConfig({
                layoutRect: lt
            }), _t.disableLabelLayout = !0), _t.beforeUpdate = function () {
                var Ze = Math.max((lt ? lt.width : it.shape.width) - Zt[1] - Zt[3], 0),
                    Ue = Math.max((lt ? lt.height : it.shape.height) - Zt[0] - Zt[2], 0);
                ($t.width !== Ze || $t.height !== Ue) && _t.setStyle({
                    width: Ze,
                    height: Ue
                })
            }, $t.truncateMinChar = 2, $t.lineOverflow = "truncate", J($t, lt, v);
            var ue = _t.getState("emphasis");
            J(ue ? ue.style : null, lt, v)
        }
    }

    function J(it, Y, vt) {
        var lt = it ? it.text : null;
        if (!Y && vt.isLeafRoot && lt != null) {
            var dt = a.get("drillDownIcon", !0);
            it.text = dt ? dt + " " + lt : lt
        }
    }

    function X(it, Y, vt, lt) {
        var dt = x != null && t[it][x],
            zt = i[it];
        return dt ? (t[it][x] = null, nt(zt, dt)) : g || (dt = new Y, dt instanceof hr && (dt.z2 = a_(vt, lt)), st(zt, dt)), e[it][y] = dt
    }

    function nt(it, Y) {
        var vt = it[y] = {};
        Y instanceof ps ? (vt.oldX = Y.x, vt.oldY = Y.y) : vt.oldShape = W({}, Y.shape)
    }

    function st(it, Y) {
        var vt = it[y] = {},
            lt = o.parentNode,
            dt = Y instanceof U;
        if (lt && (!r || r.direction === "drillDown")) {
            var zt = 0,
                Bt = 0,
                _t = i.background[lt.getRawIndex()];
            !r && _t && _t.oldShape && (zt = _t.oldShape.width, Bt = _t.oldShape.height), dt ? (vt.oldX = 0, vt.oldY = Bt) : vt.oldShape = {
                x: zt,
                y: Bt,
                width: 0,
                height: 0
            }
        }
        vt.fadein = !dt
    }
}

function a_(a, e) {
    return a * J1 + e
}
const i_ = e_;
var Pa = T,
    n_ = St,
    ki = -1,
    yl = function () {
        function a(e) {
            var t = e.mappingMethod,
                r = e.type,
                i = this.option = ot(e);
            this.type = r, this.mappingMethod = t, this._normalizeData = l_[t];
            var n = a.visualHandlers[r];
            this.applyVisual = n.applyVisual, this.getColorMapper = n.getColorMapper, this._normalizedToVisual = n._normalizedToVisual[t], t === "piecewise" ? (Yn(i), o_(i)) : t === "category" ? i.categories ? s_(i) : Yn(i, !0) : (ba(t !== "linear" || i.dataExtent), Yn(i))
        }
        return a.prototype.mapValueToVisual = function (e) {
            var t = this._normalizeData(e);
            return this._normalizedToVisual(t, e)
        }, a.prototype.getNormalizer = function () {
            return F(this._normalizeData, this)
        }, a.listVisualTypes = function () {
            return wt(a.visualHandlers)
        }, a.isValidType = function (e) {
            return a.visualHandlers.hasOwnProperty(e)
        }, a.eachVisual = function (e, t, r) {
            St(e) ? T(e, t, r) : t.call(r, e)
        }, a.mapVisual = function (e, t, r) {
            var i, n = B(e) ? [] : St(e) ? {} : (i = !0, null);
            return a.eachVisual(e, function (o, s) {
                var l = t.call(r, o, s);
                i ? n = l : n[s] = l
            }), n
        }, a.retrieveVisuals = function (e) {
            var t = {},
                r;
            return e && Pa(a.visualHandlers, function (i, n) {
                e.hasOwnProperty(n) && (t[n] = e[n], r = !0)
            }), r ? t : null
        }, a.prepareVisualTypes = function (e) {
            if (B(e)) e = e.slice();
            else if (n_(e)) {
                var t = [];
                Pa(e, function (r, i) {
                    t.push(i)
                }), e = t
            } else return [];
            return e.sort(function (r, i) {
                return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1
            }), e
        }, a.dependsOn = function (e, t) {
            return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t
        }, a.findPieceIndex = function (e, t, r) {
            for (var i, n = 1 / 0, o = 0, s = t.length; o < s; o++) {
                var l = t[o].value;
                if (l != null) {
                    if (l === e || q(l) && l === e + "") return o;
                    r && c(l, o)
                }
            }
            for (var o = 0, s = t.length; o < s; o++) {
                var u = t[o],
                    v = u.interval,
                    h = u.close;
                if (v) {
                    if (v[0] === -1 / 0) {
                        if (ni(h[1], e, v[1])) return o
                    } else if (v[1] === 1 / 0) {
                        if (ni(h[0], v[0], e)) return o
                    } else if (ni(h[0], v[0], e) && ni(h[1], e, v[1])) return o;
                    r && c(v[0], o), r && c(v[1], o)
                }
            }
            if (r) return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;

            function c(f, p) {
                var d = Math.abs(f - e);
                d < n && (n = d, i = p)
            }
        }, a.visualHandlers = {
            color: {
                applyVisual: aa("color"),
                getColorMapper: function () {
                    var e = this.option;
                    return F(e.mappingMethod === "category" ? function (t, r) {
                        return !r && (t = this._normalizeData(t)), pa.call(this, t)
                    } : function (t, r, i) {
                        var n = !!i;
                        return !r && (t = this._normalizeData(t)), i = An(t, e.parsedVisual, i), n ? i : xi(i, "rgba")
                    }, this)
                },
                _normalizedToVisual: {
                    linear: function (e) {
                        return xi(An(e, this.option.parsedVisual), "rgba")
                    },
                    category: pa,
                    piecewise: function (e, t) {
                        var r = gs.call(this, t);
                        return r == null && (r = xi(An(e, this.option.parsedVisual), "rgba")), r
                    },
                    fixed: Qe
                }
            },
            colorHue: ii(function (e, t) {
                return ya(e, t)
            }),
            colorSaturation: ii(function (e, t) {
                return ya(e, null, t)
            }),
            colorLightness: ii(function (e, t) {
                return ya(e, null, null, t)
            }),
            colorAlpha: ii(function (e, t) {
                return Di(e, t)
            }),
            decal: {
                applyVisual: aa("decal"),
                _normalizedToVisual: {
                    linear: null,
                    category: pa,
                    piecewise: null,
                    fixed: null
                }
            },
            opacity: {
                applyVisual: aa("opacity"),
                _normalizedToVisual: ds([0, 1])
            },
            liftZ: {
                applyVisual: aa("liftZ"),
                _normalizedToVisual: {
                    linear: Qe,
                    category: Qe,
                    piecewise: Qe,
                    fixed: Qe
                }
            },
            symbol: {
                applyVisual: function (e, t, r) {
                    var i = this.mapValueToVisual(e);
                    r("symbol", i)
                },
                _normalizedToVisual: {
                    linear: Uv,
                    category: pa,
                    piecewise: function (e, t) {
                        var r = gs.call(this, t);
                        return r == null && (r = Uv.call(this, e)), r
                    },
                    fixed: Qe
                }
            },
            symbolSize: {
                applyVisual: aa("symbolSize"),
                _normalizedToVisual: ds([0, 1])
            }
        }, a
    }();

function o_(a) {
    var e = a.pieceList;
    a.hasSpecialVisual = !1, T(e, function (t, r) {
        t.originIndex = r, t.visual != null && (a.hasSpecialVisual = !0)
    })
}

function s_(a) {
    var e = a.categories,
        t = a.categoryMap = {},
        r = a.visual;
    if (Pa(e, function (o, s) {
            t[o] = s
        }), !B(r)) {
        var i = [];
        St(r) ? Pa(r, function (o, s) {
            var l = t[s];
            i[l ? ? ki] = o
        }) : i[ki] = r, r = ld(a, i)
    }
    for (var n = e.length - 1; n >= 0; n--) r[n] == null && (delete t[e[n]], e.pop())
}

function Yn(a, e) {
    var t = a.visual,
        r = [];
    St(t) ? Pa(t, function (n) {
        r.push(n)
    }) : t != null && r.push(t);
    var i = {
        color: 1,
        symbol: 1
    };
    !e && r.length === 1 && !i.hasOwnProperty(a.type) && (r[1] = r[0]), ld(a, r)
}

function ii(a) {
    return {
        applyVisual: function (e, t, r) {
            var i = this.mapValueToVisual(e);
            r("color", a(t("color"), i))
        },
        _normalizedToVisual: ds([0, 1])
    }
}

function Uv(a) {
    var e = this.option.visual;
    return e[Math.round(ht(a, [0, 1], [0, e.length - 1], !0))] || {}
}

function aa(a) {
    return function (e, t, r) {
        r(a, this.mapValueToVisual(e))
    }
}

function pa(a) {
    var e = this.option.visual;
    return e[this.option.loop && a !== ki ? a % e.length : a]
}

function Qe() {
    return this.option.visual[0]
}

function ds(a) {
    return {
        linear: function (e) {
            return ht(e, a, this.option.visual, !0)
        },
        category: pa,
        piecewise: function (e, t) {
            var r = gs.call(this, t);
            return r == null && (r = ht(e, a, this.option.visual, !0)), r
        },
        fixed: Qe
    }
}

function gs(a) {
    var e = this.option,
        t = e.pieceList;
    if (e.hasSpecialVisual) {
        var r = yl.findPieceIndex(a, t),
            i = t[r];
        if (i && i.visual) return i.visual[this.type]
    }
}

function ld(a, e) {
    return a.visual = e, a.type === "color" && (a.parsedVisual = G(e, function (t) {
        var r = rp(t);
        return r || [0, 0, 0, 1]
    })), e
}
var l_ = {
    linear: function (a) {
        return ht(a, this.option.dataExtent, [0, 1], !0)
    },
    piecewise: function (a) {
        var e = this.option.pieceList,
            t = yl.findPieceIndex(a, e, !0);
        if (t != null) return ht(t, [0, e.length - 1], [0, 1], !0)
    },
    category: function (a) {
        var e = this.option.categories ? this.option.categoryMap[a] : a;
        return e ? ? ki
    },
    fixed: pe
};

function ni(a, e, t) {
    return a ? e <= t : e < t
}
const Ot = yl;
var u_ = "itemStyle",
    ud = xt();
const v_ = {
    seriesType: "treemap",
    reset: function (a) {
        var e = a.getData().tree,
            t = e.root;
        t.isRemoved() || vd(t, {}, a.getViewRoot().getAncestors(), a)
    }
};

function vd(a, e, t, r) {
    var i = a.getModel(),
        n = a.getLayout(),
        o = a.hostTree.data;
    if (!(!n || n.invisible || !n.isInView)) {
        var s = i.getModel(u_),
            l = h_(s, e, r),
            u = o.ensureUniqueItemVisual(a.dataIndex, "style"),
            v = s.get("borderColor"),
            h = s.get("borderColorSaturation"),
            c;
        h != null && (c = Yv(l), v = c_(h, c)), u.stroke = v;
        var f = a.viewChildren;
        if (!f || !f.length) c = Yv(l), u.fill = c;
        else {
            var p = f_(a, i, n, s, l, f);
            T(f, function (d, g) {
                if (d.depth >= t.length || d === t[d.depth]) {
                    var y = p_(i, l, d, g, p, r);
                    vd(d, y, t, r)
                }
            })
        }
    }
}

function h_(a, e, t) {
    var r = W({}, e),
        i = t.designatedVisualItemStyle;
    return T(["color", "colorAlpha", "colorSaturation"], function (n) {
        i[n] = e[n];
        var o = a.get(n);
        i[n] = null, o != null && (r[n] = o)
    }), r
}

function Yv(a) {
    var e = Xn(a, "color");
    if (e) {
        var t = Xn(a, "colorAlpha"),
            r = Xn(a, "colorSaturation");
        return r && (e = ya(e, null, null, r)), t && (e = Di(e, t)), e
    }
}

function c_(a, e) {
    return e != null ? ya(e, null, null, a) : null
}

function Xn(a, e) {
    var t = a[e];
    if (t != null && t !== "none") return t
}

function f_(a, e, t, r, i, n) {
    if (!(!n || !n.length)) {
        var o = Kn(e, "color") || i.color != null && i.color !== "none" && (Kn(e, "colorAlpha") || Kn(e, "colorSaturation"));
        if (o) {
            var s = e.get("visualMin"),
                l = e.get("visualMax"),
                u = t.dataExtent.slice();
            s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
            var v = e.get("colorMappingBy"),
                h = {
                    type: o.name,
                    dataExtent: u,
                    visual: o.range
                };
            h.type === "color" && (v === "index" || v === "id") ? (h.mappingMethod = "category", h.loop = !0) : h.mappingMethod = "linear";
            var c = new Ot(h);
            return ud(c).drColorMappingBy = v, c
        }
    }
}

function Kn(a, e) {
    var t = a.get(e);
    return B(t) && t.length ? {
        name: e,
        range: t
    } : null
}

function p_(a, e, t, r, i, n) {
    var o = W({}, e);
    if (i) {
        var s = i.type,
            l = s === "color" && ud(i).drColorMappingBy,
            u = l === "index" ? r : l === "id" ? n.mapIdToIndex(t.getId()) : t.getValue(a.get("visualDimension"));
        o[s] = i.mapValueToVisual(u)
    }
    return o
}
var Ra = Math.max,
    Vi = Math.min,
    Xv = Ut,
    ml = T,
    hd = ["itemStyle", "borderWidth"],
    d_ = ["itemStyle", "gapWidth"],
    g_ = ["upperLabel", "show"],
    y_ = ["upperLabel", "height"];
const m_ = {
    seriesType: "treemap",
    reset: function (a, e, t, r) {
        var i = t.getWidth(),
            n = t.getHeight(),
            o = a.option,
            s = kt(a.getBoxLayoutParams(), {
                width: t.getWidth(),
                height: t.getHeight()
            }),
            l = o.size || [],
            u = H(Xv(s.width, l[0]), i),
            v = H(Xv(s.height, l[1]), n),
            h = r && r.type,
            c = ["treemapZoomToNode", "treemapRootToNode"],
            f = Ma(r, c, a),
            p = h === "treemapRender" || h === "treemapMove" ? r.rootRect : null,
            d = a.getViewRoot(),
            g = nd(d);
        if (h !== "treemapMove") {
            var y = h === "treemapZoomToNode" ? A_(a, f, d, u, v) : p ? [p.width, p.height] : [u, v],
                x = o.sort;
            x && x !== "asc" && x !== "desc" && (x = "desc");
            var m = {
                squareRatio: o.squareRatio,
                sort: x,
                leafDepth: o.leafDepth
            };
            d.hostTree.clearLayouts();
            var S = {
                x: 0,
                y: 0,
                width: y[0],
                height: y[1],
                area: y[0] * y[1]
            };
            d.setLayout(S), cd(d, m, !1, 0), S = d.getLayout(), ml(g, function (b, w) {
                var A = (g[w + 1] || d).getValue();
                b.setLayout(W({
                    dataExtent: [A, A],
                    borderWidth: 0,
                    upperHeight: 0
                }, S))
            })
        }
        var _ = a.getData().tree.root;
        _.setLayout(T_(s, p, f), !0), a.setLayoutInfo(s), fd(_, new gt(-s.x, -s.y, i, n), g, d, 0)
    }
};

function cd(a, e, t, r) {
    var i, n;
    if (!a.isRemoved()) {
        var o = a.getLayout();
        i = o.width, n = o.height;
        var s = a.getModel(),
            l = s.get(hd),
            u = s.get(d_) / 2,
            v = pd(s),
            h = Math.max(l, v),
            c = l - u,
            f = h - u;
        a.setLayout({
            borderWidth: l,
            upperHeight: h,
            upperLabelHeight: v
        }, !0), i = Ra(i - 2 * c, 0), n = Ra(n - c - f, 0);
        var p = i * n,
            d = x_(a, s, p, e, t, r);
        if (d.length) {
            var g = {
                    x: c,
                    y: f,
                    width: i,
                    height: n
                },
                y = Vi(i, n),
                x = 1 / 0,
                m = [];
            m.area = 0;
            for (var S = 0, _ = d.length; S < _;) {
                var b = d[S];
                m.push(b), m.area += b.getLayout().area;
                var w = w_(m, y, e.squareRatio);
                w <= x ? (S++, x = w) : (m.area -= m.pop().getLayout().area, Kv(m, y, g, u, !1), y = Vi(g.width, g.height), m.length = m.area = 0, x = 1 / 0)
            }
            if (m.length && Kv(m, y, g, u, !0), !t) {
                var A = s.get("childrenVisibleMin");
                A != null && p < A && (t = !0)
            }
            for (var S = 0, _ = d.length; S < _; S++) cd(d[S], e, t, r + 1)
        }
    }
}

function x_(a, e, t, r, i, n) {
    var o = a.children || [],
        s = r.sort;
    s !== "asc" && s !== "desc" && (s = null);
    var l = r.leafDepth != null && r.leafDepth <= n;
    if (i && !l) return a.viewChildren = [];
    o = Dt(o, function (f) {
        return !f.isRemoved()
    }), __(o, s);
    var u = b_(e, o, s);
    if (u.sum === 0) return a.viewChildren = [];
    if (u.sum = S_(e, t, u.sum, s, o), u.sum === 0) return a.viewChildren = [];
    for (var v = 0, h = o.length; v < h; v++) {
        var c = o[v].getValue() / u.sum * t;
        o[v].setLayout({
            area: c
        })
    }
    return l && (o.length && a.setLayout({
        isLeafRoot: !0
    }, !0), o.length = 0), a.viewChildren = o, a.setLayout({
        dataExtent: u.dataExtent
    }, !0), o
}

function S_(a, e, t, r, i) {
    if (!r) return t;
    for (var n = a.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
        var u = i[r === "asc" ? o - l - 1 : l].getValue();
        u / t * e < n && (s = l, t -= u)
    }
    return r === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), t
}

function __(a, e) {
    return e && a.sort(function (t, r) {
        var i = e === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue();
        return i === 0 ? e === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : i
    }), a
}

function b_(a, e, t) {
    for (var r = 0, i = 0, n = e.length; i < n; i++) r += e[i].getValue();
    var o = a.get("visualDimension"),
        s;
    return !e || !e.length ? s = [NaN, NaN] : o === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], ml(e, function (l) {
        var u = l.getValue(o);
        u < s[0] && (s[0] = u), u > s[1] && (s[1] = u)
    })), {
        sum: r,
        dataExtent: s
    }
}

function w_(a, e, t) {
    for (var r = 0, i = 1 / 0, n = 0, o = void 0, s = a.length; n < s; n++) o = a[n].getLayout().area, o && (o < i && (i = o), o > r && (r = o));
    var l = a.area * a.area,
        u = e * e * t;
    return l ? Ra(u * r / l, l / (u * i)) : 1 / 0
}

function Kv(a, e, t, r, i) {
    var n = e === t.width ? 0 : 1,
        o = 1 - n,
        s = ["x", "y"],
        l = ["width", "height"],
        u = t[s[n]],
        v = e ? a.area / e : 0;
    (i || v > t[l[o]]) && (v = t[l[o]]);
    for (var h = 0, c = a.length; h < c; h++) {
        var f = a[h],
            p = {},
            d = v ? f.getLayout().area / v : 0,
            g = p[l[o]] = Ra(v - 2 * r, 0),
            y = t[s[n]] + t[l[n]] - u,
            x = h === c - 1 || y < d ? y : d,
            m = p[l[n]] = Ra(x - 2 * r, 0);
        p[s[o]] = t[s[o]] + Vi(r, g / 2), p[s[n]] = u + Vi(r, m / 2), u += x, f.setLayout(p, !0)
    }
    t[s[o]] += v, t[l[o]] -= v
}

function A_(a, e, t, r, i) {
    var n = (e || {}).node,
        o = [r, i];
    if (!n || n === t) return o;
    for (var s, l = r * i, u = l * a.option.zoomToNodeRatio; s = n.parentNode;) {
        for (var v = 0, h = s.children, c = 0, f = h.length; c < f; c++) v += h[c].getValue();
        var p = n.getValue();
        if (p === 0) return o;
        u *= v / p;
        var d = s.getModel(),
            g = d.get(hd),
            y = Math.max(g, pd(d));
        u += 4 * g * g + (3 * g + y) * Math.pow(u, .5), u > pu && (u = pu), n = s
    }
    u < l && (u = l);
    var x = Math.pow(u / l, .5);
    return [r * x, i * x]
}

function T_(a, e, t) {
    if (e) return {
        x: e.x,
        y: e.y
    };
    var r = {
        x: 0,
        y: 0
    };
    if (!t) return r;
    var i = t.node,
        n = i.getLayout();
    if (!n) return r;
    for (var o = [n.width / 2, n.height / 2], s = i; s;) {
        var l = s.getLayout();
        o[0] += l.x, o[1] += l.y, s = s.parentNode
    }
    return {
        x: a.width / 2 - o[0],
        y: a.height / 2 - o[1]
    }
}

function fd(a, e, t, r, i) {
    var n = a.getLayout(),
        o = t[i],
        s = o && o === a;
    if (!(o && !s || i === t.length && a !== r)) {
        a.setLayout({
            isInView: !0,
            invisible: !s && !e.intersect(n),
            isAboveViewRoot: s
        }, !0);
        var l = new gt(e.x - n.x, e.y - n.y, e.width, e.height);
        ml(a.viewChildren || [], function (u) {
            fd(u, l, t, r, i + 1)
        })
    }
}

function pd(a) {
    return a.get(g_) ? a.get(y_) : 0
}

function C_(a) {
    a.registerSeriesModel($1), a.registerChartView(i_), a.registerVisual(v_), a.registerLayout(m_), H1(a)
}

function D_(a) {
    var e = a.findComponents({
        mainType: "legend"
    });
    !e || !e.length || a.eachSeriesByType("graph", function (t) {
        var r = t.getCategoriesData(),
            i = t.getGraph(),
            n = i.data,
            o = r.mapArray(r.getName);
        n.filterSelf(function (s) {
            var l = n.getItemModel(s),
                u = l.getShallow("category");
            if (u != null) {
                te(u) && (u = o[u]);
                for (var v = 0; v < e.length; v++)
                    if (!e[v].isSelected(u)) return !1
            }
            return !0
        })
    })
}

function I_(a) {
    var e = {};
    a.eachSeriesByType("graph", function (t) {
        var r = t.getCategoriesData(),
            i = t.getData(),
            n = {};
        r.each(function (o) {
            var s = r.getName(o);
            n["ec-" + s] = o;
            var l = r.getItemModel(o),
                u = l.getModel("itemStyle").getItemStyle();
            u.fill || (u.fill = t.getColorFromPalette(s, e)), r.setItemVisual(o, "style", u);
            for (var v = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < v.length; h++) {
                var c = l.getShallow(v[h], !0);
                c != null && r.setItemVisual(o, v[h], c)
            }
        }), r.count() && i.each(function (o) {
            var s = i.getItemModel(o),
                l = s.getShallow("category");
            if (l != null) {
                q(l) && (l = n["ec-" + l]);
                var u = r.getItemVisual(l, "style"),
                    v = i.ensureUniqueItemVisual(o, "style");
                W(v, u);
                for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], c = 0; c < h.length; c++) i.setItemVisual(o, h[c], r.getItemVisual(l, h[c]))
            }
        })
    })
}

function oi(a) {
    return a instanceof Array || (a = [a, a]), a
}

function L_(a) {
    a.eachSeriesByType("graph", function (e) {
        var t = e.getGraph(),
            r = e.getEdgeData(),
            i = oi(e.get("edgeSymbol")),
            n = oi(e.get("edgeSymbolSize"));
        r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", n && n[0]), r.setVisual("toSymbolSize", n && n[1]), r.setVisual("style", e.getModel("lineStyle").getLineStyle()), r.each(function (o) {
            var s = r.getItemModel(o),
                l = t.getEdgeByIndex(o),
                u = oi(s.getShallow("symbol", !0)),
                v = oi(s.getShallow("symbolSize", !0)),
                h = s.getModel("lineStyle").getLineStyle(),
                c = r.ensureUniqueItemVisual(o, "style");
            switch (W(c, h), c.stroke) {
                case "source": {
                    var f = l.node1.getVisual("style");
                    c.stroke = f && f.fill;
                    break
                }
                case "target": {
                    var f = l.node2.getVisual("style");
                    c.stroke = f && f.fill;
                    break
                }
            }
            u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), v[0] && l.setVisual("fromSymbolSize", v[0]), v[1] && l.setVisual("toSymbolSize", v[1])
        })
    })
}
var ys = "-->",
    Sn = function (a) {
        return a.get("autoCurveness") || null
    },
    dd = function (a, e) {
        var t = Sn(a),
            r = 20,
            i = [];
        if (te(t)) r = t;
        else if (B(t)) {
            a.__curvenessList = t;
            return
        }
        e > r && (r = e);
        var n = r % 2 ? r + 2 : r + 3;
        i = [];
        for (var o = 0; o < n; o++) i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
        a.__curvenessList = i
    },
    Ea = function (a, e, t) {
        var r = [a.id, a.dataIndex].join("."),
            i = [e.id, e.dataIndex].join(".");
        return [t.uid, r, i].join(ys)
    },
    gd = function (a) {
        var e = a.split(ys);
        return [e[0], e[2], e[1]].join(ys)
    },
    M_ = function (a, e) {
        var t = Ea(a.node1, a.node2, e);
        return e.__edgeMap[t]
    },
    P_ = function (a, e) {
        var t = ms(Ea(a.node1, a.node2, e), e),
            r = ms(Ea(a.node2, a.node1, e), e);
        return t + r
    },
    ms = function (a, e) {
        var t = e.__edgeMap;
        return t[a] ? t[a].length : 0
    };

function R_(a) {
    Sn(a) && (a.__curvenessList = [], a.__edgeMap = {}, dd(a))
}

function E_(a, e, t, r) {
    if (Sn(t)) {
        var i = Ea(a, e, t),
            n = t.__edgeMap,
            o = n[gd(i)];
        n[i] && !o ? n[i].isForward = !0 : o && n[i] && (o.isForward = !0, n[i].isForward = !1), n[i] = n[i] || [], n[i].push(r)
    }
}

function xl(a, e, t, r) {
    var i = Sn(e),
        n = B(i);
    if (!i) return null;
    var o = M_(a, e);
    if (!o) return null;
    for (var s = -1, l = 0; l < o.length; l++)
        if (o[l] === t) {
            s = l;
            break
        } var u = P_(a, e);
    dd(e, u), a.lineStyle = a.lineStyle || {};
    var v = Ea(a.node1, a.node2, e),
        h = e.__curvenessList,
        c = n || u % 2 ? 0 : 1;
    if (o.isForward) return h[c + s];
    var f = gd(v),
        p = ms(f, e),
        d = h[s + p + c];
    return r ? n ? i && i[0] === 0 ? (p + c) % 2 ? d : -d : ((p % 2 ? 0 : 1) + c) % 2 ? d : -d : (p + c) % 2 ? d : -d : h[s + p + c]
}

function yd(a) {
    var e = a.coordinateSystem;
    if (!(e && e.type !== "view")) {
        var t = a.getGraph();
        t.eachNode(function (r) {
            var i = r.getModel();
            r.setLayout([+i.get("x"), +i.get("y")])
        }), Sl(t, a)
    }
}

function Sl(a, e) {
    a.eachEdge(function (t, r) {
        var i = Wa(t.getModel().get(["lineStyle", "curveness"]), -xl(t, e, r, !0), 0),
            n = Ve(t.node1.getLayout()),
            o = Ve(t.node2.getLayout()),
            s = [n, o]; + i && s.push([(n[0] + o[0]) / 2 - (n[1] - o[1]) * i, (n[1] + o[1]) / 2 - (o[0] - n[0]) * i]), t.setLayout(s)
    })
}

function k_(a, e) {
    a.eachSeriesByType("graph", function (t) {
        var r = t.get("layout"),
            i = t.coordinateSystem;
        if (i && i.type !== "view") {
            var n = t.getData(),
                o = [];
            T(i.dimensions, function (c) {
                o = o.concat(n.mapDimensionsAll(c))
            });
            for (var s = 0; s < n.count(); s++) {
                for (var l = [], u = !1, v = 0; v < o.length; v++) {
                    var h = n.get(o[v], s);
                    isNaN(h) || (u = !0), l.push(h)
                }
                u ? n.setItemLayout(s, i.dataToPoint(l)) : n.setItemLayout(s, [NaN, NaN])
            }
            Sl(n.graph, t)
        } else(!r || r === "none") && yd(t)
    })
}

function da(a) {
    var e = a.coordinateSystem;
    if (e.type !== "view") return 1;
    var t = a.option.nodeScaleRatio,
        r = e.scaleX,
        i = e.getZoom(),
        n = (i - 1) * t + 1;
    return n / r
}

function ga(a) {
    var e = a.getVisual("symbolSize");
    return e instanceof Array && (e = (e[0] + e[1]) / 2), +e
}
var qv = Math.PI,
    qn = [];

function _l(a, e, t, r) {
    var i = a.coordinateSystem;
    if (!(i && i.type !== "view")) {
        var n = i.getBoundingRect(),
            o = a.getData(),
            s = o.graph,
            l = n.width / 2 + n.x,
            u = n.height / 2 + n.y,
            v = Math.min(n.width, n.height) / 2,
            h = o.count();
        if (o.setLayout({
                cx: l,
                cy: u
            }), !!h) {
            if (t) {
                var c = i.pointToData(r),
                    f = c[0],
                    p = c[1],
                    d = [f - l, p - u];
                $a(d, d), um(d, d, v), t.setLayout([l + d[0], u + d[1]], !0);
                var g = a.get(["circular", "rotateLabel"]);
                md(t, g, l, u)
            }
            V_[e](a, s, o, v, l, u, h), s.eachEdge(function (y, x) {
                var m = Wa(y.getModel().get(["lineStyle", "curveness"]), xl(y, a, x), 0),
                    S = Ve(y.node1.getLayout()),
                    _ = Ve(y.node2.getLayout()),
                    b, w = (S[0] + _[0]) / 2,
                    A = (S[1] + _[1]) / 2; + m && (m *= 3, b = [l * m + w * (1 - m), u * m + A * (1 - m)]), y.setLayout([S, _, b])
            })
        }
    }
}
var V_ = {
    value: function (a, e, t, r, i, n, o) {
        var s = 0,
            l = t.getSum("value"),
            u = Math.PI * 2 / (l || o);
        e.eachNode(function (v) {
            var h = v.getValue("value"),
                c = u * (l ? h : 1) / 2;
            s += c, v.setLayout([r * Math.cos(s) + i, r * Math.sin(s) + n]), s += c
        })
    },
    symbolSize: function (a, e, t, r, i, n, o) {
        var s = 0;
        qn.length = o;
        var l = da(a);
        e.eachNode(function (h) {
            var c = ga(h);
            isNaN(c) && (c = 2), c < 0 && (c = 0), c *= l;
            var f = Math.asin(c / 2 / r);
            isNaN(f) && (f = qv / 2), qn[h.dataIndex] = f, s += f * 2
        });
        var u = (2 * qv - s) / o / 2,
            v = 0;
        e.eachNode(function (h) {
            var c = u + qn[h.dataIndex];
            v += c, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([r * Math.cos(v) + i, r * Math.sin(v) + n]), v += c
        })
    }
};

function md(a, e, t, r) {
    var i = a.getGraphicEl();
    if (i) {
        var n = a.getModel(),
            o = n.get(["label", "rotate"]) || 0,
            s = i.getSymbolPath();
        if (e) {
            var l = a.getLayout(),
                u = Math.atan2(l[1] - r, l[0] - t);
            u < 0 && (u = Math.PI * 2 + u);
            var v = l[0] < t;
            v && (u = u - Math.PI);
            var h = v ? "left" : "right";
            s.setTextConfig({
                rotation: -u,
                position: h,
                origin: "center"
            });
            var c = s.ensureState("emphasis");
            W(c.textConfig || (c.textConfig = {}), {
                position: h
            })
        } else s.setTextConfig({
            rotation: o *= Math.PI / 180
        })
    }
}

function O_(a) {
    a.eachSeriesByType("graph", function (e) {
        e.get("layout") === "circular" && _l(e, "symbolSize")
    })
}
var br = Jo;

function z_(a, e, t) {
    for (var r = a, i = e, n = t.rect, o = n.width, s = n.height, l = [n.x + o / 2, n.y + s / 2], u = t.gravity == null ? .1 : t.gravity, v = 0; v < r.length; v++) {
        var h = r[v];
        h.p || (h.p = vm(o * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), h.pp = Ve(h.p), h.edges = null
    }
    var c = t.friction == null ? .6 : t.friction,
        f = c,
        p, d;
    return {
        warmUp: function () {
            f = c * .8
        },
        setFixed: function (g) {
            r[g].fixed = !0
        },
        setUnfixed: function (g) {
            r[g].fixed = !1
        },
        beforeStep: function (g) {
            p = g
        },
        afterStep: function (g) {
            d = g
        },
        step: function (g) {
            p && p(r, i);
            for (var y = [], x = r.length, m = 0; m < i.length; m++) {
                var S = i[m];
                if (!S.ignoreForceLayout) {
                    var _ = S.n1,
                        b = S.n2;
                    Vr(y, b.p, _.p);
                    var w = du(y) - S.d,
                        A = b.w / (_.w + b.w);
                    isNaN(A) && (A = 0), $a(y, y), !_.fixed && br(_.p, _.p, y, A * w * f), !b.fixed && br(b.p, b.p, y, -(1 - A) * w * f)
                }
            }
            for (var m = 0; m < x; m++) {
                var C = r[m];
                C.fixed || (Vr(y, l, C.p), br(C.p, C.p, y, u * f))
            }
            for (var m = 0; m < x; m++)
                for (var _ = r[m], D = m + 1; D < x; D++) {
                    var b = r[D];
                    Vr(y, b.p, _.p);
                    var w = du(y);
                    w === 0 && (hm(y, Math.random() - .5, Math.random() - .5), w = 1);
                    var I = (_.rep + b.rep) / w / w;
                    !_.fixed && br(_.pp, _.pp, y, I), !b.fixed && br(b.pp, b.pp, y, -I)
                }
            for (var L = [], m = 0; m < x; m++) {
                var C = r[m];
                C.fixed || (Vr(L, C.p, C.pp), br(C.p, C.p, L, f), Ft(C.pp, C.p))
            }
            f = f * .992;
            var M = f < .01;
            d && d(r, i, M), g && g(M)
        }
    }
}

function N_(a) {
    a.eachSeriesByType("graph", function (e) {
        var t = e.coordinateSystem;
        if (!(t && t.type !== "view"))
            if (e.get("layout") === "force") {
                var r = e.preservedPoints || {},
                    i = e.getGraph(),
                    n = i.data,
                    o = i.edgeData,
                    s = e.getModel("force"),
                    l = s.get("initLayout");
                e.preservedPoints ? n.each(function (m) {
                    var S = n.getId(m);
                    n.setItemLayout(m, r[S] || [NaN, NaN])
                }) : !l || l === "none" ? yd(e) : l === "circular" && _l(e, "value");
                var u = n.getDataExtent("value"),
                    v = o.getDataExtent("value"),
                    h = s.get("repulsion"),
                    c = s.get("edgeLength"),
                    f = B(h) ? h : [h, h],
                    p = B(c) ? c : [c, c];
                p = [p[1], p[0]];
                var d = n.mapArray("value", function (m, S) {
                        var _ = n.getItemLayout(S),
                            b = ht(m, u, f);
                        return isNaN(b) && (b = (f[0] + f[1]) / 2), {
                            w: b,
                            rep: b,
                            fixed: n.getItemModel(S).get("fixed"),
                            p: !_ || isNaN(_[0]) || isNaN(_[1]) ? null : _
                        }
                    }),
                    g = o.mapArray("value", function (m, S) {
                        var _ = i.getEdgeByIndex(S),
                            b = ht(m, v, p);
                        isNaN(b) && (b = (p[0] + p[1]) / 2);
                        var w = _.getModel(),
                            A = Wa(_.getModel().get(["lineStyle", "curveness"]), -xl(_, e, S, !0), 0);
                        return {
                            n1: d[_.node1.dataIndex],
                            n2: d[_.node2.dataIndex],
                            d: b,
                            curveness: A,
                            ignoreForceLayout: w.get("ignoreForceLayout")
                        }
                    }),
                    y = t.getBoundingRect(),
                    x = z_(d, g, {
                        rect: y,
                        gravity: s.get("gravity"),
                        friction: s.get("friction")
                    });
                x.beforeStep(function (m, S) {
                    for (var _ = 0, b = m.length; _ < b; _++) m[_].fixed && Ft(m[_].p, i.getNodeByIndex(_).getLayout())
                }), x.afterStep(function (m, S, _) {
                    for (var b = 0, w = m.length; b < w; b++) m[b].fixed || i.getNodeByIndex(b).setLayout(m[b].p), r[n.getId(b)] = m[b].p;
                    for (var b = 0, w = S.length; b < w; b++) {
                        var A = S[b],
                            C = i.getEdgeByIndex(b),
                            D = A.n1.p,
                            I = A.n2.p,
                            L = C.getLayout();
                        L = L ? L.slice() : [], L[0] = L[0] || [], L[1] = L[1] || [], Ft(L[0], D), Ft(L[1], I), +A.curveness && (L[2] = [(D[0] + I[0]) / 2 - (D[1] - I[1]) * A.curveness, (D[1] + I[1]) / 2 - (I[0] - D[0]) * A.curveness]), C.setLayout(L)
                    }
                }), e.forceLayout = x, e.preservedPoints = r, x.step()
            } else e.forceLayout = null
    })
}

function G_(a, e, t) {
    var r = W(a.getBoxLayoutParams(), {
        aspect: t
    });
    return kt(r, {
        width: e.getWidth(),
        height: e.getHeight()
    })
}

function B_(a, e) {
    var t = [];
    return a.eachSeriesByType("graph", function (r) {
        var i = r.get("coordinateSystem");
        if (!i || i === "view") {
            var n = r.getData(),
                o = n.mapArray(function (g) {
                    var y = n.getItemModel(g);
                    return [+y.get("x"), +y.get("y")]
                }),
                s = [],
                l = [];
            vn(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
            var u = (l[0] - s[0]) / (l[1] - s[1]),
                v = G_(r, e, u);
            isNaN(u) && (s = [v.x, v.y], l = [v.x + v.width, v.y + v.height]);
            var h = l[0] - s[0],
                c = l[1] - s[1],
                f = v.width,
                p = v.height,
                d = r.coordinateSystem = new qa;
            d.zoomLimit = r.get("scaleLimit"), d.setBoundingRect(s[0], s[1], h, c), d.setViewRect(v.x, v.y, f, p), d.setCenter(r.get("center"), e), d.setZoom(r.get("zoom")), t.push(d)
        }
    }), t
}
var jv = Jt.prototype,
    jn = tp.prototype,
    xd = function () {
        function a() {
            this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1
        }
        return a
    }();
(function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e
})(xd);

function Jn(a) {
    return isNaN(+a.cpx1) || isNaN(+a.cpy1)
}
var H_ = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "ec-line", r
        }
        return e.prototype.getDefaultStyle = function () {
            return {
                stroke: "#000",
                fill: null
            }
        }, e.prototype.getDefaultShape = function () {
            return new xd
        }, e.prototype.buildPath = function (t, r) {
            Jn(r) ? jv.buildPath.call(this, t, r) : jn.buildPath.call(this, t, r)
        }, e.prototype.pointAt = function (t) {
            return Jn(this.shape) ? jv.pointAt.call(this, t) : jn.pointAt.call(this, t)
        }, e.prototype.tangentAt = function (t) {
            var r = this.shape,
                i = Jn(r) ? [r.x2 - r.x1, r.y2 - r.y1] : jn.tangentAt.call(this, t);
            return $a(i, i)
        }, e
    }(Pt),
    Qn = ["fromSymbol", "toSymbol"];

function Jv(a) {
    return "_" + a + "Type"
}

function Qv(a, e, t) {
    var r = e.getItemVisual(t, a);
    if (!r || r === "none") return r;
    var i = e.getItemVisual(t, a + "Size"),
        n = e.getItemVisual(t, a + "Rotate"),
        o = e.getItemVisual(t, a + "Offset"),
        s = e.getItemVisual(t, a + "KeepAspect"),
        l = Na(i),
        u = jr(o || 0, l);
    return r + l + u + (n || "") + (s || "")
}

function th(a, e, t) {
    var r = e.getItemVisual(t, a);
    if (!(!r || r === "none")) {
        var i = e.getItemVisual(t, a + "Size"),
            n = e.getItemVisual(t, a + "Rotate"),
            o = e.getItemVisual(t, a + "Offset"),
            s = e.getItemVisual(t, a + "KeepAspect"),
            l = Na(i),
            u = jr(o || 0, l),
            v = Et(r, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
        return v.__specifiedRotation = n == null || isNaN(n) ? void 0 : +n * Math.PI / 180 || 0, v.name = a, v
    }
}

function F_(a) {
    var e = new H_({
        name: "line",
        subPixelOptimize: !0
    });
    return xs(e.shape, a), e
}

function xs(a, e) {
    a.x1 = e[0][0], a.y1 = e[0][1], a.x2 = e[1][0], a.y2 = e[1][1], a.percent = 1;
    var t = e[2];
    t ? (a.cpx1 = t[0], a.cpy1 = t[1]) : (a.cpx1 = NaN, a.cpy1 = NaN)
}
var W_ = function (a) {
    E(e, a);

    function e(t, r, i) {
        var n = a.call(this) || this;
        return n._createLine(t, r, i), n
    }
    return e.prototype._createLine = function (t, r, i) {
        var n = t.hostModel,
            o = t.getItemLayout(r),
            s = F_(o);
        s.shape.percent = 0, Yt(s, {
            shape: {
                percent: 1
            }
        }, n, r), this.add(s), T(Qn, function (l) {
            var u = th(l, t, r);
            this.add(u), this[Jv(l)] = Qv(l, t, r)
        }, this), this._updateCommonStl(t, r, i)
    }, e.prototype.updateData = function (t, r, i) {
        var n = t.hostModel,
            o = this.childOfName("line"),
            s = t.getItemLayout(r),
            l = {
                shape: {}
            };
        xs(l.shape, s), yt(o, l, n, r), T(Qn, function (u) {
            var v = Qv(u, t, r),
                h = Jv(u);
            if (this[h] !== v) {
                this.remove(this.childOfName(u));
                var c = th(u, t, r);
                this.add(c)
            }
            this[h] = v
        }, this), this._updateCommonStl(t, r, i)
    }, e.prototype.getLinePath = function () {
        return this.childAt(0)
    }, e.prototype._updateCommonStl = function (t, r, i) {
        var n = t.hostModel,
            o = this.childOfName("line"),
            s = i && i.emphasisLineStyle,
            l = i && i.blurLineStyle,
            u = i && i.selectLineStyle,
            v = i && i.labelStatesModels,
            h = i && i.emphasisDisabled,
            c = i && i.focus,
            f = i && i.blurScope;
        if (!i || t.hasItemOption) {
            var p = t.getItemModel(r),
                d = p.getModel("emphasis");
            s = d.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), h = d.get("disabled"), c = d.get("focus"), f = d.get("blurScope"), v = Gt(p)
        }
        var g = t.getItemVisual(r, "style"),
            y = g.stroke;
        o.useStyle(g), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, T(Qn, function (b) {
            var w = this.childOfName(b);
            if (w) {
                w.setColor(y), w.style.opacity = g.opacity;
                for (var A = 0; A < Aa.length; A++) {
                    var C = Aa[A],
                        D = o.getState(C);
                    if (D) {
                        var I = D.style || {},
                            L = w.ensureState(C),
                            M = L.style || (L.style = {});
                        I.stroke != null && (M[w.__isEmptyBrush ? "stroke" : "fill"] = I.stroke), I.opacity != null && (M.opacity = I.opacity)
                    }
                }
                w.markRedraw()
            }
        }, this);
        var x = n.getRawValue(r);
        Xt(this, v, {
            labelDataIndex: r,
            labelFetcher: {
                getFormattedLabel: function (b, w) {
                    return n.getFormattedLabel(b, w, t.dataType)
                }
            },
            inheritColor: y || "#000",
            defaultOpacity: g.opacity,
            defaultText: (x == null ? t.getName(r) : isFinite(x) ? js(x) : x) + ""
        });
        var m = this.getTextContent();
        if (m) {
            var S = v.normal;
            m.__align = m.style.align, m.__verticalAlign = m.style.verticalAlign, m.__position = S.get("position") || "middle";
            var _ = S.get("distance");
            B(_) || (_ = [_, _]), m.__labelDistance = _
        }
        this.setTextConfig({
            position: null,
            local: !0,
            inside: !1
        }), Tt(this, c, f, h)
    }, e.prototype.highlight = function () {
        Br(this)
    }, e.prototype.downplay = function () {
        Hr(this)
    }, e.prototype.updateLayout = function (t, r) {
        this.setLinePoints(t.getItemLayout(r))
    }, e.prototype.setLinePoints = function (t) {
        var r = this.childOfName("line");
        xs(r.shape, t), r.dirty()
    }, e.prototype.beforeUpdate = function () {
        var t = this,
            r = t.childOfName("fromSymbol"),
            i = t.childOfName("toSymbol"),
            n = t.getTextContent();
        if (!r && !i && (!n || n.ignore)) return;
        for (var o = 1, s = this.parent; s;) s.scaleX && (o /= s.scaleX), s = s.parent;
        var l = t.childOfName("line");
        if (!this.__dirty && !l.__dirty) return;
        var u = l.shape.percent,
            v = l.pointAt(0),
            h = l.pointAt(u),
            c = Vr([], h, v);
        $a(c, c);

        function f(D, I) {
            var L = D.__specifiedRotation;
            if (L == null) {
                var M = l.tangentAt(I);
                D.attr("rotation", (I === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(M[1], M[0]))
            } else D.attr("rotation", L)
        }
        if (r && (r.setPosition(v), f(r, 0), r.scaleX = r.scaleY = o * u, r.markRedraw()), i && (i.setPosition(h), f(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), n && !n.ignore) {
            n.x = n.y = 0, n.originX = n.originY = 0;
            var p = void 0,
                d = void 0,
                g = n.__labelDistance,
                y = g[0] * o,
                x = g[1] * o,
                m = u / 2,
                S = l.tangentAt(m),
                _ = [S[1], -S[0]],
                b = l.pointAt(m);
            _[1] > 0 && (_[0] = -_[0], _[1] = -_[1]);
            var w = S[0] < 0 ? -1 : 1;
            if (n.__position !== "start" && n.__position !== "end") {
                var A = -Math.atan2(S[1], S[0]);
                h[0] < v[0] && (A = Math.PI + A), n.rotation = A
            }
            var C = void 0;
            switch (n.__position) {
                case "insideStartTop":
                case "insideMiddleTop":
                case "insideEndTop":
                case "middle":
                    C = -x, d = "bottom";
                    break;
                case "insideStartBottom":
                case "insideMiddleBottom":
                case "insideEndBottom":
                    C = x, d = "top";
                    break;
                default:
                    C = 0, d = "middle"
            }
            switch (n.__position) {
                case "end":
                    n.x = c[0] * y + h[0], n.y = c[1] * x + h[1], p = c[0] > .8 ? "left" : c[0] < -.8 ? "right" : "center", d = c[1] > .8 ? "top" : c[1] < -.8 ? "bottom" : "middle";
                    break;
                case "start":
                    n.x = -c[0] * y + v[0], n.y = -c[1] * x + v[1], p = c[0] > .8 ? "right" : c[0] < -.8 ? "left" : "center", d = c[1] > .8 ? "bottom" : c[1] < -.8 ? "top" : "middle";
                    break;
                case "insideStartTop":
                case "insideStart":
                case "insideStartBottom":
                    n.x = y * w + v[0], n.y = v[1] + C, p = S[0] < 0 ? "right" : "left", n.originX = -y * w, n.originY = -C;
                    break;
                case "insideMiddleTop":
                case "insideMiddle":
                case "insideMiddleBottom":
                case "middle":
                    n.x = b[0], n.y = b[1] + C, p = "center", n.originY = -C;
                    break;
                case "insideEndTop":
                case "insideEnd":
                case "insideEndBottom":
                    n.x = -y * w + h[0], n.y = h[1] + C, p = S[0] >= 0 ? "right" : "left", n.originX = y * w, n.originY = -C;
                    break
            }
            n.scaleX = n.scaleY = o, n.setStyle({
                verticalAlign: n.__verticalAlign || d,
                align: n.__align || p
            })
        }
    }, e
}(U);
const bl = W_;
var wl = function () {
    function a(e) {
        this.group = new U, this._LineCtor = e || bl
    }
    return a.prototype.updateData = function (e) {
        var t = this;
        this._progressiveEls = null;
        var r = this,
            i = r.group,
            n = r._lineData;
        r._lineData = e, n || i.removeAll();
        var o = eh(e);
        e.diff(n).add(function (s) {
            t._doAdd(e, s, o)
        }).update(function (s, l) {
            t._doUpdate(n, e, l, s, o)
        }).remove(function (s) {
            i.remove(n.getItemGraphicEl(s))
        }).execute()
    }, a.prototype.updateLayout = function () {
        var e = this._lineData;
        e && e.eachItemGraphicEl(function (t, r) {
            t.updateLayout(e, r)
        }, this)
    }, a.prototype.incrementalPrepareUpdate = function (e) {
        this._seriesScope = eh(e), this._lineData = null, this.group.removeAll()
    }, a.prototype.incrementalUpdate = function (e, t) {
        this._progressiveEls = [];

        function r(s) {
            !s.isGroup && !$_(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0)
        }
        for (var i = e.start; i < e.end; i++) {
            var n = t.getItemLayout(i);
            if (to(n)) {
                var o = new this._LineCtor(t, i, this._seriesScope);
                o.traverse(r), this.group.add(o), t.setItemGraphicEl(i, o), this._progressiveEls.push(o)
            }
        }
    }, a.prototype.remove = function () {
        this.group.removeAll()
    }, a.prototype.eachRendered = function (e) {
        Ga(this._progressiveEls || this.group, e)
    }, a.prototype._doAdd = function (e, t, r) {
        var i = e.getItemLayout(t);
        if (to(i)) {
            var n = new this._LineCtor(e, t, r);
            e.setItemGraphicEl(t, n), this.group.add(n)
        }
    }, a.prototype._doUpdate = function (e, t, r, i, n) {
        var o = e.getItemGraphicEl(r);
        if (!to(t.getItemLayout(i))) {
            this.group.remove(o);
            return
        }
        o ? o.updateData(t, i, n) : o = new this._LineCtor(t, i, n), t.setItemGraphicEl(i, o), this.group.add(o)
    }, a
}();

function $_(a) {
    return a.animators && a.animators.length > 0
}

function eh(a) {
    var e = a.hostModel,
        t = e.getModel("emphasis");
    return {
        lineStyle: e.getModel("lineStyle").getLineStyle(),
        emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
        blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
        selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
        emphasisDisabled: t.get("disabled"),
        blurScope: t.get("blurScope"),
        focus: t.get("focus"),
        labelStatesModels: Gt(e)
    }
}

function rh(a) {
    return isNaN(a[0]) || isNaN(a[1])
}

function to(a) {
    return a && !rh(a[0]) && !rh(a[1])
}
var eo = [],
    ro = [],
    ao = [],
    wr = ap,
    io = fm,
    ah = Math.abs;

function ih(a, e, t) {
    for (var r = a[0], i = a[1], n = a[2], o = 1 / 0, s, l = t * t, u = .1, v = .1; v <= .9; v += .1) {
        eo[0] = wr(r[0], i[0], n[0], v), eo[1] = wr(r[1], i[1], n[1], v);
        var h = ah(io(eo, e) - l);
        h < o && (o = h, s = v)
    }
    for (var c = 0; c < 32; c++) {
        var f = s + u;
        ro[0] = wr(r[0], i[0], n[0], s), ro[1] = wr(r[1], i[1], n[1], s), ao[0] = wr(r[0], i[0], n[0], f), ao[1] = wr(r[1], i[1], n[1], f);
        var h = io(ro, e) - l;
        if (ah(h) < .01) break;
        var p = io(ao, e) - l;
        u /= 2, h < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u
    }
    return s
}

function no(a, e) {
    var t = [],
        r = cm,
        i = [
            [],
            [],
            []
        ],
        n = [
            [],
            []
        ],
        o = [];
    e /= 2, a.eachEdge(function (s, l) {
        var u = s.getLayout(),
            v = s.getVisual("fromSymbol"),
            h = s.getVisual("toSymbol");
        u.__original || (u.__original = [Ve(u[0]), Ve(u[1])], u[2] && u.__original.push(Ve(u[2])));
        var c = u.__original;
        if (u[2] != null) {
            if (Ft(i[0], c[0]), Ft(i[1], c[2]), Ft(i[2], c[1]), v && v !== "none") {
                var f = ga(s.node1),
                    p = ih(i, c[0], f * e);
                r(i[0][0], i[1][0], i[2][0], p, t), i[0][0] = t[3], i[1][0] = t[4], r(i[0][1], i[1][1], i[2][1], p, t), i[0][1] = t[3], i[1][1] = t[4]
            }
            if (h && h !== "none") {
                var f = ga(s.node2),
                    p = ih(i, c[1], f * e);
                r(i[0][0], i[1][0], i[2][0], p, t), i[1][0] = t[1], i[2][0] = t[2], r(i[0][1], i[1][1], i[2][1], p, t), i[1][1] = t[1], i[2][1] = t[2]
            }
            Ft(u[0], i[0]), Ft(u[1], i[2]), Ft(u[2], i[1])
        } else {
            if (Ft(n[0], c[0]), Ft(n[1], c[1]), Vr(o, n[1], n[0]), $a(o, o), v && v !== "none") {
                var f = ga(s.node1);
                Jo(n[0], n[0], o, f * e)
            }
            if (h && h !== "none") {
                var f = ga(s.node2);
                Jo(n[1], n[1], o, -f * e)
            }
            Ft(u[0], n[0]), Ft(u[1], n[1])
        }
    })
}

function nh(a) {
    return a.type === "view"
}
var Z_ = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function (t, r) {
        var i = new Ya,
            n = new wl,
            o = this.group;
        this._controller = new Ka(r.getZr()), this._controllerHost = {
            target: o
        }, o.add(i.group), o.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0
    }, e.prototype.render = function (t, r, i) {
        var n = this,
            o = t.coordinateSystem;
        this._model = t;
        var s = this._symbolDraw,
            l = this._lineDraw,
            u = this.group;
        if (nh(o)) {
            var v = {
                x: o.x,
                y: o.y,
                scaleX: o.scaleX,
                scaleY: o.scaleY
            };
            this._firstRender ? u.attr(v) : yt(u, v, t)
        }
        no(t.getGraph(), da(t));
        var h = t.getData();
        s.updateData(h);
        var c = t.getEdgeData();
        l.updateData(c), this._updateNodeAndLinkScale(), this._updateController(t, r, i), clearTimeout(this._layoutTimeout);
        var f = t.forceLayout,
            p = t.get(["force", "layoutAnimation"]);
        f && this._startForceLayoutIteration(f, p);
        var d = t.get("layout");
        h.graph.eachNode(function (m) {
            var S = m.dataIndex,
                _ = m.getGraphicEl(),
                b = m.getModel();
            if (_) {
                _.off("drag").off("dragend");
                var w = b.get("draggable");
                w && _.on("drag", function (C) {
                    switch (d) {
                        case "force":
                            f.warmUp(), !n._layouting && n._startForceLayoutIteration(f, p), f.setFixed(S), h.setItemLayout(S, [_.x, _.y]);
                            break;
                        case "circular":
                            h.setItemLayout(S, [_.x, _.y]), m.setLayout({
                                fixed: !0
                            }, !0), _l(t, "symbolSize", m, [C.offsetX, C.offsetY]), n.updateLayout(t);
                            break;
                        case "none":
                        default:
                            h.setItemLayout(S, [_.x, _.y]), Sl(t.getGraph(), t), n.updateLayout(t);
                            break
                    }
                }).on("dragend", function () {
                    f && f.setUnfixed(S)
                }), _.setDraggable(w, !!b.get("cursor"));
                var A = b.get(["emphasis", "focus"]);
                A === "adjacency" && (tt(_).focus = m.getAdjacentDataIndices())
            }
        }), h.graph.eachEdge(function (m) {
            var S = m.getGraphicEl(),
                _ = m.getModel().get(["emphasis", "focus"]);
            S && _ === "adjacency" && (tt(S).focus = {
                edge: [m.dataIndex],
                node: [m.node1.dataIndex, m.node2.dataIndex]
            })
        });
        var g = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]),
            y = h.getLayout("cx"),
            x = h.getLayout("cy");
        h.graph.eachNode(function (m) {
            md(m, g, y, x)
        }), this._firstRender = !1
    }, e.prototype.dispose = function () {
        this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null
    }, e.prototype._startForceLayoutIteration = function (t, r) {
        var i = this;
        (function n() {
            t.step(function (o) {
                i.updateLayout(i._model), (i._layouting = !o) && (r ? i._layoutTimeout = setTimeout(n, 16) : n())
            })
        })()
    }, e.prototype._updateController = function (t, r, i) {
        var n = this,
            o = this._controller,
            s = this._controllerHost,
            l = this.group;
        if (o.setPointerChecker(function (u, v, h) {
                var c = l.getBoundingRect();
                return c.applyTransform(l.transform), c.contain(v, h) && !yn(u, i, t)
            }), !nh(t.coordinateSystem)) {
            o.disable();
            return
        }
        o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function (u) {
            vl(s, u.dx, u.dy), i.dispatchAction({
                seriesId: t.id,
                type: "graphRoam",
                dx: u.dx,
                dy: u.dy
            })
        }).on("zoom", function (u) {
            hl(s, u.scale, u.originX, u.originY), i.dispatchAction({
                seriesId: t.id,
                type: "graphRoam",
                zoom: u.scale,
                originX: u.originX,
                originY: u.originY
            }), n._updateNodeAndLinkScale(), no(t.getGraph(), da(t)), n._lineDraw.updateLayout(), i.updateLabelLayout()
        })
    }, e.prototype._updateNodeAndLinkScale = function () {
        var t = this._model,
            r = t.getData(),
            i = da(t);
        r.eachItemGraphicEl(function (n, o) {
            n && n.setSymbolScale(i)
        })
    }, e.prototype.updateLayout = function (t) {
        no(t.getGraph(), da(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout()
    }, e.prototype.remove = function () {
        clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove()
    }, e.type = "graph", e
}(At);
const U_ = Z_;

function Ar(a) {
    return "_EC_" + a
}
var Y_ = function () {
        function a(e) {
            this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1
        }
        return a.prototype.isDirected = function () {
            return this._directed
        }, a.prototype.addNode = function (e, t) {
            e = e == null ? "" + t : "" + e;
            var r = this._nodesMap;
            if (!r[Ar(e)]) {
                var i = new tr(e, t);
                return i.hostGraph = this, this.nodes.push(i), r[Ar(e)] = i, i
            }
        }, a.prototype.getNodeByIndex = function (e) {
            var t = this.data.getRawIndex(e);
            return this.nodes[t]
        }, a.prototype.getNodeById = function (e) {
            return this._nodesMap[Ar(e)]
        }, a.prototype.addEdge = function (e, t, r) {
            var i = this._nodesMap,
                n = this._edgesMap;
            if (te(e) && (e = this.nodes[e]), te(t) && (t = this.nodes[t]), e instanceof tr || (e = i[Ar(e)]), t instanceof tr || (t = i[Ar(t)]), !(!e || !t)) {
                var o = e.id + "-" + t.id,
                    s = new Sd(e, t, r);
                return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), n[o] = s, s
            }
        }, a.prototype.getEdgeByIndex = function (e) {
            var t = this.edgeData.getRawIndex(e);
            return this.edges[t]
        }, a.prototype.getEdge = function (e, t) {
            e instanceof tr && (e = e.id), t instanceof tr && (t = t.id);
            var r = this._edgesMap;
            return this._directed ? r[e + "-" + t] : r[e + "-" + t] || r[t + "-" + e]
        }, a.prototype.eachNode = function (e, t) {
            for (var r = this.nodes, i = r.length, n = 0; n < i; n++) r[n].dataIndex >= 0 && e.call(t, r[n], n)
        }, a.prototype.eachEdge = function (e, t) {
            for (var r = this.edges, i = r.length, n = 0; n < i; n++) r[n].dataIndex >= 0 && r[n].node1.dataIndex >= 0 && r[n].node2.dataIndex >= 0 && e.call(t, r[n], n)
        }, a.prototype.breadthFirstTraverse = function (e, t, r, i) {
            if (t instanceof tr || (t = this._nodesMap[Ar(t)]), !!t) {
                for (var n = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = !1;
                if (!e.call(i, t, null))
                    for (var s = [t]; s.length;)
                        for (var l = s.shift(), u = l[n], o = 0; o < u.length; o++) {
                            var v = u[o],
                                h = v.node1 === l ? v.node2 : v.node1;
                            if (!h.__visited) {
                                if (e.call(i, h, l)) return;
                                s.push(h), h.__visited = !0
                            }
                        }
            }
        }, a.prototype.update = function () {
            for (var e = this.data, t = this.edgeData, r = this.nodes, i = this.edges, n = 0, o = r.length; n < o; n++) r[n].dataIndex = -1;
            for (var n = 0, o = e.count(); n < o; n++) r[e.getRawIndex(n)].dataIndex = n;
            t.filterSelf(function (s) {
                var l = i[t.getRawIndex(s)];
                return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0
            });
            for (var n = 0, o = i.length; n < o; n++) i[n].dataIndex = -1;
            for (var n = 0, o = t.count(); n < o; n++) i[t.getRawIndex(n)].dataIndex = n
        }, a.prototype.clone = function () {
            for (var e = new a(this._directed), t = this.nodes, r = this.edges, i = 0; i < t.length; i++) e.addNode(t[i].id, t[i].dataIndex);
            for (var i = 0; i < r.length; i++) {
                var n = r[i];
                e.addEdge(n.node1.id, n.node2.id, n.dataIndex)
            }
            return e
        }, a
    }(),
    tr = function () {
        function a(e, t) {
            this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ? ? "", this.dataIndex = t ? ? -1
        }
        return a.prototype.degree = function () {
            return this.edges.length
        }, a.prototype.inDegree = function () {
            return this.inEdges.length
        }, a.prototype.outDegree = function () {
            return this.outEdges.length
        }, a.prototype.getModel = function (e) {
            if (!(this.dataIndex < 0)) {
                var t = this.hostGraph,
                    r = t.data.getItemModel(this.dataIndex);
                return r.getModel(e)
            }
        }, a.prototype.getAdjacentDataIndices = function () {
            for (var e = {
                    edge: [],
                    node: []
                }, t = 0; t < this.edges.length; t++) {
                var r = this.edges[t];
                r.dataIndex < 0 || (e.edge.push(r.dataIndex), e.node.push(r.node1.dataIndex, r.node2.dataIndex))
            }
            return e
        }, a.prototype.getTrajectoryDataIndices = function () {
            for (var e = Q(), t = Q(), r = 0; r < this.edges.length; r++) {
                var i = this.edges[r];
                if (!(i.dataIndex < 0)) {
                    e.set(i.dataIndex, !0);
                    for (var n = [i.node1], o = [i.node2], s = 0; s < n.length;) {
                        var l = n[s];
                        s++, t.set(l.dataIndex, !0);
                        for (var u = 0; u < l.inEdges.length; u++) e.set(l.inEdges[u].dataIndex, !0), n.push(l.inEdges[u].node1)
                    }
                    for (s = 0; s < o.length;) {
                        var v = o[s];
                        s++, t.set(v.dataIndex, !0);
                        for (var u = 0; u < v.outEdges.length; u++) e.set(v.outEdges[u].dataIndex, !0), o.push(v.outEdges[u].node2)
                    }
                }
            }
            return {
                edge: e.keys(),
                node: t.keys()
            }
        }, a
    }(),
    Sd = function () {
        function a(e, t, r) {
            this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = r ? ? -1
        }
        return a.prototype.getModel = function (e) {
            if (!(this.dataIndex < 0)) {
                var t = this.hostGraph,
                    r = t.edgeData.getItemModel(this.dataIndex);
                return r.getModel(e)
            }
        }, a.prototype.getAdjacentDataIndices = function () {
            return {
                edge: [this.dataIndex],
                node: [this.node1.dataIndex, this.node2.dataIndex]
            }
        }, a.prototype.getTrajectoryDataIndices = function () {
            var e = Q(),
                t = Q();
            e.set(this.dataIndex, !0);
            for (var r = [this.node1], i = [this.node2], n = 0; n < r.length;) {
                var o = r[n];
                n++, t.set(o.dataIndex, !0);
                for (var s = 0; s < o.inEdges.length; s++) e.set(o.inEdges[s].dataIndex, !0), r.push(o.inEdges[s].node1)
            }
            for (n = 0; n < i.length;) {
                var l = i[n];
                n++, t.set(l.dataIndex, !0);
                for (var s = 0; s < l.outEdges.length; s++) e.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2)
            }
            return {
                edge: e.keys(),
                node: t.keys()
            }
        }, a
    }();

function _d(a, e) {
    return {
        getValue: function (t) {
            var r = this[a][e];
            return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex)
        },
        setVisual: function (t, r) {
            this.dataIndex >= 0 && this[a][e].setItemVisual(this.dataIndex, t, r)
        },
        getVisual: function (t) {
            return this[a][e].getItemVisual(this.dataIndex, t)
        },
        setLayout: function (t, r) {
            this.dataIndex >= 0 && this[a][e].setItemLayout(this.dataIndex, t, r)
        },
        getLayout: function () {
            return this[a][e].getItemLayout(this.dataIndex)
        },
        getGraphicEl: function () {
            return this[a][e].getItemGraphicEl(this.dataIndex)
        },
        getRawIndex: function () {
            return this[a][e].getRawIndex(this.dataIndex)
        }
    }
}
le(tr, _d("hostGraph", "data"));
le(Sd, _d("hostGraph", "edgeData"));

function bd(a, e, t, r, i) {
    for (var n = new Y_(r), o = 0; o < a.length; o++) n.addNode(Ut(a[o].id, a[o].name, o), o);
    for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
        var v = e[o],
            h = v.source,
            c = v.target;
        n.addEdge(h, c, u) && (l.push(v), s.push(Ut(Se(v.id, null), h + " > " + c)), u++)
    }
    var f = t.get("coordinateSystem"),
        p;
    if (f === "cartesian2d" || f === "polar") p = dr(a, t);
    else {
        var d = ip.get(f),
            g = d ? d.dimensions || [] : [];
        ft(g, "value") < 0 && g.concat(["value"]);
        var y = qs(a, {
            coordDimensions: g,
            encodeDefine: t.getEncode()
        }).dimensions;
        p = new Qt(y, t), p.initData(a)
    }
    var x = new Qt(["value"], t);
    return x.initData(l, s), i && i(p, x), ad({
        mainData: p,
        struct: n,
        structAttr: "graph",
        datas: {
            node: p,
            edge: x
        },
        datasAttr: {
            node: "data",
            edge: "edgeData"
        }
    }), n.update(), n
}
var X_ = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.hasSymbolVisual = !0, t
    }
    return e.prototype.init = function (t) {
        a.prototype.init.apply(this, arguments);
        var r = this;

        function i() {
            return r._categoriesData
        }
        this.legendVisualProvider = new Js(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
    }, e.prototype.mergeOption = function (t) {
        a.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
    }, e.prototype.mergeDefaultAndTheme = function (t) {
        a.prototype.mergeDefaultAndTheme.apply(this, arguments), un(t, "edgeLabel", ["show"])
    }, e.prototype.getInitialData = function (t, r) {
        var i = t.edges || t.links || [],
            n = t.data || t.nodes || [],
            o = this;
        if (n && i) {
            R_(this);
            var s = bd(n, i, this, !0, l);
            return T(s.edges, function (u) {
                E_(u.node1, u.node2, this, u.dataIndex)
            }, this), s.data
        }

        function l(u, v) {
            u.wrapMethod("getItemModel", function (p) {
                var d = o._categoriesModels,
                    g = p.getShallow("category"),
                    y = d[g];
                return y && (y.parentModel = p.parentModel, p.parentModel = y), p
            });
            var h = Rt.prototype.getModel;

            function c(p, d) {
                var g = h.call(this, p, d);
                return g.resolveParentPath = f, g
            }
            v.wrapMethod("getItemModel", function (p) {
                return p.resolveParentPath = f, p.getModel = c, p
            });

            function f(p) {
                if (p && (p[0] === "label" || p[1] === "label")) {
                    var d = p.slice();
                    return p[0] === "label" ? d[0] = "edgeLabel" : p[1] === "label" && (d[1] = "edgeLabel"), d
                }
                return p
            }
        }
    }, e.prototype.getGraph = function () {
        return this.getData().graph
    }, e.prototype.getEdgeData = function () {
        return this.getGraph().edgeData
    }, e.prototype.getCategoriesData = function () {
        return this._categoriesData
    }, e.prototype.formatTooltip = function (t, r, i) {
        if (i === "edge") {
            var n = this.getData(),
                o = this.getDataParams(t, i),
                s = n.graph.getEdgeByIndex(t),
                l = n.getName(s.node1.dataIndex),
                u = n.getName(s.node2.dataIndex),
                v = [];
            return l != null && v.push(l), u != null && v.push(u), qt("nameValue", {
                name: v.join(" > "),
                value: o.value,
                noValue: o.value == null
            })
        }
        var h = pm({
            series: this,
            dataIndex: t,
            multipleSeries: r
        });
        return h
    }, e.prototype._updateCategoriesData = function () {
        var t = G(this.option.categories || [], function (i) {
                return i.value != null ? i : W({
                    value: 0
                }, i)
            }),
            r = new Qt(["value"], this);
        r.initData(t), this._categoriesData = r, this._categoriesModels = r.mapArray(function (i) {
            return r.getItemModel(i)
        })
    }, e.prototype.setZoom = function (t) {
        this.option.zoom = t
    }, e.prototype.setCenter = function (t) {
        this.option.center = t
    }, e.prototype.isAnimationEnabled = function () {
        return a.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]))
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
        z: 2,
        coordinateSystem: "view",
        legendHoverLink: !0,
        layout: null,
        circular: {
            rotateLabel: !1
        },
        force: {
            initLayout: null,
            repulsion: [0, 50],
            gravity: .1,
            friction: .6,
            edgeLength: 30,
            layoutAnimation: !0
        },
        left: "center",
        top: "center",
        symbol: "circle",
        symbolSize: 10,
        edgeSymbol: ["none", "none"],
        edgeSymbolSize: 10,
        edgeLabel: {
            position: "middle",
            distance: 5
        },
        draggable: !1,
        roam: !1,
        center: null,
        zoom: 1,
        nodeScaleRatio: .6,
        label: {
            show: !1,
            formatter: "{b}"
        },
        itemStyle: {},
        lineStyle: {
            color: "#aaa",
            width: 1,
            opacity: .5
        },
        emphasis: {
            scale: !0,
            label: {
                show: !0
            }
        },
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        }
    }, e
}(Vt);
const K_ = X_;
var q_ = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
};

function j_(a) {
    a.registerChartView(U_), a.registerSeriesModel(K_), a.registerProcessor(D_), a.registerVisual(I_), a.registerVisual(L_), a.registerLayout(k_), a.registerLayout(a.PRIORITY.VISUAL.POST_CHART_LAYOUT, O_), a.registerLayout(N_), a.registerCoordinateSystem("graphView", {
        dimensions: qa.dimensions,
        create: B_
    }), a.registerAction({
        type: "focusNodeAdjacency",
        event: "focusNodeAdjacency",
        update: "series:focusNodeAdjacency"
    }, pe), a.registerAction({
        type: "unfocusNodeAdjacency",
        event: "unfocusNodeAdjacency",
        update: "series:unfocusNodeAdjacency"
    }, pe), a.registerAction(q_, function (e, t, r) {
        t.eachComponent({
            mainType: "series",
            query: e
        }, function (i) {
            var n = i.coordinateSystem,
                o = fl(n, e, void 0, r);
            i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
        })
    })
}
var J_ = function () {
        function a() {
            this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0
        }
        return a
    }(),
    Q_ = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "pointer", r
        }
        return e.prototype.getDefaultShape = function () {
            return new J_
        }, e.prototype.buildPath = function (t, r) {
            var i = Math.cos,
                n = Math.sin,
                o = r.r,
                s = r.width,
                l = r.angle,
                u = r.x - i(l) * s * (s >= o / 3 ? 1 : 2),
                v = r.y - n(l) * s * (s >= o / 3 ? 1 : 2);
            l = r.angle - Math.PI / 2, t.moveTo(u, v), t.lineTo(r.x + i(l) * s, r.y + n(l) * s), t.lineTo(r.x + i(r.angle) * o, r.y + n(r.angle) * o), t.lineTo(r.x - i(l) * s, r.y - n(l) * s), t.lineTo(u, v)
        }, e
    }(Pt);

function tb(a, e) {
    var t = a.get("center"),
        r = e.getWidth(),
        i = e.getHeight(),
        n = Math.min(r, i),
        o = H(t[0], e.getWidth()),
        s = H(t[1], e.getHeight()),
        l = H(a.get("radius"), n / 2);
    return {
        cx: o,
        cy: s,
        r: l
    }
}

function si(a, e) {
    var t = a == null ? "" : a + "";
    return e && (q(e) ? t = e.replace("{value}", t) : rt(e) && (t = e(a))), t
}
var eb = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i) {
        this.group.removeAll();
        var n = t.get(["axisLine", "lineStyle", "color"]),
            o = tb(t, i);
        this._renderMain(t, r, i, n, o), this._data = t.getData()
    }, e.prototype.dispose = function () {}, e.prototype._renderMain = function (t, r, i, n, o) {
        var s = this.group,
            l = t.get("clockwise"),
            u = -t.get("startAngle") / 180 * Math.PI,
            v = -t.get("endAngle") / 180 * Math.PI,
            h = t.getModel("axisLine"),
            c = h.get("roundCap"),
            f = c ? yu : cr,
            p = h.get("show"),
            d = h.getModel("lineStyle"),
            g = d.get("width"),
            y = [u, v];
        dm(y, !l), u = y[0], v = y[1];
        for (var x = v - u, m = u, S = [], _ = 0; p && _ < n.length; _++) {
            var b = Math.min(Math.max(n[_][0], 0), 1);
            v = u + x * b;
            var w = new f({
                shape: {
                    startAngle: m,
                    endAngle: v,
                    cx: o.cx,
                    cy: o.cy,
                    clockwise: l,
                    r0: o.r - g,
                    r: o.r
                },
                silent: !0
            });
            w.setStyle({
                fill: n[_][1]
            }), w.setStyle(d.getLineStyle(["color", "width"])), S.push(w), m = v
        }
        S.reverse(), T(S, function (C) {
            return s.add(C)
        });
        var A = function (C) {
            if (C <= 0) return n[0][1];
            var D;
            for (D = 0; D < n.length; D++)
                if (n[D][0] >= C && (D === 0 ? 0 : n[D - 1][0]) < C) return n[D][1];
            return n[D - 1][1]
        };
        this._renderTicks(t, r, i, A, o, u, v, l, g), this._renderTitleAndDetail(t, r, i, A, o), this._renderAnchor(t, o), this._renderPointer(t, r, i, A, o, u, v, l, g)
    }, e.prototype._renderTicks = function (t, r, i, n, o, s, l, u, v) {
        for (var h = this.group, c = o.cx, f = o.cy, p = o.r, d = +t.get("min"), g = +t.get("max"), y = t.getModel("splitLine"), x = t.getModel("axisTick"), m = t.getModel("axisLabel"), S = t.get("splitNumber"), _ = x.get("splitNumber"), b = H(y.get("length"), p), w = H(x.get("length"), p), A = s, C = (l - s) / S, D = C / _, I = y.getModel("lineStyle").getLineStyle(), L = x.getModel("lineStyle").getLineStyle(), M = y.get("distance"), P, R, k = 0; k <= S; k++) {
            if (P = Math.cos(A), R = Math.sin(A), y.get("show")) {
                var V = M ? M + v : v,
                    O = new Jt({
                        shape: {
                            x1: P * (p - V) + c,
                            y1: R * (p - V) + f,
                            x2: P * (p - b - V) + c,
                            y2: R * (p - b - V) + f
                        },
                        style: I,
                        silent: !0
                    });
                I.stroke === "auto" && O.setStyle({
                    stroke: n(k / S)
                }), h.add(O)
            }
            if (m.get("show")) {
                var V = m.get("distance") + M,
                    z = si(js(k / S * (g - d) + d), m.get("formatter")),
                    $ = n(k / S),
                    Z = P * (p - b - V) + c,
                    et = R * (p - b - V) + f,
                    J = m.get("rotate"),
                    X = 0;
                J === "radial" ? (X = -A + 2 * Math.PI, X > Math.PI / 2 && (X += Math.PI)) : J === "tangential" ? X = -A - Math.PI / 2 : te(J) && (X = J * Math.PI / 180), X === 0 ? h.add(new ut({
                    style: mt(m, {
                        text: z,
                        x: Z,
                        y: et,
                        verticalAlign: R < -.8 ? "top" : R > .8 ? "bottom" : "middle",
                        align: P < -.4 ? "left" : P > .4 ? "right" : "center"
                    }, {
                        inheritColor: $
                    }),
                    silent: !0
                })) : h.add(new ut({
                    style: mt(m, {
                        text: z,
                        x: Z,
                        y: et,
                        verticalAlign: "middle",
                        align: "center"
                    }, {
                        inheritColor: $
                    }),
                    silent: !0,
                    originX: Z,
                    originY: et,
                    rotation: X
                }))
            }
            if (x.get("show") && k !== S) {
                var V = x.get("distance");
                V = V ? V + v : v;
                for (var nt = 0; nt <= _; nt++) {
                    P = Math.cos(A), R = Math.sin(A);
                    var st = new Jt({
                        shape: {
                            x1: P * (p - V) + c,
                            y1: R * (p - V) + f,
                            x2: P * (p - w - V) + c,
                            y2: R * (p - w - V) + f
                        },
                        silent: !0,
                        style: L
                    });
                    L.stroke === "auto" && st.setStyle({
                        stroke: n((k + nt / _) / S)
                    }), h.add(st), A += D
                }
                A -= D
            } else A += C
        }
    }, e.prototype._renderPointer = function (t, r, i, n, o, s, l, u, v) {
        var h = this.group,
            c = this._data,
            f = this._progressEls,
            p = [],
            d = t.get(["pointer", "show"]),
            g = t.getModel("progress"),
            y = g.get("show"),
            x = t.getData(),
            m = x.mapDimension("value"),
            S = +t.get("min"),
            _ = +t.get("max"),
            b = [S, _],
            w = [s, l];

        function A(D, I) {
            var L = x.getItemModel(D),
                M = L.getModel("pointer"),
                P = H(M.get("width"), o.r),
                R = H(M.get("length"), o.r),
                k = t.get(["pointer", "icon"]),
                V = M.get("offsetCenter"),
                O = H(V[0], o.r),
                z = H(V[1], o.r),
                $ = M.get("keepAspect"),
                Z;
            return k ? Z = Et(k, O - P / 2, z - R, P, R, null, $) : Z = new Q_({
                shape: {
                    angle: -Math.PI / 2,
                    width: P,
                    r: R,
                    x: O,
                    y: z
                }
            }), Z.rotation = -(I + Math.PI / 2), Z.x = o.cx, Z.y = o.cy, Z
        }

        function C(D, I) {
            var L = g.get("roundCap"),
                M = L ? yu : cr,
                P = g.get("overlap"),
                R = P ? g.get("width") : v / x.count(),
                k = P ? o.r - R : o.r - (D + 1) * R,
                V = P ? o.r : o.r - D * R,
                O = new M({
                    shape: {
                        startAngle: s,
                        endAngle: I,
                        cx: o.cx,
                        cy: o.cy,
                        clockwise: u,
                        r0: k,
                        r: V
                    }
                });
            return P && (O.z2 = _ - x.get(m, D) % _), O
        }(y || d) && (x.diff(c).add(function (D) {
            var I = x.get(m, D);
            if (d) {
                var L = A(D, s);
                Yt(L, {
                    rotation: -((isNaN(+I) ? w[0] : ht(I, b, w, !0)) + Math.PI / 2)
                }, t), h.add(L), x.setItemGraphicEl(D, L)
            }
            if (y) {
                var M = C(D, s),
                    P = g.get("clip");
                Yt(M, {
                    shape: {
                        endAngle: ht(I, b, w, P)
                    }
                }, t), h.add(M), gu(t.seriesIndex, x.dataType, D, M), p[D] = M
            }
        }).update(function (D, I) {
            var L = x.get(m, D);
            if (d) {
                var M = c.getItemGraphicEl(I),
                    P = M ? M.rotation : s,
                    R = A(D, P);
                R.rotation = P, yt(R, {
                    rotation: -((isNaN(+L) ? w[0] : ht(L, b, w, !0)) + Math.PI / 2)
                }, t), h.add(R), x.setItemGraphicEl(D, R)
            }
            if (y) {
                var k = f[I],
                    V = k ? k.shape.endAngle : s,
                    O = C(D, V),
                    z = g.get("clip");
                yt(O, {
                    shape: {
                        endAngle: ht(L, b, w, z)
                    }
                }, t), h.add(O), gu(t.seriesIndex, x.dataType, D, O), p[D] = O
            }
        }).execute(), x.each(function (D) {
            var I = x.getItemModel(D),
                L = I.getModel("emphasis"),
                M = L.get("focus"),
                P = L.get("blurScope"),
                R = L.get("disabled");
            if (d) {
                var k = x.getItemGraphicEl(D),
                    V = x.getItemVisual(D, "style"),
                    O = V.fill;
                if (k instanceof ge) {
                    var z = k.style;
                    k.useStyle(W({
                        image: z.image,
                        x: z.x,
                        y: z.y,
                        width: z.width,
                        height: z.height
                    }, V))
                } else k.useStyle(V), k.type !== "pointer" && k.setColor(O);
                k.setStyle(I.getModel(["pointer", "itemStyle"]).getItemStyle()), k.style.fill === "auto" && k.setStyle("fill", n(ht(x.get(m, D), b, [0, 1], !0))), k.z2EmphasisLift = 0, ee(k, I), Tt(k, M, P, R)
            }
            if (y) {
                var $ = p[D];
                $.useStyle(x.getItemVisual(D, "style")), $.setStyle(I.getModel(["progress", "itemStyle"]).getItemStyle()), $.z2EmphasisLift = 0, ee($, I), Tt($, M, P, R)
            }
        }), this._progressEls = p)
    }, e.prototype._renderAnchor = function (t, r) {
        var i = t.getModel("anchor"),
            n = i.get("show");
        if (n) {
            var o = i.get("size"),
                s = i.get("icon"),
                l = i.get("offsetCenter"),
                u = i.get("keepAspect"),
                v = Et(s, r.cx - o / 2 + H(l[0], r.r), r.cy - o / 2 + H(l[1], r.r), o, o, null, u);
            v.z2 = i.get("showAbove") ? 1 : 0, v.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(v)
        }
    }, e.prototype._renderTitleAndDetail = function (t, r, i, n, o) {
        var s = this,
            l = t.getData(),
            u = l.mapDimension("value"),
            v = +t.get("min"),
            h = +t.get("max"),
            c = new U,
            f = [],
            p = [],
            d = t.isAnimationEnabled(),
            g = t.get(["pointer", "showAbove"]);
        l.diff(this._data).add(function (y) {
            f[y] = new ut({
                silent: !0
            }), p[y] = new ut({
                silent: !0
            })
        }).update(function (y, x) {
            f[y] = s._titleEls[x], p[y] = s._detailEls[x]
        }).execute(), l.each(function (y) {
            var x = l.getItemModel(y),
                m = l.get(u, y),
                S = new U,
                _ = n(ht(m, [v, h], [0, 1], !0)),
                b = x.getModel("title");
            if (b.get("show")) {
                var w = b.get("offsetCenter"),
                    A = o.cx + H(w[0], o.r),
                    C = o.cy + H(w[1], o.r),
                    D = f[y];
                D.attr({
                    z2: g ? 0 : 2,
                    style: mt(b, {
                        x: A,
                        y: C,
                        text: l.getName(y),
                        align: "center",
                        verticalAlign: "middle"
                    }, {
                        inheritColor: _
                    })
                }), S.add(D)
            }
            var I = x.getModel("detail");
            if (I.get("show")) {
                var L = I.get("offsetCenter"),
                    M = o.cx + H(L[0], o.r),
                    P = o.cy + H(L[1], o.r),
                    R = H(I.get("width"), o.r),
                    k = H(I.get("height"), o.r),
                    V = t.get(["progress", "show"]) ? l.getItemVisual(y, "style").fill : _,
                    D = p[y],
                    O = I.get("formatter");
                D.attr({
                    z2: g ? 0 : 2,
                    style: mt(I, {
                        x: M,
                        y: P,
                        text: si(m, O),
                        width: isNaN(R) ? null : R,
                        height: isNaN(k) ? null : k,
                        align: "center",
                        verticalAlign: "middle"
                    }, {
                        inheritColor: V
                    })
                }), gm(D, {
                    normal: I
                }, m, function ($) {
                    return si($, O)
                }), d && Hf(D, y, l, t, {
                    getFormattedLabel: function ($, Z, et, J, X, nt) {
                        return si(nt ? nt.interpolatedValue : m, O)
                    }
                }), S.add(D)
            }
            c.add(S)
        }), this.group.add(c), this._titleEls = f, this._detailEls = p
    }, e.type = "gauge", e
}(At);
const rb = eb;
var ab = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t
    }
    return e.prototype.getInitialData = function (t, r) {
        return ln(this, ["value"])
    }, e.type = "series.gauge", e.defaultOption = {
        z: 2,
        colorBy: "data",
        center: ["50%", "50%"],
        legendHoverLink: !0,
        radius: "75%",
        startAngle: 225,
        endAngle: -45,
        clockwise: !0,
        min: 0,
        max: 100,
        splitNumber: 10,
        axisLine: {
            show: !0,
            roundCap: !1,
            lineStyle: {
                color: [
                    [1, "#E6EBF8"]
                ],
                width: 10
            }
        },
        progress: {
            show: !1,
            overlap: !0,
            width: 10,
            roundCap: !1,
            clip: !0
        },
        splitLine: {
            show: !0,
            length: 10,
            distance: 10,
            lineStyle: {
                color: "#63677A",
                width: 3,
                type: "solid"
            }
        },
        axisTick: {
            show: !0,
            splitNumber: 5,
            length: 6,
            distance: 10,
            lineStyle: {
                color: "#63677A",
                width: 1,
                type: "solid"
            }
        },
        axisLabel: {
            show: !0,
            distance: 15,
            color: "#464646",
            fontSize: 12,
            rotate: 0
        },
        pointer: {
            icon: null,
            offsetCenter: [0, 0],
            show: !0,
            showAbove: !0,
            length: "60%",
            width: 6,
            keepAspect: !1
        },
        anchor: {
            show: !1,
            showAbove: !1,
            size: 6,
            icon: "circle",
            offsetCenter: [0, 0],
            keepAspect: !1,
            itemStyle: {
                color: "#fff",
                borderWidth: 0,
                borderColor: "#5470c6"
            }
        },
        title: {
            show: !0,
            offsetCenter: [0, "20%"],
            color: "#464646",
            fontSize: 16,
            valueAnimation: !1
        },
        detail: {
            show: !0,
            backgroundColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            borderColor: "#ccc",
            width: 100,
            height: null,
            padding: [5, 10],
            offsetCenter: [0, "40%"],
            color: "#464646",
            fontSize: 30,
            fontWeight: "bold",
            lineHeight: 30,
            valueAnimation: !1
        }
    }, e
}(Vt);
const ib = ab;

function nb(a) {
    a.registerChartView(rb), a.registerSeriesModel(ib)
}
var ob = ["itemStyle", "opacity"],
    sb = function (a) {
        E(e, a);

        function e(t, r) {
            var i = a.call(this) || this,
                n = i,
                o = new $e,
                s = new ut;
            return n.setTextContent(s), i.setTextGuideLine(o), i.updateData(t, r, !0), i
        }
        return e.prototype.updateData = function (t, r, i) {
            var n = this,
                o = t.hostModel,
                s = t.getItemModel(r),
                l = t.getItemLayout(r),
                u = s.getModel("emphasis"),
                v = s.get(ob);
            v = v ? ? 1, i || gr(n), n.useStyle(t.getItemVisual(r, "style")), n.style.lineJoin = "round", i ? (n.setShape({
                points: l.points
            }), n.style.opacity = 0, Yt(n, {
                style: {
                    opacity: v
                }
            }, o, r)) : yt(n, {
                style: {
                    opacity: v
                },
                shape: {
                    points: l.points
                }
            }, o, r), ee(n, s), this._updateLabel(t, r), Tt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"))
        }, e.prototype._updateLabel = function (t, r) {
            var i = this,
                n = this.getTextGuideLine(),
                o = i.getTextContent(),
                s = t.hostModel,
                l = t.getItemModel(r),
                u = t.getItemLayout(r),
                v = u.label,
                h = t.getItemVisual(r, "style"),
                c = h.fill;
            Xt(o, Gt(l), {
                labelFetcher: t.hostModel,
                labelDataIndex: r,
                defaultOpacity: h.opacity,
                defaultText: t.getName(r)
            }, {
                normal: {
                    align: v.textAlign,
                    verticalAlign: v.verticalAlign
                }
            }), i.setTextConfig({
                local: !0,
                inside: !!v.inside,
                insideStroke: c,
                outsideFill: c
            });
            var f = v.linePoints;
            n.setShape({
                points: f
            }), i.textGuideLineConfig = {
                anchor: f ? new _e(f[0][0], f[0][1]) : null
            }, yt(o, {
                style: {
                    x: v.x,
                    y: v.y
                }
            }, s, r), o.attr({
                rotation: v.rotation,
                originX: v.x,
                originY: v.y,
                z2: 10
            }), Nf(i, Gf(l), {
                stroke: c
            })
        }, e
    }(de),
    lb = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.ignoreLabelLineUpdate = !0, t
        }
        return e.prototype.render = function (t, r, i) {
            var n = t.getData(),
                o = this._data,
                s = this.group;
            n.diff(o).add(function (l) {
                var u = new sb(n, l);
                n.setItemGraphicEl(l, u), s.add(u)
            }).update(function (l, u) {
                var v = o.getItemGraphicEl(u);
                v.updateData(n, l), s.add(v), n.setItemGraphicEl(l, v)
            }).remove(function (l) {
                var u = o.getItemGraphicEl(l);
                ym(u, t, l)
            }).execute(), this._data = n
        }, e.prototype.remove = function () {
            this.group.removeAll(), this._data = null
        }, e.prototype.dispose = function () {}, e.type = "funnel", e
    }(At);
const ub = lb;
var vb = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function (t) {
        a.prototype.init.apply(this, arguments), this.legendVisualProvider = new Js(F(this.getData, this), F(this.getRawData, this)), this._defaultLabelLine(t)
    }, e.prototype.getInitialData = function (t, r) {
        return ln(this, {
            coordDimensions: ["value"],
            encodeDefaulter: K(Jf, this)
        })
    }, e.prototype._defaultLabelLine = function (t) {
        un(t, "labelLine", ["show"]);
        var r = t.labelLine,
            i = t.emphasis.labelLine;
        r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show
    }, e.prototype.getDataParams = function (t) {
        var r = this.getData(),
            i = a.prototype.getDataParams.call(this, t),
            n = r.mapDimension("value"),
            o = r.getSum(n);
        return i.percent = o ? +(r.get(n, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i
    }, e.type = "series.funnel", e.defaultOption = {
        z: 2,
        legendHoverLink: !0,
        colorBy: "data",
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        minSize: "0%",
        maxSize: "100%",
        sort: "descending",
        orient: "vertical",
        gap: 0,
        funnelAlign: "center",
        label: {
            show: !0,
            position: "outer"
        },
        labelLine: {
            show: !0,
            length: 20,
            lineStyle: {
                width: 1
            }
        },
        itemStyle: {
            borderColor: "#fff",
            borderWidth: 1
        },
        emphasis: {
            label: {
                show: !0
            }
        },
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        }
    }, e
}(Vt);
const hb = vb;

function cb(a, e) {
    return kt(a.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
    })
}

function fb(a, e) {
    for (var t = a.mapDimension("value"), r = a.mapArray(t, function (l) {
            return l
        }), i = [], n = e === "ascending", o = 0, s = a.count(); o < s; o++) i[o] = o;
    return rt(e) ? i.sort(e) : e !== "none" && i.sort(function (l, u) {
        return n ? r[l] - r[u] : r[u] - r[l]
    }), i
}

function pb(a) {
    var e = a.hostModel,
        t = e.get("orient");
    a.each(function (r) {
        var i = a.getItemModel(r),
            n = i.getModel("label"),
            o = n.get("position"),
            s = i.getModel("labelLine"),
            l = a.getItemLayout(r),
            u = l.points,
            v = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight",
            h, c, f, p;
        if (v) o === "insideLeft" ? (c = (u[0][0] + u[3][0]) / 2 + 5, f = (u[0][1] + u[3][1]) / 2, h = "left") : o === "insideRight" ? (c = (u[1][0] + u[2][0]) / 2 - 5, f = (u[1][1] + u[2][1]) / 2, h = "right") : (c = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, f = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [
            [c, f],
            [c, f]
        ];
        else {
            var d = void 0,
                g = void 0,
                y = void 0,
                x = void 0,
                m = s.get("length");
            o === "left" ? (d = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, y = d - m, c = y - 5, h = "right") : o === "right" ? (d = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, y = d + m, c = y + 5, h = "left") : o === "top" ? (d = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, x = g - m, f = x - 5, h = "center") : o === "bottom" ? (d = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, x = g + m, f = x + 5, h = "center") : o === "rightTop" ? (d = t === "horizontal" ? u[3][0] : u[1][0], g = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (x = g - m, f = x - 5, h = "center") : (y = d + m, c = y + 5, h = "top")) : o === "rightBottom" ? (d = u[2][0], g = u[2][1], t === "horizontal" ? (x = g + m, f = x + 5, h = "center") : (y = d + m, c = y + 5, h = "bottom")) : o === "leftTop" ? (d = u[0][0], g = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (x = g - m, f = x - 5, h = "center") : (y = d - m, c = y - 5, h = "right")) : o === "leftBottom" ? (d = t === "horizontal" ? u[1][0] : u[3][0], g = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (x = g + m, f = x + 5, h = "center") : (y = d - m, c = y - 5, h = "right")) : (d = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (x = g + m, f = x + 5, h = "center") : (y = d + m, c = y + 5, h = "left")), t === "horizontal" ? (y = d, c = y) : (x = g, f = x), p = [
                [d, g],
                [y, x]
            ]
        }
        l.label = {
            linePoints: p,
            x: c,
            y: f,
            verticalAlign: "middle",
            textAlign: h,
            inside: v
        }
    })
}

function db(a, e) {
    a.eachSeriesByType("funnel", function (t) {
        var r = t.getData(),
            i = r.mapDimension("value"),
            n = t.get("sort"),
            o = cb(t, e),
            s = t.get("orient"),
            l = o.width,
            u = o.height,
            v = fb(r, n),
            h = o.x,
            c = o.y,
            f = s === "horizontal" ? [H(t.get("minSize"), u), H(t.get("maxSize"), u)] : [H(t.get("minSize"), l), H(t.get("maxSize"), l)],
            p = r.getDataExtent(i),
            d = t.get("min"),
            g = t.get("max");
        d == null && (d = Math.min(p[0], 0)), g == null && (g = p[1]);
        var y = t.get("funnelAlign"),
            x = t.get("gap"),
            m = s === "horizontal" ? l : u,
            S = (m - x * (r.count() - 1)) / r.count(),
            _ = function (P, R) {
                if (s === "horizontal") {
                    var k = r.get(i, P) || 0,
                        V = ht(k, [d, g], f, !0),
                        O = void 0;
                    switch (y) {
                        case "top":
                            O = c;
                            break;
                        case "center":
                            O = c + (u - V) / 2;
                            break;
                        case "bottom":
                            O = c + (u - V);
                            break
                    }
                    return [
                        [R, O],
                        [R, O + V]
                    ]
                }
                var z = r.get(i, P) || 0,
                    $ = ht(z, [d, g], f, !0),
                    Z;
                switch (y) {
                    case "left":
                        Z = h;
                        break;
                    case "center":
                        Z = h + (l - $) / 2;
                        break;
                    case "right":
                        Z = h + l - $;
                        break
                }
                return [
                    [Z, R],
                    [Z + $, R]
                ]
            };
        n === "ascending" && (S = -S, x = -x, s === "horizontal" ? h += l : c += u, v = v.reverse());
        for (var b = 0; b < v.length; b++) {
            var w = v[b],
                A = v[b + 1],
                C = r.getItemModel(w);
            if (s === "horizontal") {
                var D = C.get(["itemStyle", "width"]);
                D == null ? D = S : (D = H(D, l), n === "ascending" && (D = -D));
                var I = _(w, h),
                    L = _(A, h + D);
                h += D + x, r.setItemLayout(w, {
                    points: I.concat(L.slice().reverse())
                })
            } else {
                var M = C.get(["itemStyle", "height"]);
                M == null ? M = S : (M = H(M, u), n === "ascending" && (M = -M));
                var I = _(w, c),
                    L = _(A, c + M);
                c += M + x, r.setItemLayout(w, {
                    points: I.concat(L.slice().reverse())
                })
            }
        }
        pb(r)
    })
}

function gb(a) {
    a.registerChartView(ub), a.registerSeriesModel(hb), a.registerLayout(db), a.registerProcessor(Qs("funnel"))
}
var yb = .3,
    mb = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._dataGroup = new U, t._initialized = !1, t
        }
        return e.prototype.init = function () {
            this.group.add(this._dataGroup)
        }, e.prototype.render = function (t, r, i, n) {
            this._progressiveEls = null;
            var o = this._dataGroup,
                s = t.getData(),
                l = this._data,
                u = t.coordinateSystem,
                v = u.dimensions,
                h = sh(t);
            s.diff(l).add(c).update(f).remove(p).execute();

            function c(g) {
                var y = oh(s, o, g, v, u);
                oo(y, s, g, h)
            }

            function f(g, y) {
                var x = l.getItemGraphicEl(y),
                    m = wd(s, g, v, u);
                s.setItemGraphicEl(g, x), yt(x, {
                    shape: {
                        points: m
                    }
                }, t, g), gr(x), oo(x, s, g, h)
            }

            function p(g) {
                var y = l.getItemGraphicEl(g);
                o.remove(y)
            }
            if (!this._initialized) {
                this._initialized = !0;
                var d = xb(u, t, function () {
                    setTimeout(function () {
                        o.removeClipPath()
                    })
                });
                o.setClipPath(d)
            }
            this._data = s
        }, e.prototype.incrementalPrepareRender = function (t, r, i) {
            this._initialized = !0, this._data = null, this._dataGroup.removeAll()
        }, e.prototype.incrementalRender = function (t, r, i) {
            for (var n = r.getData(), o = r.coordinateSystem, s = o.dimensions, l = sh(r), u = this._progressiveEls = [], v = t.start; v < t.end; v++) {
                var h = oh(n, this._dataGroup, v, s, o);
                h.incremental = !0, oo(h, n, v, l), u.push(h)
            }
        }, e.prototype.remove = function () {
            this._dataGroup && this._dataGroup.removeAll(), this._data = null
        }, e.type = "parallel", e
    }(At);

function xb(a, e, t) {
    var r = a.model,
        i = a.getRect(),
        n = new pt({
            shape: {
                x: i.x,
                y: i.y,
                width: i.width,
                height: i.height
            }
        }),
        o = r.get("layout") === "horizontal" ? "width" : "height";
    return n.setShape(o, 0), Yt(n, {
        shape: {
            width: i.width,
            height: i.height
        }
    }, e, t), n
}

function wd(a, e, t, r) {
    for (var i = [], n = 0; n < t.length; n++) {
        var o = t[n],
            s = a.get(a.mapDimension(o), e);
        Sb(s, r.getAxis(o).type) || i.push(r.dataToPoint(s, o))
    }
    return i
}

function oh(a, e, t, r, i) {
    var n = wd(a, t, r, i),
        o = new $e({
            shape: {
                points: n
            },
            z2: 10
        });
    return e.add(o), a.setItemGraphicEl(t, o), o
}

function sh(a) {
    var e = a.get("smooth", !0);
    return e === !0 && (e = yb), e = mm(e), xm(e) && (e = 0), {
        smooth: e
    }
}

function oo(a, e, t, r) {
    a.useStyle(e.getItemVisual(t, "style")), a.style.fill = null, a.setShape("smooth", r.smooth);
    var i = e.getItemModel(t),
        n = i.getModel("emphasis");
    ee(a, i, "lineStyle"), Tt(a, n.get("focus"), n.get("blurScope"), n.get("disabled"))
}

function Sb(a, e) {
    return e === "category" ? a == null : a == null || isNaN(a)
}
const _b = mb;
var bb = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t
    }
    return e.prototype.getInitialData = function (t, r) {
        return dr(null, this, {
            useEncodeDefaulter: F(wb, null, this)
        })
    }, e.prototype.getRawIndicesByActiveState = function (t) {
        var r = this.coordinateSystem,
            i = this.getData(),
            n = [];
        return r.eachActiveState(i, function (o, s) {
            t === o && n.push(i.getRawIndex(s))
        }), n
    }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = {
        z: 2,
        coordinateSystem: "parallel",
        parallelIndex: 0,
        label: {
            show: !1
        },
        inactiveOpacity: .05,
        activeOpacity: 1,
        lineStyle: {
            width: 1,
            opacity: .45,
            type: "solid"
        },
        emphasis: {
            label: {
                show: !1
            }
        },
        progressive: 500,
        smooth: !1,
        animationEasing: "linear"
    }, e
}(Vt);

function wb(a) {
    var e = a.ecModel.getComponent("parallel", a.get("parallelIndex"));
    if (e) {
        var t = {};
        return T(e.dimensions, function (r) {
            var i = Ab(r);
            t[r] = i
        }), t
    }
}

function Ab(a) {
    return +a.replace("dim", "")
}
const Tb = bb;
var Cb = ["lineStyle", "opacity"],
    Db = {
        seriesType: "parallel",
        reset: function (a, e) {
            var t = a.coordinateSystem,
                r = {
                    normal: a.get(["lineStyle", "opacity"]),
                    active: a.get("activeOpacity"),
                    inactive: a.get("inactiveOpacity")
                };
            return {
                progress: function (i, n) {
                    t.eachActiveState(n, function (o, s) {
                        var l = r[o];
                        if (o === "normal" && n.hasItemOption) {
                            var u = n.getItemModel(s).get(Cb, !0);
                            u != null && (l = u)
                        }
                        var v = n.ensureUniqueItemVisual(s, "style");
                        v.opacity = l
                    }, i.start, i.end)
                }
            }
        }
    };
const Ib = Db;

function Lb(a) {
    Mb(a), Pb(a)
}

function Mb(a) {
    if (!a.parallel) {
        var e = !1;
        T(a.series, function (t) {
            t && t.type === "parallel" && (e = !0)
        }), e && (a.parallel = [{}])
    }
}

function Pb(a) {
    var e = Wt(a.parallelAxis);
    T(e, function (t) {
        if (St(t)) {
            var r = t.parallelIndex || 0,
                i = Wt(a.parallel)[r];
            i && i.parallelAxisDefault && ct(t, i.parallelAxisDefault, !1)
        }
    })
}
var Rb = 5,
    Eb = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            this._model = t, this._api = i, this._handlers || (this._handlers = {}, T(kb, function (n, o) {
                i.getZr().on(o, this._handlers[o] = F(n, this))
            }, this)), Jr(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate")
        }, e.prototype.dispose = function (t, r) {
            Ta(this, "_throttledDispatchExpand"), T(this._handlers, function (i, n) {
                r.getZr().off(n, i)
            }), this._handlers = null
        }, e.prototype._throttledDispatchExpand = function (t) {
            this._dispatchExpand(t)
        }, e.prototype._dispatchExpand = function (t) {
            t && this._api.dispatchAction(W({
                type: "parallelAxisExpand"
            }, t))
        }, e.type = "parallel", e
    }(It),
    kb = {
        mousedown: function (a) {
            so(this, "click") && (this._mouseDownPoint = [a.offsetX, a.offsetY])
        },
        mouseup: function (a) {
            var e = this._mouseDownPoint;
            if (so(this, "click") && e) {
                var t = [a.offsetX, a.offsetY],
                    r = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
                if (r > Rb) return;
                var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([a.offsetX, a.offsetY]);
                i.behavior !== "none" && this._dispatchExpand({
                    axisExpandWindow: i.axisExpandWindow
                })
            }
            this._mouseDownPoint = null
        },
        mousemove: function (a) {
            if (!(this._mouseDownPoint || !so(this, "mousemove"))) {
                var e = this._model,
                    t = e.coordinateSystem.getSlidedAxisExpandWindow([a.offsetX, a.offsetY]),
                    r = t.behavior;
                r === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : {
                    axisExpandWindow: t.axisExpandWindow,
                    animation: r === "jump" ? null : {
                        duration: 0
                    }
                })
            }
        }
    };

function so(a, e) {
    var t = a._model;
    return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e
}
const Vb = Eb;
var Ob = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function () {
        a.prototype.init.apply(this, arguments), this.mergeOption({})
    }, e.prototype.mergeOption = function (t) {
        var r = this.option;
        t && ct(r, t, !0), this._initDimensions()
    }, e.prototype.contains = function (t, r) {
        var i = t.get("parallelIndex");
        return i != null && r.getComponent("parallel", i) === this
    }, e.prototype.setAxisExpand = function (t) {
        T(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (r) {
            t.hasOwnProperty(r) && (this.option[r] = t[r])
        }, this)
    }, e.prototype._initDimensions = function () {
        var t = this.dimensions = [],
            r = this.parallelAxisIndex = [],
            i = Dt(this.ecModel.queryComponents({
                mainType: "parallelAxis"
            }), function (n) {
                return (n.get("parallelIndex") || 0) === this.componentIndex
            }, this);
        T(i, function (n) {
            t.push("dim" + n.get("dim")), r.push(n.componentIndex)
        })
    }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = {
        z: 0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        layout: "horizontal",
        axisExpandable: !1,
        axisExpandCenter: null,
        axisExpandCount: 0,
        axisExpandWidth: 50,
        axisExpandRate: 17,
        axisExpandDebounce: 50,
        axisExpandSlideTriggerArea: [-.15, .05, .4],
        axisExpandTriggerOn: "click",
        parallelAxisDefault: null
    }, e
}(Ct);
const zb = Ob;
var Nb = function (a) {
    E(e, a);

    function e(t, r, i, n, o) {
        var s = a.call(this, t, r, i) || this;
        return s.type = n || "value", s.axisIndex = o, s
    }
    return e.prototype.isHorizontal = function () {
        return this.coordinateSystem.getModel().get("layout") !== "horizontal"
    }, e
}(ye);
const Gb = Nb;

function Sr(a, e, t, r, i, n) {
    a = a || 0;
    var o = t[1] - t[0];
    if (i != null && (i = Tr(i, [0, o])), n != null && (n = Math.max(n, i ? ? 0)), r === "all") {
        var s = Math.abs(e[1] - e[0]);
        s = Tr(s, [0, o]), i = n = Tr(s, [i, n]), r = 0
    }
    e[0] = Tr(e[0], t), e[1] = Tr(e[1], t);
    var l = lo(e, r);
    e[r] += a;
    var u = i || 0,
        v = t.slice();
    l.sign < 0 ? v[0] += u : v[1] -= u, e[r] = Tr(e[r], v);
    var h;
    return h = lo(e, r), i != null && (h.sign !== l.sign || h.span < i) && (e[1 - r] = e[r] + l.sign * i), h = lo(e, r), n != null && h.span > n && (e[1 - r] = e[r] + h.sign * n), e
}

function lo(a, e) {
    var t = a[e] - a[1 - e];
    return {
        span: Math.abs(t),
        sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
    }
}

function Tr(a, e) {
    return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, a))
}
var uo = T,
    Ad = Math.min,
    Td = Math.max,
    lh = Math.floor,
    Bb = Math.ceil,
    uh = js,
    Hb = Math.PI,
    Fb = function () {
        function a(e, t, r) {
            this.type = "parallel", this._axesMap = Q(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, r)
        }
        return a.prototype._init = function (e, t, r) {
            var i = e.dimensions,
                n = e.parallelAxisIndex;
            uo(i, function (o, s) {
                var l = n[s],
                    u = t.getComponent("parallelAxis", l),
                    v = this._axesMap.set(o, new Gb(o, en(u), [0, 0], u.get("type"), l)),
                    h = v.type === "category";
                v.onBand = h && u.get("boundaryGap"), v.inverse = u.get("inverse"), u.axis = v, v.model = u, v.coordinateSystem = u.coordinateSystem = this
            }, this)
        }, a.prototype.update = function (e, t) {
            this._updateAxesFromSeries(this._model, e)
        }, a.prototype.containPoint = function (e) {
            var t = this._makeLayoutInfo(),
                r = t.axisBase,
                i = t.layoutBase,
                n = t.pixelDimIndex,
                o = e[1 - n],
                s = e[n];
            return o >= r && o <= r + t.axisLength && s >= i && s <= i + t.layoutLength
        }, a.prototype.getModel = function () {
            return this._model
        }, a.prototype._updateAxesFromSeries = function (e, t) {
            t.eachSeries(function (r) {
                if (e.contains(r, t)) {
                    var i = r.getData();
                    uo(this.dimensions, function (n) {
                        var o = this._axesMap.get(n);
                        o.scale.unionExtentFromData(i, i.mapDimension(n)), Zr(o.scale, o.model)
                    }, this)
                }
            }, this)
        }, a.prototype.resize = function (e, t) {
            this._rect = kt(e.getBoxLayoutParams(), {
                width: t.getWidth(),
                height: t.getHeight()
            }), this._layoutAxes()
        }, a.prototype.getRect = function () {
            return this._rect
        }, a.prototype._makeLayoutInfo = function () {
            var e = this._model,
                t = this._rect,
                r = ["x", "y"],
                i = ["width", "height"],
                n = e.get("layout"),
                o = n === "horizontal" ? 0 : 1,
                s = t[i[o]],
                l = [0, s],
                u = this.dimensions.length,
                v = li(e.get("axisExpandWidth"), l),
                h = li(e.get("axisExpandCount") || 0, [0, u]),
                c = e.get("axisExpandable") && u > 3 && u > h && h > 1 && v > 0 && s > 0,
                f = e.get("axisExpandWindow"),
                p;
            if (f) p = li(f[1] - f[0], l), f[1] = f[0] + p;
            else {
                p = li(v * (h - 1), l);
                var d = e.get("axisExpandCenter") || lh(u / 2);
                f = [v * d - p / 2], f[1] = f[0] + p
            }
            var g = (s - p) / (u - h);
            g < 3 && (g = 0);
            var y = [lh(uh(f[0] / v, 1)) + 1, Bb(uh(f[1] / v, 1)) - 1],
                x = g / v * f[0];
            return {
                layout: n,
                pixelDimIndex: o,
                layoutBase: t[r[o]],
                layoutLength: s,
                axisBase: t[r[1 - o]],
                axisLength: t[i[1 - o]],
                axisExpandable: c,
                axisExpandWidth: v,
                axisCollapseWidth: g,
                axisExpandWindow: f,
                axisCount: u,
                winInnerIndices: y,
                axisExpandWindow0Pos: x
            }
        }, a.prototype._layoutAxes = function () {
            var e = this._rect,
                t = this._axesMap,
                r = this.dimensions,
                i = this._makeLayoutInfo(),
                n = i.layout;
            t.each(function (o) {
                var s = [0, i.axisLength],
                    l = o.inverse ? 1 : 0;
                o.setExtent(s[l], s[1 - l])
            }), uo(r, function (o, s) {
                var l = (i.axisExpandable ? $b : Wb)(s, i),
                    u = {
                        horizontal: {
                            x: l.position,
                            y: i.axisLength
                        },
                        vertical: {
                            x: 0,
                            y: l.position
                        }
                    },
                    v = {
                        horizontal: Hb / 2,
                        vertical: 0
                    },
                    h = [u[n].x + e.x, u[n].y + e.y],
                    c = v[n],
                    f = yr();
                Ha(f, f, c), Ge(f, f, h), this._axesLayout[o] = {
                    position: h,
                    rotation: c,
                    transform: f,
                    axisNameAvailableWidth: l.axisNameAvailableWidth,
                    axisLabelShow: l.axisLabelShow,
                    nameTruncateMaxWidth: l.nameTruncateMaxWidth,
                    tickDirection: 1,
                    labelDirection: 1
                }
            }, this)
        }, a.prototype.getAxis = function (e) {
            return this._axesMap.get(e)
        }, a.prototype.dataToPoint = function (e, t) {
            return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t)
        }, a.prototype.eachActiveState = function (e, t, r, i) {
            r == null && (r = 0), i == null && (i = e.count());
            var n = this._axesMap,
                o = this.dimensions,
                s = [],
                l = [];
            T(o, function (g) {
                s.push(e.mapDimension(g)), l.push(n.get(g).model)
            });
            for (var u = this.hasAxisBrushed(), v = r; v < i; v++) {
                var h = void 0;
                if (!u) h = "normal";
                else {
                    h = "active";
                    for (var c = e.getValues(s, v), f = 0, p = o.length; f < p; f++) {
                        var d = l[f].getActiveState(c[f]);
                        if (d === "inactive") {
                            h = "inactive";
                            break
                        }
                    }
                }
                t(h, v)
            }
        }, a.prototype.hasAxisBrushed = function () {
            for (var e = this.dimensions, t = this._axesMap, r = !1, i = 0, n = e.length; i < n; i++) t.get(e[i]).model.getActiveState() !== "normal" && (r = !0);
            return r
        }, a.prototype.axisCoordToPoint = function (e, t) {
            var r = this._axesLayout[t];
            return we([e, 0], r.transform)
        }, a.prototype.getAxisLayout = function (e) {
            return ot(this._axesLayout[e])
        }, a.prototype.getSlidedAxisExpandWindow = function (e) {
            var t = this._makeLayoutInfo(),
                r = t.pixelDimIndex,
                i = t.axisExpandWindow.slice(),
                n = i[1] - i[0],
                o = [0, t.axisExpandWidth * (t.axisCount - 1)];
            if (!this.containPoint(e)) return {
                behavior: "none",
                axisExpandWindow: i
            };
            var s = e[r] - t.layoutBase - t.axisExpandWindow0Pos,
                l, u = "slide",
                v = t.axisCollapseWidth,
                h = this._model.get("axisExpandSlideTriggerArea"),
                c = h[0] != null;
            if (v) c && v && s < n * h[0] ? (u = "jump", l = s - n * h[2]) : c && v && s > n * (1 - h[0]) ? (u = "jump", l = s - n * (1 - h[2])) : (l = s - n * h[1]) >= 0 && (l = s - n * (1 - h[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / v, l ? Sr(l, i, o, "all") : u = "none";
            else {
                var f = i[1] - i[0],
                    p = o[1] * s / f;
                i = [Td(0, p - f / 2)], i[1] = Ad(o[1], i[0] + f), i[0] = i[1] - f
            }
            return {
                axisExpandWindow: i,
                behavior: u
            }
        }, a
    }();

function li(a, e) {
    return Ad(Td(a, e[0]), e[1])
}

function Wb(a, e) {
    var t = e.layoutLength / (e.axisCount - 1);
    return {
        position: t * a,
        axisNameAvailableWidth: t,
        axisLabelShow: !0
    }
}

function $b(a, e) {
    var t = e.layoutLength,
        r = e.axisExpandWidth,
        i = e.axisCount,
        n = e.axisCollapseWidth,
        o = e.winInnerIndices,
        s, l = n,
        u = !1,
        v;
    return a < o[0] ? (s = a * n, v = n) : a <= o[1] ? (s = e.axisExpandWindow0Pos + a * r - e.axisExpandWindow[0], l = r, u = !0) : (s = t - (i - 1 - a) * n, v = n), {
        position: s,
        axisNameAvailableWidth: l,
        axisLabelShow: u,
        nameTruncateMaxWidth: v
    }
}

function Zb(a, e) {
    var t = [];
    return a.eachComponent("parallel", function (r, i) {
        var n = new Fb(r, a, e);
        n.name = "parallel_" + i, n.resize(r, e), r.coordinateSystem = n, n.model = r, t.push(n)
    }), a.eachSeries(function (r) {
        if (r.get("coordinateSystem") === "parallel") {
            var i = r.getReferringComponents("parallel", Kt).models[0];
            r.coordinateSystem = i.coordinateSystem
        }
    }), t
}
var Ub = {
    create: Zb
};
const Yb = Ub;
var Cd = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.activeIntervals = [], t
    }
    return e.prototype.getAreaSelectStyle = function () {
        return ep([
            ["fill", "color"],
            ["lineWidth", "borderWidth"],
            ["stroke", "borderColor"],
            ["width", "width"],
            ["opacity", "opacity"]
        ])(this.getModel("areaSelectStyle"))
    }, e.prototype.setActiveIntervals = function (t) {
        var r = this.activeIntervals = ot(t);
        if (r)
            for (var i = r.length - 1; i >= 0; i--) oe(r[i])
    }, e.prototype.getActiveState = function (t) {
        var r = this.activeIntervals;
        if (!r.length) return "normal";
        if (t == null || isNaN(+t)) return "inactive";
        if (r.length === 1) {
            var i = r[0];
            if (i[0] <= t && t <= i[1]) return "active"
        } else
            for (var n = 0, o = r.length; n < o; n++)
                if (r[n][0] <= t && t <= r[n][1]) return "active";
        return "inactive"
    }, e
}(Ct);
le(Cd, Ji);
const vh = Cd;
var fr = !0,
    ka = Math.min,
    Xr = Math.max,
    Xb = Math.pow,
    Kb = 1e4,
    qb = 6,
    jb = 6,
    hh = "globalPan",
    Jb = {
        w: [0, 0],
        e: [0, 1],
        n: [1, 0],
        s: [1, 1]
    },
    Qb = {
        w: "ew",
        e: "ew",
        n: "ns",
        s: "ns",
        ne: "nesw",
        sw: "nesw",
        nw: "nwse",
        se: "nwse"
    },
    ch = {
        brushStyle: {
            lineWidth: 2,
            stroke: "rgba(210,219,238,0.3)",
            fill: "#D2DBEE"
        },
        transformable: !0,
        brushMode: "single",
        removeOnClick: !1
    },
    tw = 0,
    ew = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this) || this;
            return r._track = [], r._covers = [], r._handlers = {}, r._zr = t, r.group = new U, r._uid = "brushController_" + tw++, T(lw, function (i, n) {
                this._handlers[n] = F(i, this)
            }, r), r
        }
        return e.prototype.enableBrush = function (t) {
            return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this
        }, e.prototype._doEnableBrush = function (t) {
            var r = this._zr;
            this._enableGlobalPan || mS(r, hh, this._uid), T(this._handlers, function (i, n) {
                r.on(n, i)
            }), this._brushType = t.brushType, this._brushOption = ct(ot(ch), t, !0)
        }, e.prototype._doDisableBrush = function () {
            var t = this._zr;
            xS(t, hh, this._uid), T(this._handlers, function (r, i) {
                t.off(i, r)
            }), this._brushType = this._brushOption = null
        }, e.prototype.setPanels = function (t) {
            if (t && t.length) {
                var r = this._panels = {};
                T(t, function (i) {
                    r[i.panelId] = ot(i)
                })
            } else this._panels = null;
            return this
        }, e.prototype.mount = function (t) {
            t = t || {}, this._enableGlobalPan = t.enableGlobalPan;
            var r = this.group;
            return this._zr.add(r), r.attr({
                x: t.x || 0,
                y: t.y || 0,
                rotation: t.rotation || 0,
                scaleX: t.scaleX || 1,
                scaleY: t.scaleY || 1
            }), this._transform = r.getLocalTransform(), this
        }, e.prototype.updateCovers = function (t) {
            t = G(t, function (c) {
                return ct(ot(ch), c, !0)
            });
            var r = "\0-brush-index-",
                i = this._covers,
                n = this._covers = [],
                o = this,
                s = this._creatingCover;
            return new Be(i, t, u, l).add(v).update(v).remove(h).execute(), this;

            function l(c, f) {
                return (c.id != null ? c.id : r + f) + "-" + c.brushType
            }

            function u(c, f) {
                return l(c.__brushOption, f)
            }

            function v(c, f) {
                var p = t[c];
                if (f != null && i[f] === s) n[c] = i[f];
                else {
                    var d = n[c] = f != null ? (i[f].__brushOption = p, i[f]) : Id(o, Dd(o, p));
                    Al(o, d)
                }
            }

            function h(c) {
                i[c] !== s && o.group.remove(i[c])
            }
        }, e.prototype.unmount = function () {
            return this.enableBrush(!1), Ss(this), this._zr.remove(this.group), this
        }, e.prototype.dispose = function () {
            this.unmount(), this.off()
        }, e
    }(Ys);

function Dd(a, e) {
    var t = _n[e.brushType].createCover(a, e);
    return t.__brushOption = e, Md(t, e), a.group.add(t), t
}

function Id(a, e) {
    var t = Tl(e);
    return t.endCreating && (t.endCreating(a, e), Md(e, e.__brushOption)), e
}

function Ld(a, e) {
    var t = e.__brushOption;
    Tl(e).updateCoverShape(a, e, t.range, t)
}

function Md(a, e) {
    var t = e.z;
    t == null && (t = Kb), a.traverse(function (r) {
        r.z = t, r.z2 = t
    })
}

function Al(a, e) {
    Tl(e).updateCommon(a, e), Ld(a, e)
}

function Tl(a) {
    return _n[a.__brushOption.brushType]
}

function Cl(a, e, t) {
    var r = a._panels;
    if (!r) return fr;
    var i, n = a._transform;
    return T(r, function (o) {
        o.isTargetByCursor(e, t, n) && (i = o)
    }), i
}

function Pd(a, e) {
    var t = a._panels;
    if (!t) return fr;
    var r = e.__brushOption.panelId;
    return r != null ? t[r] : fr
}

function Ss(a) {
    var e = a._covers,
        t = e.length;
    return T(e, function (r) {
        a.group.remove(r)
    }, a), e.length = 0, !!t
}

function pr(a, e) {
    var t = G(a._covers, function (r) {
        var i = r.__brushOption,
            n = ot(i.range);
        return {
            brushType: i.brushType,
            panelId: i.panelId,
            range: n
        }
    });
    a.trigger("brush", {
        areas: t,
        isEnd: !!e.isEnd,
        removeOnClick: !!e.removeOnClick
    })
}

function rw(a) {
    var e = a._track;
    if (!e.length) return !1;
    var t = e[e.length - 1],
        r = e[0],
        i = t[0] - r[0],
        n = t[1] - r[1],
        o = Xb(i * i + n * n, .5);
    return o > qb
}

function Rd(a) {
    var e = a.length - 1;
    return e < 0 && (e = 0), [a[0], a[e]]
}

function Ed(a, e, t, r) {
    var i = new U;
    return i.add(new pt({
        name: "main",
        style: Dl(t),
        silent: !0,
        draggable: !0,
        cursor: "move",
        drift: K(fh, a, e, i, ["n", "s", "w", "e"]),
        ondragend: K(pr, e, {
            isEnd: !0
        })
    })), T(r, function (n) {
        i.add(new pt({
            name: n.join(""),
            style: {
                opacity: 0
            },
            draggable: !0,
            silent: !0,
            invisible: !0,
            drift: K(fh, a, e, i, n),
            ondragend: K(pr, e, {
                isEnd: !0
            })
        }))
    }), i
}

function kd(a, e, t, r) {
    var i = r.brushStyle.lineWidth || 0,
        n = Xr(i, jb),
        o = t[0][0],
        s = t[1][0],
        l = o - i / 2,
        u = s - i / 2,
        v = t[0][1],
        h = t[1][1],
        c = v - n + i / 2,
        f = h - n + i / 2,
        p = v - o,
        d = h - s,
        g = p + i,
        y = d + i;
    me(a, e, "main", o, s, p, d), r.transformable && (me(a, e, "w", l, u, n, y), me(a, e, "e", c, u, n, y), me(a, e, "n", l, u, g, n), me(a, e, "s", l, f, g, n), me(a, e, "nw", l, u, n, n), me(a, e, "ne", c, u, n, n), me(a, e, "sw", l, f, n, n), me(a, e, "se", c, f, n, n))
}

function _s(a, e) {
    var t = e.__brushOption,
        r = t.transformable,
        i = e.childAt(0);
    i.useStyle(Dl(t)), i.attr({
        silent: !r,
        cursor: r ? "move" : "default"
    }), T([
        ["w"],
        ["e"],
        ["n"],
        ["s"],
        ["s", "e"],
        ["s", "w"],
        ["n", "e"],
        ["n", "w"]
    ], function (n) {
        var o = e.childOfName(n.join("")),
            s = n.length === 1 ? bs(a, n[0]) : iw(a, n);
        o && o.attr({
            silent: !r,
            invisible: !r,
            cursor: r ? Qb[s] + "-resize" : null
        })
    })
}

function me(a, e, t, r, i, n, o) {
    var s = e.childOfName(t);
    s && s.setShape(ow(Il(a, e, [
        [r, i],
        [r + n, i + o]
    ])))
}

function Dl(a) {
    return at({
        strokeNoScale: !0
    }, a.brushStyle)
}

function Vd(a, e, t, r) {
    var i = [ka(a, t), ka(e, r)],
        n = [Xr(a, t), Xr(e, r)];
    return [
        [i[0], n[0]],
        [i[1], n[1]]
    ]
}

function aw(a) {
    return zr(a.group)
}

function bs(a, e) {
    var t = {
            w: "left",
            e: "right",
            n: "top",
            s: "bottom"
        },
        r = {
            left: "w",
            right: "e",
            top: "n",
            bottom: "s"
        },
        i = tl(t[e], aw(a));
    return r[i]
}

function iw(a, e) {
    var t = [bs(a, e[0]), bs(a, e[1])];
    return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("")
}

function fh(a, e, t, r, i, n) {
    var o = t.__brushOption,
        s = a.toRectRange(o.range),
        l = Od(e, i, n);
    T(r, function (u) {
        var v = Jb[u];
        s[v[0]][v[1]] += l[v[0]]
    }), o.range = a.fromRectRange(Vd(s[0][0], s[1][0], s[0][1], s[1][1])), Al(e, t), pr(e, {
        isEnd: !1
    })
}

function nw(a, e, t, r) {
    var i = e.__brushOption.range,
        n = Od(a, t, r);
    T(i, function (o) {
        o[0] += n[0], o[1] += n[1]
    }), Al(a, e), pr(a, {
        isEnd: !1
    })
}

function Od(a, e, t) {
    var r = a.group,
        i = r.transformCoordToLocal(e, t),
        n = r.transformCoordToLocal(0, 0);
    return [i[0] - n[0], i[1] - n[1]]
}

function Il(a, e, t) {
    var r = Pd(a, e);
    return r && r !== fr ? r.clipPath(t, a._transform) : ot(t)
}

function ow(a) {
    var e = ka(a[0][0], a[1][0]),
        t = ka(a[0][1], a[1][1]),
        r = Xr(a[0][0], a[1][0]),
        i = Xr(a[0][1], a[1][1]);
    return {
        x: e,
        y: t,
        width: r - e,
        height: i - t
    }
}

function sw(a, e, t) {
    if (!(!a._brushType || uw(a, e.offsetX, e.offsetY))) {
        var r = a._zr,
            i = a._covers,
            n = Cl(a, e, t);
        if (!a._dragging)
            for (var o = 0; o < i.length; o++) {
                var s = i[o].__brushOption;
                if (n && (n === fr || s.panelId === n.panelId) && _n[s.brushType].contain(i[o], t[0], t[1])) return
            }
        n && r.setCursorStyle("crosshair")
    }
}

function ws(a) {
    var e = a.event;
    e.preventDefault && e.preventDefault()
}

function As(a, e, t) {
    return a.childOfName("main").contain(e, t)
}

function zd(a, e, t, r) {
    var i = a._creatingCover,
        n = a._creatingPanel,
        o = a._brushOption,
        s;
    if (a._track.push(t.slice()), rw(a) || i) {
        if (n && !i) {
            o.brushMode === "single" && Ss(a);
            var l = ot(o);
            l.brushType = ph(l.brushType, n), l.panelId = n === fr ? null : n.panelId, i = a._creatingCover = Dd(a, l), a._covers.push(i)
        }
        if (i) {
            var u = _n[ph(a._brushType, n)],
                v = i.__brushOption;
            v.range = u.getCreatingRange(Il(a, i, a._track)), r && (Id(a, i), u.updateCommon(a, i)), Ld(a, i), s = {
                isEnd: r
            }
        }
    } else r && o.brushMode === "single" && o.removeOnClick && Cl(a, e, t) && Ss(a) && (s = {
        isEnd: r,
        removeOnClick: !0
    });
    return s
}

function ph(a, e) {
    return a === "auto" ? e.defaultBrushType : a
}
var lw = {
    mousedown: function (a) {
        if (this._dragging) dh(this, a);
        else if (!a.target || !a.target.draggable) {
            ws(a);
            var e = this.group.transformCoordToLocal(a.offsetX, a.offsetY);
            this._creatingCover = null;
            var t = this._creatingPanel = Cl(this, a, e);
            t && (this._dragging = !0, this._track = [e.slice()])
        }
    },
    mousemove: function (a) {
        var e = a.offsetX,
            t = a.offsetY,
            r = this.group.transformCoordToLocal(e, t);
        if (sw(this, a, r), this._dragging) {
            ws(a);
            var i = zd(this, a, r, !1);
            i && pr(this, i)
        }
    },
    mouseup: function (a) {
        dh(this, a)
    }
};

function dh(a, e) {
    if (a._dragging) {
        ws(e);
        var t = e.offsetX,
            r = e.offsetY,
            i = a.group.transformCoordToLocal(t, r),
            n = zd(a, e, i, !0);
        a._dragging = !1, a._track = [], a._creatingCover = null, n && pr(a, n)
    }
}

function uw(a, e, t) {
    var r = a._zr;
    return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight()
}
var _n = {
    lineX: gh(0),
    lineY: gh(1),
    rect: {
        createCover: function (a, e) {
            function t(r) {
                return r
            }
            return Ed({
                toRectRange: t,
                fromRectRange: t
            }, a, e, [
                ["w"],
                ["e"],
                ["n"],
                ["s"],
                ["s", "e"],
                ["s", "w"],
                ["n", "e"],
                ["n", "w"]
            ])
        },
        getCreatingRange: function (a) {
            var e = Rd(a);
            return Vd(e[1][0], e[1][1], e[0][0], e[0][1])
        },
        updateCoverShape: function (a, e, t, r) {
            kd(a, e, t, r)
        },
        updateCommon: _s,
        contain: As
    },
    polygon: {
        createCover: function (a, e) {
            var t = new U;
            return t.add(new $e({
                name: "main",
                style: Dl(e),
                silent: !0
            })), t
        },
        getCreatingRange: function (a) {
            return a
        },
        endCreating: function (a, e) {
            e.remove(e.childAt(0)), e.add(new de({
                name: "main",
                draggable: !0,
                drift: K(nw, a, e),
                ondragend: K(pr, a, {
                    isEnd: !0
                })
            }))
        },
        updateCoverShape: function (a, e, t, r) {
            e.childAt(0).setShape({
                points: Il(a, e, t)
            })
        },
        updateCommon: _s,
        contain: As
    }
};

function gh(a) {
    return {
        createCover: function (e, t) {
            return Ed({
                toRectRange: function (r) {
                    var i = [r, [0, 100]];
                    return a && i.reverse(), i
                },
                fromRectRange: function (r) {
                    return r[a]
                }
            }, e, t, [
                [
                    ["w"],
                    ["e"]
                ],
                [
                    ["n"],
                    ["s"]
                ]
            ][a])
        },
        getCreatingRange: function (e) {
            var t = Rd(e),
                r = ka(t[0][a], t[1][a]),
                i = Xr(t[0][a], t[1][a]);
            return [r, i]
        },
        updateCoverShape: function (e, t, r, i) {
            var n, o = Pd(e, t);
            if (o !== fr && o.getLinearBrushOtherExtent) n = o.getLinearBrushOtherExtent(a);
            else {
                var s = e._zr;
                n = [0, [s.getWidth(), s.getHeight()][1 - a]]
            }
            var l = [r, n];
            a && l.reverse(), kd(e, t, l, i)
        },
        updateCommon: _s,
        contain: As
    }
}
const Ll = ew;

function Nd(a) {
    return a = Ml(a),
        function (e) {
            return Sm(e, a)
        }
}

function Gd(a, e) {
    return a = Ml(a),
        function (t) {
            var r = e ? ? t,
                i = r ? a.width : a.height,
                n = r ? a.x : a.y;
            return [n, n + (i || 0)]
        }
}

function Bd(a, e, t) {
    var r = Ml(a);
    return function (i, n) {
        return r.contain(n[0], n[1]) && !yn(i, e, t)
    }
}

function Ml(a) {
    return gt.create(a)
}
var vw = ["axisLine", "axisTickLabel", "axisName"],
    hw = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function (t, r) {
            a.prototype.init.apply(this, arguments), (this._brushController = new Ll(r.getZr())).on("brush", F(this._onBrush, this))
        }, e.prototype.render = function (t, r, i, n) {
            if (!cw(t, r, n)) {
                this.axisModel = t, this.api = i, this.group.removeAll();
                var o = this._axisGroup;
                if (this._axisGroup = new U, this.group.add(this._axisGroup), !!t.get("show")) {
                    var s = pw(t, r),
                        l = s.coordinateSystem,
                        u = t.getAreaSelectStyle(),
                        v = u.width,
                        h = t.axis.dim,
                        c = l.getAxisLayout(h),
                        f = W({
                            strokeContainThreshold: v
                        }, c),
                        p = new ze(t, f);
                    T(vw, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(f, u, t, s, v, i), rn(o, this._axisGroup, t)
                }
            }
        }, e.prototype._refreshBrushController = function (t, r, i, n, o, s) {
            var l = i.axis.getExtent(),
                u = l[1] - l[0],
                v = Math.min(30, Math.abs(u) * .1),
                h = gt.create({
                    x: l[0],
                    y: -o / 2,
                    width: u,
                    height: o
                });
            h.x -= v, h.width += 2 * v, this._brushController.mount({
                enableGlobalPan: !0,
                rotation: t.rotation,
                x: t.position[0],
                y: t.position[1]
            }).setPanels([{
                panelId: "pl",
                clipPath: Nd(h),
                isTargetByCursor: Bd(h, s, n),
                getLinearBrushOtherExtent: Gd(h, 0)
            }]).enableBrush({
                brushType: "lineX",
                brushStyle: r,
                removeOnClick: !0
            }).updateCovers(fw(i))
        }, e.prototype._onBrush = function (t) {
            var r = t.areas,
                i = this.axisModel,
                n = i.axis,
                o = G(r, function (s) {
                    return [n.coordToData(s.range[0], !0), n.coordToData(s.range[1], !0)]
                });
            (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
                type: "axisAreaSelect",
                parallelAxisId: i.id,
                intervals: o
            })
        }, e.prototype.dispose = function () {
            this._brushController.dispose()
        }, e.type = "parallelAxis", e
    }(It);

function cw(a, e, t) {
    return t && t.type === "axisAreaSelect" && e.findComponents({
        mainType: "parallelAxis",
        query: t
    })[0] === a
}

function fw(a) {
    var e = a.axis;
    return G(a.activeIntervals, function (t) {
        return {
            brushType: "lineX",
            panelId: "pl",
            range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
        }
    })
}

function pw(a, e) {
    return e.getComponent("parallel", a.get("parallelIndex"))
}
const dw = hw;
var gw = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
};

function yw(a) {
    a.registerAction(gw, function (e, t) {
        t.eachComponent({
            mainType: "parallelAxis",
            query: e
        }, function (r) {
            r.axis.model.setActiveIntervals(e.intervals)
        })
    }), a.registerAction("parallelAxisExpand", function (e, t) {
        t.eachComponent({
            mainType: "parallel",
            query: e
        }, function (r) {
            r.setAxisExpand(e)
        })
    })
}
var mw = {
    type: "value",
    areaSelectStyle: {
        width: 20,
        borderWidth: 1,
        borderColor: "rgba(160,197,232)",
        color: "rgba(160,197,232)",
        opacity: .3
    },
    realtime: !0,
    z: 10
};

function Hd(a) {
    a.registerComponentView(Vb), a.registerComponentModel(zb), a.registerCoordinateSystem("parallel", Yb), a.registerPreprocessor(Lb), a.registerComponentModel(vh), a.registerComponentView(dw), Yr(a, "parallel", vh, mw), yw(a)
}

function xw(a) {
    j(Hd), a.registerChartView(_b), a.registerSeriesModel(Tb), a.registerVisual(a.PRIORITY.VISUAL.BRUSH, Ib)
}
var Sw = function () {
        function a() {
            this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0
        }
        return a
    }(),
    _w = function (a) {
        E(e, a);

        function e(t) {
            return a.call(this, t) || this
        }
        return e.prototype.getDefaultShape = function () {
            return new Sw
        }, e.prototype.buildPath = function (t, r) {
            var i = r.extent;
            t.moveTo(r.x1, r.y1), t.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (t.lineTo(r.x2 + i, r.y2), t.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (t.lineTo(r.x2, r.y2 + i), t.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), t.closePath()
        }, e.prototype.highlight = function () {
            Br(this)
        }, e.prototype.downplay = function () {
            Hr(this)
        }, e
    }(Pt),
    bw = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._focusAdjacencyDisabled = !1, t
        }
        return e.prototype.render = function (t, r, i) {
            var n = this,
                o = t.getGraph(),
                s = this.group,
                l = t.layoutInfo,
                u = l.width,
                v = l.height,
                h = t.getData(),
                c = t.getData("edge"),
                f = t.get("orient");
            this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function (p) {
                var d = new _w,
                    g = tt(d);
                g.dataIndex = p.dataIndex, g.seriesIndex = t.seriesIndex, g.dataType = "edge";
                var y = p.getModel(),
                    x = y.getModel("lineStyle"),
                    m = x.get("curveness"),
                    S = p.node1.getLayout(),
                    _ = p.node1.getModel(),
                    b = _.get("localX"),
                    w = _.get("localY"),
                    A = p.node2.getLayout(),
                    C = p.node2.getModel(),
                    D = C.get("localX"),
                    I = C.get("localY"),
                    L = p.getLayout(),
                    M, P, R, k, V, O, z, $;
                d.shape.extent = Math.max(1, L.dy), d.shape.orient = f, f === "vertical" ? (M = (b != null ? b * u : S.x) + L.sy, P = (w != null ? w * v : S.y) + S.dy, R = (D != null ? D * u : A.x) + L.ty, k = I != null ? I * v : A.y, V = M, O = P * (1 - m) + k * m, z = R, $ = P * m + k * (1 - m)) : (M = (b != null ? b * u : S.x) + S.dx, P = (w != null ? w * v : S.y) + L.sy, R = D != null ? D * u : A.x, k = (I != null ? I * v : A.y) + L.ty, V = M * (1 - m) + R * m, O = P, z = M * m + R * (1 - m), $ = k), d.setShape({
                    x1: M,
                    y1: P,
                    x2: R,
                    y2: k,
                    cpx1: V,
                    cpy1: O,
                    cpx2: z,
                    cpy2: $
                }), d.useStyle(x.getItemStyle()), yh(d.style, f, p);
                var Z = "" + y.get("value"),
                    et = Gt(y, "edgeLabel");
                Xt(d, et, {
                    labelFetcher: {
                        getFormattedLabel: function (nt, st, it, Y, vt, lt) {
                            return t.getFormattedLabel(nt, st, "edge", Y, Wa(vt, et.normal && et.normal.get("formatter"), Z), lt)
                        }
                    },
                    labelDataIndex: p.dataIndex,
                    defaultText: Z
                }), d.setTextConfig({
                    position: "inside"
                });
                var J = y.getModel("emphasis");
                ee(d, y, "lineStyle", function (nt) {
                    var st = nt.getItemStyle();
                    return yh(st, f, p), st
                }), s.add(d), c.setItemGraphicEl(p.dataIndex, d);
                var X = J.get("focus");
                Tt(d, X === "adjacency" ? p.getAdjacentDataIndices() : X === "trajectory" ? p.getTrajectoryDataIndices() : X, J.get("blurScope"), J.get("disabled"))
            }), o.eachNode(function (p) {
                var d = p.getLayout(),
                    g = p.getModel(),
                    y = g.get("localX"),
                    x = g.get("localY"),
                    m = g.getModel("emphasis"),
                    S = new pt({
                        shape: {
                            x: y != null ? y * u : d.x,
                            y: x != null ? x * v : d.y,
                            width: d.dx,
                            height: d.dy
                        },
                        style: g.getModel("itemStyle").getItemStyle(),
                        z2: 10
                    });
                Xt(S, Gt(g), {
                    labelFetcher: {
                        getFormattedLabel: function (b, w) {
                            return t.getFormattedLabel(b, w, "node")
                        }
                    },
                    labelDataIndex: p.dataIndex,
                    defaultText: p.id
                }), S.disableLabelAnimation = !0, S.setStyle("fill", p.getVisual("color")), S.setStyle("decal", p.getVisual("style").decal), ee(S, g), s.add(S), h.setItemGraphicEl(p.dataIndex, S), tt(S).dataType = "node";
                var _ = m.get("focus");
                Tt(S, _ === "adjacency" ? p.getAdjacentDataIndices() : _ === "trajectory" ? p.getTrajectoryDataIndices() : _, m.get("blurScope"), m.get("disabled"))
            }), h.eachItemGraphicEl(function (p, d) {
                var g = h.getItemModel(d);
                g.get("draggable") && (p.drift = function (y, x) {
                    n._focusAdjacencyDisabled = !0, this.shape.x += y, this.shape.y += x, this.dirty(), i.dispatchAction({
                        type: "dragNode",
                        seriesId: t.id,
                        dataIndex: h.getRawIndex(d),
                        localX: this.shape.x / u,
                        localY: this.shape.y / v
                    })
                }, p.ondragend = function () {
                    n._focusAdjacencyDisabled = !1
                }, p.draggable = !0, p.cursor = "move")
            }), !this._data && t.isAnimationEnabled() && s.setClipPath(ww(s.getBoundingRect(), t, function () {
                s.removeClipPath()
            })), this._data = t.getData()
        }, e.prototype.dispose = function () {}, e.type = "sankey", e
    }(At);

function yh(a, e, t) {
    switch (a.fill) {
        case "source":
            a.fill = t.node1.getVisual("color"), a.decal = t.node1.getVisual("style").decal;
            break;
        case "target":
            a.fill = t.node2.getVisual("color"), a.decal = t.node2.getVisual("style").decal;
            break;
        case "gradient":
            var r = t.node1.getVisual("color"),
                i = t.node2.getVisual("color");
            q(r) && q(i) && (a.fill = new qi(0, 0, +(e === "horizontal"), +(e === "vertical"), [{
                color: r,
                offset: 0
            }, {
                color: i,
                offset: 1
            }]))
    }
}

function ww(a, e, t) {
    var r = new pt({
        shape: {
            x: a.x - 10,
            y: a.y - 10,
            width: 0,
            height: a.height + 20
        }
    });
    return Yt(r, {
        shape: {
            width: a.width + 20
        }
    }, e, t), r
}
const Aw = bw;
var Tw = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.getInitialData = function (t, r) {
        var i = t.edges || t.links,
            n = t.data || t.nodes,
            o = t.levels;
        this.levelModels = [];
        for (var s = this.levelModels, l = 0; l < o.length; l++) o[l].depth != null && o[l].depth >= 0 && (s[o[l].depth] = new Rt(o[l], this, r));
        if (n && i) {
            var u = bd(n, i, this, !0, v);
            return u.data
        }

        function v(h, c) {
            h.wrapMethod("getItemModel", function (f, p) {
                var d = f.parentModel,
                    g = d.getData().getItemLayout(p);
                if (g) {
                    var y = g.depth,
                        x = d.levelModels[y];
                    x && (f.parentModel = x)
                }
                return f
            }), c.wrapMethod("getItemModel", function (f, p) {
                var d = f.parentModel,
                    g = d.getGraph().getEdgeByIndex(p),
                    y = g.node1.getLayout();
                if (y) {
                    var x = y.depth,
                        m = d.levelModels[x];
                    m && (f.parentModel = m)
                }
                return f
            })
        }
    }, e.prototype.setNodePosition = function (t, r) {
        var i = this.option.data || this.option.nodes,
            n = i[t];
        n.localX = r[0], n.localY = r[1]
    }, e.prototype.getGraph = function () {
        return this.getData().graph
    }, e.prototype.getEdgeData = function () {
        return this.getGraph().edgeData
    }, e.prototype.formatTooltip = function (t, r, i) {
        function n(f) {
            return isNaN(f) || f == null
        }
        if (i === "edge") {
            var o = this.getDataParams(t, i),
                s = o.data,
                l = o.value,
                u = s.source + " -- " + s.target;
            return qt("nameValue", {
                name: u,
                value: l,
                noValue: n(l)
            })
        } else {
            var v = this.getGraph().getNodeByIndex(t),
                h = v.getLayout().value,
                c = this.getDataParams(t, i).data.name;
            return qt("nameValue", {
                name: c != null ? c + "" : null,
                value: h,
                noValue: n(h)
            })
        }
    }, e.prototype.optionUpdated = function () {}, e.prototype.getDataParams = function (t, r) {
        var i = a.prototype.getDataParams.call(this, t, r);
        if (i.value == null && r === "node") {
            var n = this.getGraph().getNodeByIndex(t),
                o = n.getLayout().value;
            i.value = o
        }
        return i
    }, e.type = "series.sankey", e.defaultOption = {
        z: 2,
        coordinateSystem: "view",
        left: "5%",
        top: "5%",
        right: "20%",
        bottom: "5%",
        orient: "horizontal",
        nodeWidth: 20,
        nodeGap: 8,
        draggable: !0,
        layoutIterations: 32,
        label: {
            show: !0,
            position: "right",
            fontSize: 12
        },
        edgeLabel: {
            show: !1,
            fontSize: 12
        },
        levels: [],
        nodeAlign: "justify",
        lineStyle: {
            color: "#314656",
            opacity: .2,
            curveness: .5
        },
        emphasis: {
            label: {
                show: !0
            },
            lineStyle: {
                opacity: .5
            }
        },
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        },
        animationEasing: "linear",
        animationDuration: 1e3
    }, e
}(Vt);
const Cw = Tw;

function Dw(a, e) {
    a.eachSeriesByType("sankey", function (t) {
        var r = t.get("nodeWidth"),
            i = t.get("nodeGap"),
            n = Iw(t, e);
        t.layoutInfo = n;
        var o = n.width,
            s = n.height,
            l = t.getGraph(),
            u = l.nodes,
            v = l.edges;
        Mw(u);
        var h = Dt(u, function (d) {
                return d.getLayout().value === 0
            }),
            c = h.length !== 0 ? 0 : t.get("layoutIterations"),
            f = t.get("orient"),
            p = t.get("nodeAlign");
        Lw(u, v, r, i, o, s, c, f, p)
    })
}

function Iw(a, e) {
    return kt(a.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
    })
}

function Lw(a, e, t, r, i, n, o, s, l) {
    Pw(a, e, t, i, n, s, l), Vw(a, e, n, i, r, o, s), $w(a, s)
}

function Mw(a) {
    T(a, function (e) {
        var t = Oe(e.outEdges, Oi),
            r = Oe(e.inEdges, Oi),
            i = e.getValue() || 0,
            n = Math.max(t, r, i);
        e.setLayout({
            value: n
        }, !0)
    })
}

function Pw(a, e, t, r, i, n, o) {
    for (var s = [], l = [], u = [], v = [], h = 0, c = 0; c < e.length; c++) s[c] = 1;
    for (var c = 0; c < a.length; c++) l[c] = a[c].inEdges.length, l[c] === 0 && u.push(a[c]);
    for (var f = -1; u.length;) {
        for (var p = 0; p < u.length; p++) {
            var d = u[p],
                g = d.hostGraph.data.getRawDataItem(d.dataIndex),
                y = g.depth != null && g.depth >= 0;
            y && g.depth > f && (f = g.depth), d.setLayout({
                depth: y ? g.depth : h
            }, !0), n === "vertical" ? d.setLayout({
                dy: t
            }, !0) : d.setLayout({
                dx: t
            }, !0);
            for (var x = 0; x < d.outEdges.length; x++) {
                var m = d.outEdges[x],
                    S = e.indexOf(m);
                s[S] = 0;
                var _ = m.node2,
                    b = a.indexOf(_);
                --l[b] === 0 && v.indexOf(_) < 0 && v.push(_)
            }
        }++h, u = v, v = []
    }
    for (var c = 0; c < s.length; c++)
        if (s[c] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
    var w = f > h - 1 ? f : h - 1;
    o && o !== "left" && Rw(a, o, n, w);
    var A = n === "vertical" ? (i - t) / w : (r - t) / w;
    kw(a, A, n)
}

function Fd(a) {
    var e = a.hostGraph.data.getRawDataItem(a.dataIndex);
    return e.depth != null && e.depth >= 0
}

function Rw(a, e, t, r) {
    if (e === "right") {
        for (var i = [], n = a, o = 0; n.length;) {
            for (var s = 0; s < n.length; s++) {
                var l = n[s];
                l.setLayout({
                    skNodeHeight: o
                }, !0);
                for (var u = 0; u < l.inEdges.length; u++) {
                    var v = l.inEdges[u];
                    i.indexOf(v.node1) < 0 && i.push(v.node1)
                }
            }
            n = i, i = [], ++o
        }
        T(a, function (h) {
            Fd(h) || h.setLayout({
                depth: Math.max(0, r - h.getLayout().skNodeHeight)
            }, !0)
        })
    } else e === "justify" && Ew(a, r)
}

function Ew(a, e) {
    T(a, function (t) {
        !Fd(t) && !t.outEdges.length && t.setLayout({
            depth: e
        }, !0)
    })
}

function kw(a, e, t) {
    T(a, function (r) {
        var i = r.getLayout().depth * e;
        t === "vertical" ? r.setLayout({
            y: i
        }, !0) : r.setLayout({
            x: i
        }, !0)
    })
}

function Vw(a, e, t, r, i, n, o) {
    var s = Ow(a, o);
    zw(s, e, t, r, i, o), vo(s, i, t, r, o);
    for (var l = 1; n > 0; n--) l *= .99, Nw(s, l, o), vo(s, i, t, r, o), Ww(s, l, o), vo(s, i, t, r, o)
}

function Ow(a, e) {
    var t = [],
        r = e === "vertical" ? "y" : "x",
        i = Qo(a, function (n) {
            return n.getLayout()[r]
        });
    return i.keys.sort(function (n, o) {
        return n - o
    }), T(i.keys, function (n) {
        t.push(i.buckets.get(n))
    }), t
}

function zw(a, e, t, r, i, n) {
    var o = 1 / 0;
    T(a, function (s) {
        var l = s.length,
            u = 0;
        T(s, function (h) {
            u += h.getLayout().value
        });
        var v = n === "vertical" ? (r - (l - 1) * i) / u : (t - (l - 1) * i) / u;
        v < o && (o = v)
    }), T(a, function (s) {
        T(s, function (l, u) {
            var v = l.getLayout().value * o;
            n === "vertical" ? (l.setLayout({
                x: u
            }, !0), l.setLayout({
                dx: v
            }, !0)) : (l.setLayout({
                y: u
            }, !0), l.setLayout({
                dy: v
            }, !0))
        })
    }), T(e, function (s) {
        var l = +s.getValue() * o;
        s.setLayout({
            dy: l
        }, !0)
    })
}

function vo(a, e, t, r, i) {
    var n = i === "vertical" ? "x" : "y";
    T(a, function (o) {
        o.sort(function (d, g) {
            return d.getLayout()[n] - g.getLayout()[n]
        });
        for (var s, l, u, v = 0, h = o.length, c = i === "vertical" ? "dx" : "dy", f = 0; f < h; f++) l = o[f], u = v - l.getLayout()[n], u > 0 && (s = l.getLayout()[n] + u, i === "vertical" ? l.setLayout({
            x: s
        }, !0) : l.setLayout({
            y: s
        }, !0)), v = l.getLayout()[n] + l.getLayout()[c] + e;
        var p = i === "vertical" ? r : t;
        if (u = v - e - p, u > 0) {
            s = l.getLayout()[n] - u, i === "vertical" ? l.setLayout({
                x: s
            }, !0) : l.setLayout({
                y: s
            }, !0), v = s;
            for (var f = h - 2; f >= 0; --f) l = o[f], u = l.getLayout()[n] + l.getLayout()[c] + e - v, u > 0 && (s = l.getLayout()[n] - u, i === "vertical" ? l.setLayout({
                x: s
            }, !0) : l.setLayout({
                y: s
            }, !0)), v = l.getLayout()[n]
        }
    })
}

function Nw(a, e, t) {
    T(a.slice().reverse(), function (r) {
        T(r, function (i) {
            if (i.outEdges.length) {
                var n = Oe(i.outEdges, Gw, t) / Oe(i.outEdges, Oi);
                if (isNaN(n)) {
                    var o = i.outEdges.length;
                    n = o ? Oe(i.outEdges, Bw, t) / o : 0
                }
                if (t === "vertical") {
                    var s = i.getLayout().x + (n - He(i, t)) * e;
                    i.setLayout({
                        x: s
                    }, !0)
                } else {
                    var l = i.getLayout().y + (n - He(i, t)) * e;
                    i.setLayout({
                        y: l
                    }, !0)
                }
            }
        })
    })
}

function Gw(a, e) {
    return He(a.node2, e) * a.getValue()
}

function Bw(a, e) {
    return He(a.node2, e)
}

function Hw(a, e) {
    return He(a.node1, e) * a.getValue()
}

function Fw(a, e) {
    return He(a.node1, e)
}

function He(a, e) {
    return e === "vertical" ? a.getLayout().x + a.getLayout().dx / 2 : a.getLayout().y + a.getLayout().dy / 2
}

function Oi(a) {
    return a.getValue()
}

function Oe(a, e, t) {
    for (var r = 0, i = a.length, n = -1; ++n < i;) {
        var o = +e(a[n], t);
        isNaN(o) || (r += o)
    }
    return r
}

function Ww(a, e, t) {
    T(a, function (r) {
        T(r, function (i) {
            if (i.inEdges.length) {
                var n = Oe(i.inEdges, Hw, t) / Oe(i.inEdges, Oi);
                if (isNaN(n)) {
                    var o = i.inEdges.length;
                    n = o ? Oe(i.inEdges, Fw, t) / o : 0
                }
                if (t === "vertical") {
                    var s = i.getLayout().x + (n - He(i, t)) * e;
                    i.setLayout({
                        x: s
                    }, !0)
                } else {
                    var l = i.getLayout().y + (n - He(i, t)) * e;
                    i.setLayout({
                        y: l
                    }, !0)
                }
            }
        })
    })
}

function $w(a, e) {
    var t = e === "vertical" ? "x" : "y";
    T(a, function (r) {
        r.outEdges.sort(function (i, n) {
            return i.node2.getLayout()[t] - n.node2.getLayout()[t]
        }), r.inEdges.sort(function (i, n) {
            return i.node1.getLayout()[t] - n.node1.getLayout()[t]
        })
    }), T(a, function (r) {
        var i = 0,
            n = 0;
        T(r.outEdges, function (o) {
            o.setLayout({
                sy: i
            }, !0), i += o.getLayout().dy
        }), T(r.inEdges, function (o) {
            o.setLayout({
                ty: n
            }, !0), n += o.getLayout().dy
        })
    })
}

function Zw(a) {
    a.eachSeriesByType("sankey", function (e) {
        var t = e.getGraph(),
            r = t.nodes,
            i = t.edges;
        if (r.length) {
            var n = 1 / 0,
                o = -1 / 0;
            T(r, function (s) {
                var l = s.getLayout().value;
                l < n && (n = l), l > o && (o = l)
            }), T(r, function (s) {
                var l = new Ot({
                        type: "color",
                        mappingMethod: "linear",
                        dataExtent: [n, o],
                        visual: e.get("color")
                    }),
                    u = l.mapValueToVisual(s.getLayout().value),
                    v = s.getModel().get(["itemStyle", "color"]);
                v != null ? (s.setVisual("color", v), s.setVisual("style", {
                    fill: v
                })) : (s.setVisual("color", u), s.setVisual("style", {
                    fill: u
                }))
            })
        }
        i.length && T(i, function (s) {
            var l = s.getModel().get("lineStyle");
            s.setVisual("style", l)
        })
    })
}

function Uw(a) {
    a.registerChartView(Aw), a.registerSeriesModel(Cw), a.registerLayout(Dw), a.registerVisual(Zw), a.registerAction({
        type: "dragNode",
        event: "dragnode",
        update: "update"
    }, function (e, t) {
        t.eachComponent({
            mainType: "series",
            subType: "sankey",
            query: e
        }, function (r) {
            r.setNodePosition(e.dataIndex, [e.localX, e.localY])
        })
    })
}
var Wd = function () {
        function a() {}
        return a.prototype.getInitialData = function (e, t) {
            var r, i = t.getComponent("xAxis", this.get("xAxisIndex")),
                n = t.getComponent("yAxis", this.get("yAxisIndex")),
                o = i.get("type"),
                s = n.get("type"),
                l;
            o === "category" ? (e.layout = "horizontal", r = i.getOrdinalMeta(), l = !0) : s === "category" ? (e.layout = "vertical", r = n.getOrdinalMeta(), l = !0) : e.layout = e.layout || "horizontal";
            var u = ["x", "y"],
                v = e.layout === "horizontal" ? 0 : 1,
                h = this._baseAxisDim = u[v],
                c = u[1 - v],
                f = [i, n],
                p = f[v].get("type"),
                d = f[1 - v].get("type"),
                g = e.data;
            if (g && l) {
                var y = [];
                T(g, function (S, _) {
                    var b;
                    B(S) ? (b = S.slice(), S.unshift(_)) : B(S.value) ? (b = W({}, S), b.value = b.value.slice(), S.value.unshift(_)) : b = S, y.push(b)
                }), e.data = y
            }
            var x = this.defaultValueDimensions,
                m = [{
                    name: h,
                    type: ts(p),
                    ordinalMeta: r,
                    otherDims: {
                        tooltip: !1,
                        itemName: 0
                    },
                    dimsDef: ["base"]
                }, {
                    name: c,
                    type: ts(d),
                    dimsDef: x.slice()
                }];
            return ln(this, {
                coordDimensions: m,
                dimensionsCount: x.length + 1,
                encodeDefaulter: K(_m, m, this)
            })
        }, a.prototype.getBaseAxis = function () {
            var e = this._baseAxisDim;
            return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis
        }, a
    }(),
    $d = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.defaultValueDimensions = [{
                name: "min",
                defaultTooltip: !0
            }, {
                name: "Q1",
                defaultTooltip: !0
            }, {
                name: "median",
                defaultTooltip: !0
            }, {
                name: "Q3",
                defaultTooltip: !0
            }, {
                name: "max",
                defaultTooltip: !0
            }], t.visualDrawType = "stroke", t
        }
        return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            layout: null,
            boxWidth: [7, 50],
            itemStyle: {
                color: "#fff",
                borderWidth: 1
            },
            emphasis: {
                scale: !0,
                itemStyle: {
                    borderWidth: 2,
                    shadowBlur: 5,
                    shadowOffsetX: 1,
                    shadowOffsetY: 1,
                    shadowColor: "rgba(0,0,0,0.2)"
                }
            },
            animationDuration: 800
        }, e
    }(Vt);
le($d, Wd, !0);
const Yw = $d;
var Xw = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            var n = t.getData(),
                o = this.group,
                s = this._data;
            this._data || o.removeAll();
            var l = t.get("layout") === "horizontal" ? 1 : 0;
            n.diff(s).add(function (u) {
                if (n.hasValue(u)) {
                    var v = n.getItemLayout(u),
                        h = mh(v, n, u, l, !0);
                    n.setItemGraphicEl(u, h), o.add(h)
                }
            }).update(function (u, v) {
                var h = s.getItemGraphicEl(v);
                if (!n.hasValue(u)) {
                    o.remove(h);
                    return
                }
                var c = n.getItemLayout(u);
                h ? (gr(h), Zd(c, h, n, u)) : h = mh(c, n, u, l), o.add(h), n.setItemGraphicEl(u, h)
            }).remove(function (u) {
                var v = s.getItemGraphicEl(u);
                v && o.remove(v)
            }).execute(), this._data = n
        }, e.prototype.remove = function (t) {
            var r = this.group,
                i = this._data;
            this._data = null, i && i.eachItemGraphicEl(function (n) {
                n && r.remove(n)
            })
        }, e.type = "boxplot", e
    }(At),
    Kw = function () {
        function a() {}
        return a
    }(),
    qw = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "boxplotBoxPath", r
        }
        return e.prototype.getDefaultShape = function () {
            return new Kw
        }, e.prototype.buildPath = function (t, r) {
            var i = r.points,
                n = 0;
            for (t.moveTo(i[n][0], i[n][1]), n++; n < 4; n++) t.lineTo(i[n][0], i[n][1]);
            for (t.closePath(); n < i.length; n++) t.moveTo(i[n][0], i[n][1]), n++, t.lineTo(i[n][0], i[n][1])
        }, e
    }(Pt);

function mh(a, e, t, r, i) {
    var n = a.ends,
        o = new qw({
            shape: {
                points: i ? jw(n, r, a) : n
            }
        });
    return Zd(a, o, e, t, i), o
}

function Zd(a, e, t, r, i) {
    var n = t.hostModel,
        o = Qr[i ? "initProps" : "updateProps"];
    o(e, {
        shape: {
            points: a.ends
        }
    }, n, r), e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.z2 = 100;
    var s = t.getItemModel(r),
        l = s.getModel("emphasis");
    ee(e, s), Tt(e, l.get("focus"), l.get("blurScope"), l.get("disabled"))
}

function jw(a, e, t) {
    return G(a, function (r) {
        return r = r.slice(), r[e] = t.initBaseline, r
    })
}
const Jw = Xw;
var xa = T;

function Qw(a) {
    var e = tA(a);
    xa(e, function (t) {
        var r = t.seriesModels;
        r.length && (eA(t), xa(r, function (i, n) {
            rA(i, t.boxOffsetList[n], t.boxWidthList[n])
        }))
    })
}

function tA(a) {
    var e = [],
        t = [];
    return a.eachSeriesByType("boxplot", function (r) {
        var i = r.getBaseAxis(),
            n = ft(t, i);
        n < 0 && (n = t.length, t[n] = i, e[n] = {
            axis: i,
            seriesModels: []
        }), e[n].seriesModels.push(r)
    }), e
}

function eA(a) {
    var e = a.axis,
        t = a.seriesModels,
        r = t.length,
        i = a.boxWidthList = [],
        n = a.boxOffsetList = [],
        o = [],
        s;
    if (e.type === "category") s = e.getBandWidth();
    else {
        var l = 0;
        xa(t, function (p) {
            l = Math.max(l, p.getData().count())
        });
        var u = e.getExtent();
        s = Math.abs(u[1] - u[0]) / l
    }
    xa(t, function (p) {
        var d = p.get("boxWidth");
        B(d) || (d = [d, d]), o.push([H(d[0], s) || 0, H(d[1], s) || 0])
    });
    var v = s * .8 - 2,
        h = v / r * .3,
        c = (v - h * (r - 1)) / r,
        f = c / 2 - v / 2;
    xa(t, function (p, d) {
        n.push(f), f += h + c, i.push(Math.min(Math.max(c, o[d][0]), o[d][1]))
    })
}

function rA(a, e, t) {
    var r = a.coordinateSystem,
        i = a.getData(),
        n = t / 2,
        o = a.get("layout") === "horizontal" ? 0 : 1,
        s = 1 - o,
        l = ["x", "y"],
        u = i.mapDimension(l[o]),
        v = i.mapDimensionsAll(l[s]);
    if (u == null || v.length < 5) return;
    for (var h = 0; h < i.count(); h++) {
        var c = i.get(u, h),
            f = m(c, v[2], h),
            p = m(c, v[0], h),
            d = m(c, v[1], h),
            g = m(c, v[3], h),
            y = m(c, v[4], h),
            x = [];
        S(x, d, !1), S(x, g, !0), x.push(p, d, y, g), _(x, p), _(x, y), _(x, f), i.setItemLayout(h, {
            initBaseline: f[s],
            ends: x
        })
    }

    function m(b, w, A) {
        var C = i.get(w, A),
            D = [];
        D[o] = b, D[s] = C;
        var I;
        return isNaN(b) || isNaN(C) ? I = [NaN, NaN] : (I = r.dataToPoint(D), I[o] += e), I
    }

    function S(b, w, A) {
        var C = w.slice(),
            D = w.slice();
        C[o] += n, D[o] -= n, A ? b.push(C, D) : b.push(D, C)
    }

    function _(b, w) {
        var A = w.slice(),
            C = w.slice();
        A[o] -= n, C[o] += n, b.push(A, C)
    }
}

function aA(a, e) {
    e = e || {};
    for (var t = [], r = [], i = e.boundIQR, n = i === "none" || i === 0, o = 0; o < a.length; o++) {
        var s = oe(a[o].slice()),
            l = Tn(s, .25),
            u = Tn(s, .5),
            v = Tn(s, .75),
            h = s[0],
            c = s[s.length - 1],
            f = (i ? ? 1.5) * (v - l),
            p = n ? h : Math.max(h, l - f),
            d = n ? c : Math.min(c, v + f),
            g = e.itemNameFormatter,
            y = rt(g) ? g({
                value: o
            }) : q(g) ? g.replace("{value}", o + "") : o + "";
        t.push([y, p, l, u, v, d]);
        for (var x = 0; x < s.length; x++) {
            var m = s[x];
            if (m < p || m > d) {
                var S = [y, m];
                r.push(S)
            }
        }
    }
    return {
        boxData: t,
        outliers: r
    }
}
var iA = {
    type: "echarts:boxplot",
    transform: function (e) {
        var t = e.upstream;
        if (t.sourceFormat !== np) {
            var r = "";
            bt(r)
        }
        var i = aA(t.getRawData(), e.config);
        return [{
            dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
            data: i.boxData
        }, {
            data: i.outliers
        }]
    }
};

function nA(a) {
    a.registerSeriesModel(Yw), a.registerChartView(Jw), a.registerLayout(Qw), a.registerTransform(iA)
}
var oA = ["color", "borderColor"],
    sA = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t)
        }, e.prototype.incrementalPrepareRender = function (t, r, i) {
            this._clear(), this._updateDrawMode(t)
        }, e.prototype.incrementalRender = function (t, r, i, n) {
            this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, r) : this._incrementalRenderNormal(t, r)
        }, e.prototype.eachRendered = function (t) {
            Ga(this._progressiveEls || this.group, t)
        }, e.prototype._updateDrawMode = function (t) {
            var r = t.pipelineContext.large;
            (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear())
        }, e.prototype._renderNormal = function (t) {
            var r = t.getData(),
                i = this._data,
                n = this.group,
                o = r.getLayout("isSimpleBox"),
                s = t.get("clip", !0),
                l = t.coordinateSystem,
                u = l.getArea && l.getArea();
            this._data || n.removeAll(), r.diff(i).add(function (v) {
                if (r.hasValue(v)) {
                    var h = r.getItemLayout(v);
                    if (s && xh(u, h)) return;
                    var c = ho(h, v, !0);
                    Yt(c, {
                        shape: {
                            points: h.ends
                        }
                    }, t, v), co(c, r, v, o), n.add(c), r.setItemGraphicEl(v, c)
                }
            }).update(function (v, h) {
                var c = i.getItemGraphicEl(h);
                if (!r.hasValue(v)) {
                    n.remove(c);
                    return
                }
                var f = r.getItemLayout(v);
                if (s && xh(u, f)) {
                    n.remove(c);
                    return
                }
                c ? (yt(c, {
                    shape: {
                        points: f.ends
                    }
                }, t, v), gr(c)) : c = ho(f), co(c, r, v, o), n.add(c), r.setItemGraphicEl(v, c)
            }).remove(function (v) {
                var h = i.getItemGraphicEl(v);
                h && n.remove(h)
            }).execute(), this._data = r
        }, e.prototype._renderLarge = function (t) {
            this._clear(), Sh(t, this.group);
            var r = t.get("clip", !0) ? cn(t.coordinateSystem, !1, t) : null;
            r ? this.group.setClipPath(r) : this.group.removeClipPath()
        }, e.prototype._incrementalRenderNormal = function (t, r) {
            for (var i = r.getData(), n = i.getLayout("isSimpleBox"), o;
                (o = t.next()) != null;) {
                var s = i.getItemLayout(o),
                    l = ho(s);
                co(l, i, o, n), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l)
            }
        }, e.prototype._incrementalRenderLarge = function (t, r) {
            Sh(r, this.group, this._progressiveEls, !0)
        }, e.prototype.remove = function (t) {
            this._clear()
        }, e.prototype._clear = function () {
            this.group.removeAll(), this._data = null
        }, e.type = "candlestick", e
    }(At),
    lA = function () {
        function a() {}
        return a
    }(),
    uA = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "normalCandlestickBox", r
        }
        return e.prototype.getDefaultShape = function () {
            return new lA
        }, e.prototype.buildPath = function (t, r) {
            var i = r.points;
            this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]))
        }, e
    }(Pt);

function ho(a, e, t) {
    var r = a.ends;
    return new uA({
        shape: {
            points: t ? vA(r, a) : r
        },
        z2: 100
    })
}

function xh(a, e) {
    for (var t = !0, r = 0; r < e.ends.length; r++)
        if (a.contain(e.ends[r][0], e.ends[r][1])) {
            t = !1;
            break
        } return t
}

function co(a, e, t, r) {
    var i = e.getItemModel(t);
    a.useStyle(e.getItemVisual(t, "style")), a.style.strokeNoScale = !0, a.__simpleBox = r, ee(a, i)
}

function vA(a, e) {
    return G(a, function (t) {
        return t = t.slice(), t[1] = e.initBaseline, t
    })
}
var hA = function () {
        function a() {}
        return a
    }(),
    fo = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r.type = "largeCandlestickBox", r
        }
        return e.prototype.getDefaultShape = function () {
            return new hA
        }, e.prototype.buildPath = function (t, r) {
            for (var i = r.points, n = 0; n < i.length;)
                if (this.__sign === i[n++]) {
                    var o = i[n++];
                    t.moveTo(o, i[n++]), t.lineTo(o, i[n++])
                } else n += 3
        }, e
    }(Pt);

function Sh(a, e, t, r) {
    var i = a.getData(),
        n = i.getLayout("largePoints"),
        o = new fo({
            shape: {
                points: n
            },
            __sign: 1,
            ignoreCoarsePointer: !0
        });
    e.add(o);
    var s = new fo({
        shape: {
            points: n
        },
        __sign: -1,
        ignoreCoarsePointer: !0
    });
    e.add(s);
    var l = new fo({
        shape: {
            points: n
        },
        __sign: 0,
        ignoreCoarsePointer: !0
    });
    e.add(l), po(1, o, a), po(-1, s, a), po(0, l, a), r && (o.incremental = !0, s.incremental = !0), t && t.push(o, s)
}

function po(a, e, t, r) {
    var i = t.get(["itemStyle", a > 0 ? "borderColor" : "borderColor0"]) || t.get(["itemStyle", a > 0 ? "color" : "color0"]);
    a === 0 && (i = t.get(["itemStyle", "borderColorDoji"]));
    var n = t.getModel("itemStyle").getItemStyle(oA);
    e.useStyle(n), e.style.fill = null, e.style.stroke = i
}
const cA = sA;
var Ud = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.defaultValueDimensions = [{
            name: "open",
            defaultTooltip: !0
        }, {
            name: "close",
            defaultTooltip: !0
        }, {
            name: "lowest",
            defaultTooltip: !0
        }, {
            name: "highest",
            defaultTooltip: !0
        }], t
    }
    return e.prototype.getShadowDim = function () {
        return "open"
    }, e.prototype.brushSelector = function (t, r, i) {
        var n = r.getItemLayout(t);
        return n && i.rect(n.brushRect)
    }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: !0,
        layout: null,
        clip: !0,
        itemStyle: {
            color: "#eb5454",
            color0: "#47b262",
            borderColor: "#eb5454",
            borderColor0: "#47b262",
            borderColorDoji: null,
            borderWidth: 1
        },
        emphasis: {
            scale: !0,
            itemStyle: {
                borderWidth: 2
            }
        },
        barMaxWidth: null,
        barMinWidth: null,
        barWidth: null,
        large: !0,
        largeThreshold: 600,
        progressive: 3e3,
        progressiveThreshold: 1e4,
        progressiveChunkMode: "mod",
        animationEasing: "linear",
        animationDuration: 300
    }, e
}(Vt);
le(Ud, Wd, !0);
const fA = Ud;

function pA(a) {
    !a || !B(a.series) || T(a.series, function (e) {
        St(e) && e.type === "k" && (e.type = "candlestick")
    })
}
var dA = ["itemStyle", "borderColor"],
    gA = ["itemStyle", "borderColor0"],
    yA = ["itemStyle", "borderColorDoji"],
    mA = ["itemStyle", "color"],
    xA = ["itemStyle", "color0"],
    SA = {
        seriesType: "candlestick",
        plan: ji(),
        performRawSeries: !0,
        reset: function (a, e) {
            function t(n, o) {
                return o.get(n > 0 ? mA : xA)
            }

            function r(n, o) {
                return o.get(n === 0 ? yA : n > 0 ? dA : gA)
            }
            if (!e.isSeriesFiltered(a)) {
                var i = a.pipelineContext.large;
                return !i && {
                    progress: function (n, o) {
                        for (var s;
                            (s = n.next()) != null;) {
                            var l = o.getItemModel(s),
                                u = o.getItemLayout(s).sign,
                                v = l.getItemStyle();
                            v.fill = t(u, l), v.stroke = r(u, l) || v.fill;
                            var h = o.ensureUniqueItemVisual(s, "style");
                            W(h, v)
                        }
                    }
                }
            }
        }
    };
const _A = SA;
var bA = {
    seriesType: "candlestick",
    plan: ji(),
    reset: function (a) {
        var e = a.coordinateSystem,
            t = a.getData(),
            r = wA(a, t),
            i = 0,
            n = 1,
            o = ["x", "y"],
            s = t.getDimensionIndex(t.mapDimension(o[i])),
            l = G(t.mapDimensionsAll(o[n]), t.getDimensionIndex, t),
            u = l[0],
            v = l[1],
            h = l[2],
            c = l[3];
        if (t.setLayout({
                candleWidth: r,
                isSimpleBox: r <= 1.3
            }), s < 0 || l.length < 4) return;
        return {
            progress: a.pipelineContext.large ? p : f
        };

        function f(d, g) {
            for (var y, x = g.getStore();
                (y = d.next()) != null;) {
                var m = x.get(s, y),
                    S = x.get(u, y),
                    _ = x.get(v, y),
                    b = x.get(h, y),
                    w = x.get(c, y),
                    A = Math.min(S, _),
                    C = Math.max(S, _),
                    D = V(A, m),
                    I = V(C, m),
                    L = V(b, m),
                    M = V(w, m),
                    P = [];
                O(P, I, 0), O(P, D, 1), P.push($(M), $(I), $(L), $(D));
                var R = g.getItemModel(y),
                    k = !!R.get(["itemStyle", "borderColorDoji"]);
                g.setItemLayout(y, {
                    sign: _h(x, y, S, _, v, k),
                    initBaseline: S > _ ? I[n] : D[n],
                    ends: P,
                    brushRect: z(b, w, m)
                })
            }

            function V(Z, et) {
                var J = [];
                return J[i] = et, J[n] = Z, isNaN(et) || isNaN(Z) ? [NaN, NaN] : e.dataToPoint(J)
            }

            function O(Z, et, J) {
                var X = et.slice(),
                    nt = et.slice();
                X[i] = Cn(X[i] + r / 2, 1, !1), nt[i] = Cn(nt[i] - r / 2, 1, !0), J ? Z.push(X, nt) : Z.push(nt, X)
            }

            function z(Z, et, J) {
                var X = V(Z, J),
                    nt = V(et, J);
                return X[i] -= r / 2, nt[i] -= r / 2, {
                    x: X[0],
                    y: X[1],
                    width: r,
                    height: nt[1] - X[1]
                }
            }

            function $(Z) {
                return Z[i] = Cn(Z[i], 1), Z
            }
        }

        function p(d, g) {
            for (var y = or(d.count * 4), x = 0, m, S = [], _ = [], b, w = g.getStore(), A = !!a.get(["itemStyle", "borderColorDoji"]);
                (b = d.next()) != null;) {
                var C = w.get(s, b),
                    D = w.get(u, b),
                    I = w.get(v, b),
                    L = w.get(h, b),
                    M = w.get(c, b);
                if (isNaN(C) || isNaN(L) || isNaN(M)) {
                    y[x++] = NaN, x += 3;
                    continue
                }
                y[x++] = _h(w, b, D, I, v, A), S[i] = C, S[n] = L, m = e.dataToPoint(S, null, _), y[x++] = m ? m[0] : NaN, y[x++] = m ? m[1] : NaN, S[n] = M, m = e.dataToPoint(S, null, _), y[x++] = m ? m[1] : NaN
            }
            g.setLayout("largePoints", y)
        }
    }
};

function _h(a, e, t, r, i, n) {
    var o;
    return t > r ? o = -1 : t < r ? o = 1 : o = n ? 0 : e > 0 ? a.get(i, e - 1) <= r ? 1 : -1 : 1, o
}

function wA(a, e) {
    var t = a.getBaseAxis(),
        r, i = t.type === "category" ? t.getBandWidth() : (r = t.getExtent(), Math.abs(r[1] - r[0]) / e.count()),
        n = H(Lt(a.get("barMaxWidth"), i), i),
        o = H(Lt(a.get("barMinWidth"), 1), i),
        s = a.get("barWidth");
    return s != null ? H(s, i) : Math.max(Math.min(i / 2, n), o)
}
const AA = bA;

function TA(a) {
    a.registerChartView(cA), a.registerSeriesModel(fA), a.registerPreprocessor(pA), a.registerVisual(_A), a.registerLayout(AA)
}

function bh(a, e) {
    var t = e.rippleEffectColor || e.color;
    a.eachChild(function (r) {
        r.attr({
            z: e.z,
            zlevel: e.zlevel,
            style: {
                stroke: e.brushType === "stroke" ? t : null,
                fill: e.brushType === "fill" ? t : null
            }
        })
    })
}
var CA = function (a) {
    E(e, a);

    function e(t, r) {
        var i = a.call(this) || this,
            n = new Ua(t, r),
            o = new U;
        return i.add(n), i.add(o), i.updateData(t, r), i
    }
    return e.prototype.stopEffectAnimation = function () {
        this.childAt(1).removeAll()
    }, e.prototype.startEffectAnimation = function (t) {
        for (var r = t.symbolType, i = t.color, n = t.rippleNumber, o = this.childAt(1), s = 0; s < n; s++) {
            var l = Et(r, -1, -1, 2, 2, i);
            l.attr({
                style: {
                    strokeNoScale: !0
                },
                z2: 99,
                silent: !0,
                scaleX: .5,
                scaleY: .5
            });
            var u = -s / n * t.period + t.effectOffset;
            l.animate("", !0).when(t.period, {
                scaleX: t.rippleScale / 2,
                scaleY: t.rippleScale / 2
            }).delay(u).start(), l.animateStyle(!0).when(t.period, {
                opacity: 0
            }).delay(u).start(), o.add(l)
        }
        bh(o, t)
    }, e.prototype.updateEffectAnimation = function (t) {
        for (var r = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < n.length; o++) {
            var s = n[o];
            if (r[s] !== t[s]) {
                this.stopEffectAnimation(), this.startEffectAnimation(t);
                return
            }
        }
        bh(i, t)
    }, e.prototype.highlight = function () {
        Br(this)
    }, e.prototype.downplay = function () {
        Hr(this)
    }, e.prototype.getSymbolType = function () {
        var t = this.childAt(0);
        return t && t.getSymbolType()
    }, e.prototype.updateData = function (t, r) {
        var i = this,
            n = t.hostModel;
        this.childAt(0).updateData(t, r);
        var o = this.childAt(1),
            s = t.getItemModel(r),
            l = t.getItemVisual(r, "symbol"),
            u = Na(t.getItemVisual(r, "symbolSize")),
            v = t.getItemVisual(r, "style"),
            h = v && v.fill,
            c = s.getModel("emphasis");
        o.setScale(u), o.traverse(function (g) {
            g.setStyle("fill", h)
        });
        var f = jr(t.getItemVisual(r, "symbolOffset"), u);
        f && (o.x = f[0], o.y = f[1]);
        var p = t.getItemVisual(r, "symbolRotate");
        o.rotation = (p || 0) * Math.PI / 180 || 0;
        var d = {};
        d.showEffectOn = n.get("showEffectOn"), d.rippleScale = s.get(["rippleEffect", "scale"]), d.brushType = s.get(["rippleEffect", "brushType"]), d.period = s.get(["rippleEffect", "period"]) * 1e3, d.effectOffset = r / t.count(), d.z = n.getShallow("z") || 0, d.zlevel = n.getShallow("zlevel") || 0, d.symbolType = l, d.color = h, d.rippleEffectColor = s.get(["rippleEffect", "color"]), d.rippleNumber = s.get(["rippleEffect", "number"]), d.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(d) : this.startEffectAnimation(d), this._effectCfg = d) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function (g) {
            g === "emphasis" ? d.showEffectOn !== "render" && i.startEffectAnimation(d) : g === "normal" && d.showEffectOn !== "render" && i.stopEffectAnimation()
        }), this._effectCfg = d, Tt(this, c.get("focus"), c.get("blurScope"), c.get("disabled"))
    }, e.prototype.fadeOut = function (t) {
        t && t()
    }, e
}(U);
const DA = CA;
var IA = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function () {
        this._symbolDraw = new Ya(DA)
    }, e.prototype.render = function (t, r, i) {
        var n = t.getData(),
            o = this._symbolDraw;
        o.updateData(n, {
            clipShape: this._getClipShape(t)
        }), this.group.add(o.group)
    }, e.prototype._getClipShape = function (t) {
        var r = t.coordinateSystem,
            i = r && r.getArea && r.getArea();
        return t.get("clip", !0) ? i : null
    }, e.prototype.updateTransform = function (t, r, i) {
        var n = t.getData();
        this.group.dirty();
        var o = Xa("").reset(t, r, i);
        o.progress && o.progress({
            start: 0,
            end: n.count(),
            count: n.count()
        }, n), this._symbolDraw.updateLayout()
    }, e.prototype._updateGroupTransform = function (t) {
        var r = t.coordinateSystem;
        r && r.getRoamTransform && (this.group.transform = bm(r.getRoamTransform()), this.group.decomposeTransform())
    }, e.prototype.remove = function (t, r) {
        this._symbolDraw && this._symbolDraw.remove(!0)
    }, e.type = "effectScatter", e
}(At);
const LA = IA;
var MA = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.hasSymbolVisual = !0, t
    }
    return e.prototype.getInitialData = function (t, r) {
        return dr(null, this, {
            useEncodeDefaulter: !0
        })
    }, e.prototype.brushSelector = function (t, r, i) {
        return i.point(r.getItemLayout(t))
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
        coordinateSystem: "cartesian2d",
        z: 2,
        legendHoverLink: !0,
        effectType: "ripple",
        progressive: 0,
        showEffectOn: "render",
        clip: !0,
        rippleEffect: {
            period: 4,
            scale: 2.5,
            brushType: "fill",
            number: 3
        },
        universalTransition: {
            divideShape: "clone"
        },
        symbolSize: 10
    }, e
}(Vt);
const PA = MA;

function RA(a) {
    a.registerChartView(LA), a.registerSeriesModel(PA), a.registerLayout(Xa("effectScatter"))
}
var EA = function (a) {
    E(e, a);

    function e(t, r, i) {
        var n = a.call(this) || this;
        return n.add(n.createLine(t, r, i)), n._updateEffectSymbol(t, r), n
    }
    return e.prototype.createLine = function (t, r, i) {
        return new bl(t, r, i)
    }, e.prototype._updateEffectSymbol = function (t, r) {
        var i = t.getItemModel(r),
            n = i.getModel("effect"),
            o = n.get("symbolSize"),
            s = n.get("symbol");
        B(o) || (o = [o, o]);
        var l = t.getItemVisual(r, "style"),
            u = n.get("color") || l && l.stroke,
            v = this.childAt(1);
        this._symbolType !== s && (this.remove(v), v = Et(s, -.5, -.5, 1, 1, u), v.z2 = 100, v.culling = !0, this.add(v)), v && (v.setStyle("shadowColor", u), v.setStyle(n.getItemStyle(["color"])), v.scaleX = o[0], v.scaleY = o[1], v.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, n, r))
    }, e.prototype._updateEffectAnimation = function (t, r, i) {
        var n = this.childAt(1);
        if (n) {
            var o = t.getItemLayout(i),
                s = r.get("period") * 1e3,
                l = r.get("loop"),
                u = r.get("roundTrip"),
                v = r.get("constantSpeed"),
                h = Ut(r.get("delay"), function (f) {
                    return f / t.count() * s / 3
                });
            if (n.ignore = !0, this._updateAnimationPoints(n, o), v > 0 && (s = this._getLineLength(n) / v * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
                n.stopAnimation();
                var c = void 0;
                rt(h) ? c = h(i) : c = h, n.__t > 0 && (c = -s * n.__t), this._animateSymbol(n, s, c, l, u)
            }
            this._period = s, this._loop = l, this._roundTrip = u
        }
    }, e.prototype._animateSymbol = function (t, r, i, n, o) {
        if (r > 0) {
            t.__t = 0;
            var s = this,
                l = t.animate("", n).when(o ? r * 2 : r, {
                    __t: o ? 2 : 1
                }).delay(i).during(function () {
                    s._updateSymbolPosition(t)
                });
            n || l.done(function () {
                s.remove(t)
            }), l.start()
        }
    }, e.prototype._getLineLength = function (t) {
        return ha(t.__p1, t.__cp1) + ha(t.__cp1, t.__p2)
    }, e.prototype._updateAnimationPoints = function (t, r) {
        t.__p1 = r[0], t.__p2 = r[1], t.__cp1 = r[2] || [(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2]
    }, e.prototype.updateData = function (t, r, i) {
        this.childAt(0).updateData(t, r, i), this._updateEffectSymbol(t, r)
    }, e.prototype._updateSymbolPosition = function (t) {
        var r = t.__p1,
            i = t.__p2,
            n = t.__cp1,
            o = t.__t < 1 ? t.__t : 2 - t.__t,
            s = [t.x, t.y],
            l = s.slice(),
            u = ap,
            v = wm;
        s[0] = u(r[0], n[0], i[0], o), s[1] = u(r[1], n[1], i[1], o);
        var h = t.__t < 1 ? v(r[0], n[0], i[0], o) : v(i[0], n[0], r[0], 1 - o),
            c = t.__t < 1 ? v(r[1], n[1], i[1], o) : v(i[1], n[1], r[1], 1 - o);
        t.rotation = -Math.atan2(c, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = ha(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * ha(r, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1]
    }, e.prototype.updateLayout = function (t, r) {
        this.childAt(0).updateLayout(t, r);
        var i = t.getItemModel(r).getModel("effect");
        this._updateEffectAnimation(t, i, r)
    }, e
}(U);
const Yd = EA;
var kA = function (a) {
    E(e, a);

    function e(t, r, i) {
        var n = a.call(this) || this;
        return n._createPolyline(t, r, i), n
    }
    return e.prototype._createPolyline = function (t, r, i) {
        var n = t.getItemLayout(r),
            o = new $e({
                shape: {
                    points: n
                }
            });
        this.add(o), this._updateCommonStl(t, r, i)
    }, e.prototype.updateData = function (t, r, i) {
        var n = t.hostModel,
            o = this.childAt(0),
            s = {
                shape: {
                    points: t.getItemLayout(r)
                }
            };
        yt(o, s, n, r), this._updateCommonStl(t, r, i)
    }, e.prototype._updateCommonStl = function (t, r, i) {
        var n = this.childAt(0),
            o = t.getItemModel(r),
            s = i && i.emphasisLineStyle,
            l = i && i.focus,
            u = i && i.blurScope,
            v = i && i.emphasisDisabled;
        if (!i || t.hasItemOption) {
            var h = o.getModel("emphasis");
            s = h.getModel("lineStyle").getLineStyle(), v = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope")
        }
        n.useStyle(t.getItemVisual(r, "style")), n.style.fill = null, n.style.strokeNoScale = !0;
        var c = n.ensureState("emphasis");
        c.style = s, Tt(this, l, u, v)
    }, e.prototype.updateLayout = function (t, r) {
        var i = this.childAt(0);
        i.setShape("points", t.getItemLayout(r))
    }, e
}(U);
const Xd = kA;
var VA = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t._lastFrame = 0, t._lastFramePercent = 0, t
    }
    return e.prototype.createLine = function (t, r, i) {
        return new Xd(t, r, i)
    }, e.prototype._updateAnimationPoints = function (t, r) {
        this._points = r;
        for (var i = [0], n = 0, o = 1; o < r.length; o++) {
            var s = r[o - 1],
                l = r[o];
            n += ha(s, l), i.push(n)
        }
        if (n === 0) {
            this._length = 0;
            return
        }
        for (var o = 0; o < i.length; o++) i[o] /= n;
        this._offsets = i, this._length = n
    }, e.prototype._getLineLength = function () {
        return this._length
    }, e.prototype._updateSymbolPosition = function (t) {
        var r = t.__t < 1 ? t.__t : 2 - t.__t,
            i = this._points,
            n = this._offsets,
            o = i.length;
        if (n) {
            var s = this._lastFrame,
                l;
            if (r < this._lastFramePercent) {
                var u = Math.min(s + 1, o - 1);
                for (l = u; l >= 0 && !(n[l] <= r); l--);
                l = Math.min(l, o - 2)
            } else {
                for (l = s; l < o && !(n[l] > r); l++);
                l = Math.min(l - 1, o - 2)
            }
            var v = (r - n[l]) / (n[l + 1] - n[l]),
                h = i[l],
                c = i[l + 1];
            t.x = h[0] * (1 - v) + v * c[0], t.y = h[1] * (1 - v) + v * c[1];
            var f = t.__t < 1 ? c[0] - h[0] : h[0] - c[0],
                p = t.__t < 1 ? c[1] - h[1] : h[1] - c[1];
            t.rotation = -Math.atan2(p, f) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, t.ignore = !1
        }
    }, e
}(Yd);
const OA = VA;
var zA = function () {
        function a() {
            this.polyline = !1, this.curveness = 0, this.segs = []
        }
        return a
    }(),
    NA = function (a) {
        E(e, a);

        function e(t) {
            var r = a.call(this, t) || this;
            return r._off = 0, r.hoverDataIdx = -1, r
        }
        return e.prototype.reset = function () {
            this.notClear = !1, this._off = 0
        }, e.prototype.getDefaultStyle = function () {
            return {
                stroke: "#000",
                fill: null
            }
        }, e.prototype.getDefaultShape = function () {
            return new zA
        }, e.prototype.buildPath = function (t, r) {
            var i = r.segs,
                n = r.curveness,
                o;
            if (r.polyline)
                for (o = this._off; o < i.length;) {
                    var s = i[o++];
                    if (s > 0) {
                        t.moveTo(i[o++], i[o++]);
                        for (var l = 1; l < s; l++) t.lineTo(i[o++], i[o++])
                    }
                } else
                    for (o = this._off; o < i.length;) {
                        var u = i[o++],
                            v = i[o++],
                            h = i[o++],
                            c = i[o++];
                        if (t.moveTo(u, v), n > 0) {
                            var f = (u + h) / 2 - (v - c) * n,
                                p = (v + c) / 2 - (h - u) * n;
                            t.quadraticCurveTo(f, p, h, c)
                        } else t.lineTo(h, c)
                    }
            this.incremental && (this._off = o, this.notClear = !0)
        }, e.prototype.findDataIndex = function (t, r) {
            var i = this.shape,
                n = i.segs,
                o = i.curveness,
                s = this.style.lineWidth;
            if (i.polyline)
                for (var l = 0, u = 0; u < n.length;) {
                    var v = n[u++];
                    if (v > 0)
                        for (var h = n[u++], c = n[u++], f = 1; f < v; f++) {
                            var p = n[u++],
                                d = n[u++];
                            if (mu(h, c, p, d, s, t, r)) return l
                        }
                    l++
                } else
                    for (var l = 0, u = 0; u < n.length;) {
                        var h = n[u++],
                            c = n[u++],
                            p = n[u++],
                            d = n[u++];
                        if (o > 0) {
                            var g = (h + p) / 2 - (c - d) * o,
                                y = (c + d) / 2 - (p - h) * o;
                            if (Am(h, c, g, y, p, d, s, t, r)) return l
                        } else if (mu(h, c, p, d, s, t, r)) return l;
                        l++
                    }
            return -1
        }, e.prototype.contain = function (t, r) {
            var i = this.transformCoordToLocal(t, r),
                n = this.getBoundingRect();
            if (t = i[0], r = i[1], n.contain(t, r)) {
                var o = this.hoverDataIdx = this.findDataIndex(t, r);
                return o >= 0
            }
            return this.hoverDataIdx = -1, !1
        }, e.prototype.getBoundingRect = function () {
            var t = this._rect;
            if (!t) {
                for (var r = this.shape, i = r.segs, n = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length;) {
                    var v = i[u++],
                        h = i[u++];
                    n = Math.min(v, n), s = Math.max(v, s), o = Math.min(h, o), l = Math.max(h, l)
                }
                t = this._rect = new gt(n, o, s, l)
            }
            return t
        }, e
    }(Pt),
    GA = function () {
        function a() {
            this.group = new U
        }
        return a.prototype.updateData = function (e) {
            this._clear();
            var t = this._create();
            t.setShape({
                segs: e.getLayout("linesPoints")
            }), this._setCommon(t, e)
        }, a.prototype.incrementalPrepareUpdate = function (e) {
            this.group.removeAll(), this._clear()
        }, a.prototype.incrementalUpdate = function (e, t) {
            var r = this._newAdded[0],
                i = t.getLayout("linesPoints"),
                n = r && r.shape.segs;
            if (n && n.length < 2e4) {
                var o = n.length,
                    s = new Float32Array(o + i.length);
                s.set(n), s.set(i, o), r.setShape({
                    segs: s
                })
            } else {
                this._newAdded = [];
                var l = this._create();
                l.incremental = !0, l.setShape({
                    segs: i
                }), this._setCommon(l, t), l.__startIndex = e.start
            }
        }, a.prototype.remove = function () {
            this._clear()
        }, a.prototype.eachRendered = function (e) {
            this._newAdded[0] && e(this._newAdded[0])
        }, a.prototype._create = function () {
            var e = new NA({
                cursor: "default",
                ignoreCoarsePointer: !0
            });
            return this._newAdded.push(e), this.group.add(e), e
        }, a.prototype._setCommon = function (e, t, r) {
            var i = t.hostModel;
            e.setShape({
                polyline: i.get("polyline"),
                curveness: i.get(["lineStyle", "curveness"])
            }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
            var n = t.getVisual("style");
            n && n.stroke && e.setStyle("stroke", n.stroke), e.setStyle("fill", null);
            var o = tt(e);
            o.seriesIndex = i.seriesIndex, e.on("mousemove", function (s) {
                o.dataIndex = null;
                var l = e.hoverDataIdx;
                l > 0 && (o.dataIndex = l + e.__startIndex)
            })
        }, a.prototype._clear = function () {
            this._newAdded = [], this.group.removeAll()
        }, a
    }(),
    BA = {
        seriesType: "lines",
        plan: ji(),
        reset: function (a) {
            var e = a.coordinateSystem;
            if (e) {
                var t = a.get("polyline"),
                    r = a.pipelineContext.large;
                return {
                    progress: function (i, n) {
                        var o = [];
                        if (r) {
                            var s = void 0,
                                l = i.end - i.start;
                            if (t) {
                                for (var u = 0, v = i.start; v < i.end; v++) u += a.getLineCoordsCount(v);
                                s = new Float32Array(l + u * 2)
                            } else s = new Float32Array(l * 4);
                            for (var h = 0, c = [], v = i.start; v < i.end; v++) {
                                var f = a.getLineCoords(v, o);
                                t && (s[h++] = f);
                                for (var p = 0; p < f; p++) c = e.dataToPoint(o[p], !1, c), s[h++] = c[0], s[h++] = c[1]
                            }
                            n.setLayout("linesPoints", s)
                        } else
                            for (var v = i.start; v < i.end; v++) {
                                var d = n.getItemModel(v),
                                    f = a.getLineCoords(v, o),
                                    g = [];
                                if (t)
                                    for (var y = 0; y < f; y++) g.push(e.dataToPoint(o[y]));
                                else {
                                    g[0] = e.dataToPoint(o[0]), g[1] = e.dataToPoint(o[1]);
                                    var x = d.get(["lineStyle", "curveness"]); + x && (g[2] = [(g[0][0] + g[1][0]) / 2 - (g[0][1] - g[1][1]) * x, (g[0][1] + g[1][1]) / 2 - (g[1][0] - g[0][0]) * x])
                                }
                                n.setItemLayout(v, g)
                            }
                    }
                }
            }
        }
    };
const Kd = BA;
var HA = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i) {
        var n = t.getData(),
            o = this._updateLineDraw(n, t),
            s = t.get("zlevel"),
            l = t.get(["effect", "trailLength"]),
            u = i.getZr(),
            v = u.painter.getType() === "svg";
        v || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !v && u.configLayer(this._lastZlevel, {
            motionBlur: !1
        }), this._showEffect(t) && l > 0 && (v || u.configLayer(s, {
            motionBlur: !0,
            lastFrameAlpha: Math.max(Math.min(l / 10 + .9, 1), 0)
        })), o.updateData(n);
        var h = t.get("clip", !0) && cn(t.coordinateSystem, !1, t);
        h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0
    }, e.prototype.incrementalPrepareRender = function (t, r, i) {
        var n = t.getData(),
            o = this._updateLineDraw(n, t);
        o.incrementalPrepareUpdate(n), this._clearLayer(i), this._finished = !1
    }, e.prototype.incrementalRender = function (t, r, i) {
        this._lineDraw.incrementalUpdate(t, r.getData()), this._finished = t.end === r.getData().count()
    }, e.prototype.eachRendered = function (t) {
        this._lineDraw && this._lineDraw.eachRendered(t)
    }, e.prototype.updateTransform = function (t, r, i) {
        var n = t.getData(),
            o = t.pipelineContext;
        if (!this._finished || o.large || o.progressiveRender) return {
            update: !0
        };
        var s = Kd.reset(t, r, i);
        s.progress && s.progress({
            start: 0,
            end: n.count(),
            count: n.count()
        }, n), this._lineDraw.updateLayout(), this._clearLayer(i)
    }, e.prototype._updateLineDraw = function (t, r) {
        var i = this._lineDraw,
            n = this._showEffect(r),
            o = !!r.get("polyline"),
            s = r.pipelineContext,
            l = s.large;
        return (!i || n !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new GA : new wl(o ? n ? OA : Xd : n ? Yd : bl), this._hasEffet = n, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i
    }, e.prototype._showEffect = function (t) {
        return !!t.get(["effect", "show"])
    }, e.prototype._clearLayer = function (t) {
        var r = t.getZr(),
            i = r.painter.getType() === "svg";
        !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(!0)
    }, e.prototype.remove = function (t, r) {
        this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r)
    }, e.prototype.dispose = function (t, r) {
        this.remove(t, r)
    }, e.type = "lines", e
}(At);
const FA = HA;
var WA = typeof Uint32Array > "u" ? Array : Uint32Array,
    $A = typeof Float64Array > "u" ? Array : Float64Array;

function wh(a) {
    var e = a.data;
    e && e[0] && e[0][0] && e[0][0].coord && (a.data = G(e, function (t) {
        var r = [t[0].coord, t[1].coord],
            i = {
                coords: r
            };
        return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), Xs([i, t[0], t[1]])
    }))
}
var ZA = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t
    }
    return e.prototype.init = function (t) {
        t.data = t.data || [], wh(t);
        var r = this._processFlatCoordsArray(t.data);
        this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)), a.prototype.init.apply(this, arguments)
    }, e.prototype.mergeOption = function (t) {
        if (wh(t), t.data) {
            var r = this._processFlatCoordsArray(t.data);
            this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count))
        }
        a.prototype.mergeOption.apply(this, arguments)
    }, e.prototype.appendData = function (t) {
        var r = this._processFlatCoordsArray(t.data);
        r.flatCoords && (this._flatCoords ? (this._flatCoords = qo(this._flatCoords, r.flatCoords), this._flatCoordsOffset = qo(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), t.data = new Float32Array(r.count)), this.getRawData().appendData(t.data)
    }, e.prototype._getCoordsFromItemModel = function (t) {
        var r = this.getData().getItemModel(t),
            i = r.option instanceof Array ? r.option : r.getShallow("coords");
        return i
    }, e.prototype.getLineCoordsCount = function (t) {
        return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length
    }, e.prototype.getLineCoords = function (t, r) {
        if (this._flatCoordsOffset) {
            for (var i = this._flatCoordsOffset[t * 2], n = this._flatCoordsOffset[t * 2 + 1], o = 0; o < n; o++) r[o] = r[o] || [], r[o][0] = this._flatCoords[i + o * 2], r[o][1] = this._flatCoords[i + o * 2 + 1];
            return n
        } else {
            for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++) r[o] = r[o] || [], r[o][0] = s[o][0], r[o][1] = s[o][1];
            return s.length
        }
    }, e.prototype._processFlatCoordsArray = function (t) {
        var r = 0;
        if (this._flatCoords && (r = this._flatCoords.length), te(t[0])) {
            for (var i = t.length, n = new WA(i), o = new $A(i), s = 0, l = 0, u = 0, v = 0; v < i;) {
                u++;
                var h = t[v++];
                n[l++] = s + r, n[l++] = h;
                for (var c = 0; c < h; c++) {
                    var f = t[v++],
                        p = t[v++];
                    o[s++] = f, o[s++] = p
                }
            }
            return {
                flatCoordsOffset: new Uint32Array(n.buffer, 0, l),
                flatCoords: o,
                count: u
            }
        }
        return {
            flatCoordsOffset: null,
            flatCoords: null,
            count: t.length
        }
    }, e.prototype.getInitialData = function (t, r) {
        var i = new Qt(["value"], this);
        return i.hasItemOption = !1, i.initData(t.data, [], function (n, o, s, l) {
            if (n instanceof Array) return NaN;
            i.hasItemOption = !0;
            var u = n.value;
            if (u != null) return u instanceof Array ? u[l] : u
        }), i
    }, e.prototype.formatTooltip = function (t, r, i) {
        var n = this.getData(),
            o = n.getItemModel(t),
            s = o.get("name");
        if (s) return s;
        var l = o.get("fromName"),
            u = o.get("toName"),
            v = [];
        return l != null && v.push(l), u != null && v.push(u), qt("nameValue", {
            name: v.join(" > ")
        })
    }, e.prototype.preventIncremental = function () {
        return !!this.get(["effect", "show"])
    }, e.prototype.getProgressive = function () {
        var t = this.option.progressive;
        return t ? ? (this.option.large ? 1e4 : this.get("progressive"))
    }, e.prototype.getProgressiveThreshold = function () {
        var t = this.option.progressiveThreshold;
        return t ? ? (this.option.large ? 2e4 : this.get("progressiveThreshold"))
    }, e.prototype.getZLevelKey = function () {
        var t = this.getModel("effect"),
            r = t.get("trailLength");
        return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && r > 0 ? r + "" : ""
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
        coordinateSystem: "geo",
        z: 2,
        legendHoverLink: !0,
        xAxisIndex: 0,
        yAxisIndex: 0,
        symbol: ["none", "none"],
        symbolSize: [10, 10],
        geoIndex: 0,
        effect: {
            show: !1,
            period: 4,
            constantSpeed: 0,
            symbol: "circle",
            symbolSize: 3,
            loop: !0,
            trailLength: .2
        },
        large: !1,
        largeThreshold: 2e3,
        polyline: !1,
        clip: !0,
        label: {
            show: !1,
            position: "end"
        },
        lineStyle: {
            opacity: .5
        }
    }, e
}(Vt);
const UA = ZA;

function ui(a) {
    return a instanceof Array || (a = [a, a]), a
}
var YA = {
    seriesType: "lines",
    reset: function (a) {
        var e = ui(a.get("symbol")),
            t = ui(a.get("symbolSize")),
            r = a.getData();
        r.setVisual("fromSymbol", e && e[0]), r.setVisual("toSymbol", e && e[1]), r.setVisual("fromSymbolSize", t && t[0]), r.setVisual("toSymbolSize", t && t[1]);

        function i(n, o) {
            var s = n.getItemModel(o),
                l = ui(s.getShallow("symbol", !0)),
                u = ui(s.getShallow("symbolSize", !0));
            l[0] && n.setItemVisual(o, "fromSymbol", l[0]), l[1] && n.setItemVisual(o, "toSymbol", l[1]), u[0] && n.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && n.setItemVisual(o, "toSymbolSize", u[1])
        }
        return {
            dataEach: r.hasItemOption ? i : null
        }
    }
};
const XA = YA;

function KA(a) {
    a.registerChartView(FA), a.registerSeriesModel(UA), a.registerLayout(Kd), a.registerVisual(XA)
}
var qA = 256,
    jA = function () {
        function a() {
            this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
                inRange: null,
                outOfRange: null
            };
            var e = Zo.createCanvas();
            this.canvas = e
        }
        return a.prototype.update = function (e, t, r, i, n, o) {
            var s = this._getBrush(),
                l = this._getGradient(n, "inRange"),
                u = this._getGradient(n, "outOfRange"),
                v = this.pointSize + this.blurSize,
                h = this.canvas,
                c = h.getContext("2d"),
                f = e.length;
            h.width = t, h.height = r;
            for (var p = 0; p < f; ++p) {
                var d = e[p],
                    g = d[0],
                    y = d[1],
                    x = d[2],
                    m = i(x);
                c.globalAlpha = m, c.drawImage(s, g - v, y - v)
            }
            if (!h.width || !h.height) return h;
            for (var S = c.getImageData(0, 0, h.width, h.height), _ = S.data, b = 0, w = _.length, A = this.minOpacity, C = this.maxOpacity, D = C - A; b < w;) {
                var m = _[b + 3] / 256,
                    I = Math.floor(m * (qA - 1)) * 4;
                if (m > 0) {
                    var L = o(m) ? l : u;
                    m > 0 && (m = m * D + A), _[b++] = L[I], _[b++] = L[I + 1], _[b++] = L[I + 2], _[b++] = L[I + 3] * m * 256
                } else b += 4
            }
            return c.putImageData(S, 0, 0), h
        }, a.prototype._getBrush = function () {
            var e = this._brushCanvas || (this._brushCanvas = Zo.createCanvas()),
                t = this.pointSize + this.blurSize,
                r = t * 2;
            e.width = r, e.height = r;
            var i = e.getContext("2d");
            return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), e
        }, a.prototype._getGradient = function (e, t) {
            for (var r = this._gradientPixels, i = r[t] || (r[t] = new Uint8ClampedArray(256 * 4)), n = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++) e[t](s / 255, !0, n), i[o++] = n[0], i[o++] = n[1], i[o++] = n[2], i[o++] = n[3];
            return i
        }, a
    }();
const JA = jA;

function QA(a, e, t) {
    var r = a[1] - a[0];
    e = G(e, function (o) {
        return {
            interval: [(o.interval[0] - a[0]) / r, (o.interval[1] - a[0]) / r]
        }
    });
    var i = e.length,
        n = 0;
    return function (o) {
        var s;
        for (s = n; s < i; s++) {
            var l = e[s].interval;
            if (l[0] <= o && o <= l[1]) {
                n = s;
                break
            }
        }
        if (s === i)
            for (s = n - 1; s >= 0; s--) {
                var l = e[s].interval;
                if (l[0] <= o && o <= l[1]) {
                    n = s;
                    break
                }
            }
        return s >= 0 && s < i && t[s]
    }
}

function tT(a, e) {
    var t = a[1] - a[0];
    return e = [(e[0] - a[0]) / t, (e[1] - a[0]) / t],
        function (r) {
            return r >= e[0] && r <= e[1]
        }
}

function Ah(a) {
    var e = a.dimensions;
    return e[0] === "lng" && e[1] === "lat"
}
var eT = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i) {
        var n;
        r.eachComponent("visualMap", function (s) {
            s.eachTargetSeries(function (l) {
                l === t && (n = s)
            })
        }), this._progressiveEls = null, this.group.removeAll();
        var o = t.coordinateSystem;
        o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : Ah(o) && this._renderOnGeo(o, t, n, i)
    }, e.prototype.incrementalPrepareRender = function (t, r, i) {
        this.group.removeAll()
    }, e.prototype.incrementalRender = function (t, r, i, n) {
        var o = r.coordinateSystem;
        o && (Ah(o) ? this.render(r, i, n) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, n, t.start, t.end, !0)))
    }, e.prototype.eachRendered = function (t) {
        Ga(this._progressiveEls || this.group, t)
    }, e.prototype._renderOnCartesianAndCalendar = function (t, r, i, n, o) {
        var s = t.coordinateSystem,
            l = Ba(s, "cartesian2d"),
            u, v, h, c;
        if (l) {
            var f = s.getAxis("x"),
                p = s.getAxis("y");
            u = f.getBandWidth() + .5, v = p.getBandWidth() + .5, h = f.scale.getExtent(), c = p.scale.getExtent()
        }
        for (var d = this.group, g = t.getData(), y = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), x = t.getModel(["blur", "itemStyle"]).getItemStyle(), m = t.getModel(["select", "itemStyle"]).getItemStyle(), S = t.get(["itemStyle", "borderRadius"]), _ = Gt(t), b = t.getModel("emphasis"), w = b.get("focus"), A = b.get("blurScope"), C = b.get("disabled"), D = l ? [g.mapDimension("x"), g.mapDimension("y"), g.mapDimension("value")] : [g.mapDimension("time"), g.mapDimension("value")], I = i; I < n; I++) {
            var L = void 0,
                M = g.getItemVisual(I, "style");
            if (l) {
                var P = g.get(D[0], I),
                    R = g.get(D[1], I);
                if (isNaN(g.get(D[2], I)) || isNaN(P) || isNaN(R) || P < h[0] || P > h[1] || R < c[0] || R > c[1]) continue;
                var k = s.dataToPoint([P, R]);
                L = new pt({
                    shape: {
                        x: k[0] - u / 2,
                        y: k[1] - v / 2,
                        width: u,
                        height: v
                    },
                    style: M
                })
            } else {
                if (isNaN(g.get(D[1], I))) continue;
                L = new pt({
                    z2: 1,
                    shape: s.dataToRect([g.get(D[0], I)]).contentShape,
                    style: M
                })
            }
            if (g.hasItemOption) {
                var V = g.getItemModel(I),
                    O = V.getModel("emphasis");
                y = O.getModel("itemStyle").getItemStyle(), x = V.getModel(["blur", "itemStyle"]).getItemStyle(), m = V.getModel(["select", "itemStyle"]).getItemStyle(), S = V.get(["itemStyle", "borderRadius"]), w = O.get("focus"), A = O.get("blurScope"), C = O.get("disabled"), _ = Gt(V)
            }
            L.shape.r = S;
            var z = t.getRawValue(I),
                $ = "-";
            z && z[2] != null && ($ = z[2] + ""), Xt(L, _, {
                labelFetcher: t,
                labelDataIndex: I,
                defaultOpacity: M.opacity,
                defaultText: $
            }), L.ensureState("emphasis").style = y, L.ensureState("blur").style = x, L.ensureState("select").style = m, Tt(L, w, A, C), L.incremental = o, o && (L.states.emphasis.hoverLayer = !0), d.add(L), g.setItemGraphicEl(I, L), this._progressiveEls && this._progressiveEls.push(L)
        }
    }, e.prototype._renderOnGeo = function (t, r, i, n) {
        var o = i.targetVisuals.inRange,
            s = i.targetVisuals.outOfRange,
            l = r.getData(),
            u = this._hmLayer || this._hmLayer || new JA;
        u.blurSize = r.get("blurSize"), u.pointSize = r.get("pointSize"), u.minOpacity = r.get("minOpacity"), u.maxOpacity = r.get("maxOpacity");
        var v = t.getViewRect().clone(),
            h = t.getRoamTransform();
        v.applyTransform(h);
        var c = Math.max(v.x, 0),
            f = Math.max(v.y, 0),
            p = Math.min(v.width + v.x, n.getWidth()),
            d = Math.min(v.height + v.y, n.getHeight()),
            g = p - c,
            y = d - f,
            x = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")],
            m = l.mapArray(x, function (w, A, C) {
                var D = t.dataToPoint([w, A]);
                return D[0] -= c, D[1] -= f, D.push(C), D
            }),
            S = i.getExtent(),
            _ = i.type === "visualMap.continuous" ? tT(S, i.option.range) : QA(S, i.getPieceList(), i.option.selected);
        u.update(m, g, y, o.color.getNormalizer(), {
            inRange: o.color.getColorMapper(),
            outOfRange: s.color.getColorMapper()
        }, _);
        var b = new ge({
            style: {
                width: g,
                height: y,
                x: c,
                y: f,
                image: u.canvas
            },
            silent: !0
        });
        this.group.add(b)
    }, e.type = "heatmap", e
}(At);
const rT = eT;
var aT = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.getInitialData = function (t, r) {
        return dr(null, this, {
            generateCoord: "value"
        })
    }, e.prototype.preventIncremental = function () {
        var t = ip.get(this.get("coordinateSystem"));
        if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat"
    }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = {
        coordinateSystem: "cartesian2d",
        z: 2,
        geoIndex: 0,
        blurSize: 30,
        pointSize: 20,
        maxOpacity: 1,
        minOpacity: 0,
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        }
    }, e
}(Vt);
const iT = aT;

function nT(a) {
    a.registerChartView(rT), a.registerSeriesModel(iT)
}
var oT = ["itemStyle", "borderWidth"],
    Th = [{
        xy: "x",
        wh: "width",
        index: 0,
        posDesc: ["left", "right"]
    }, {
        xy: "y",
        wh: "height",
        index: 1,
        posDesc: ["top", "bottom"]
    }],
    go = new nn,
    sT = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            var n = this.group,
                o = t.getData(),
                s = this._data,
                l = t.coordinateSystem,
                u = l.getBaseAxis(),
                v = u.isHorizontal(),
                h = l.master.getRect(),
                c = {
                    ecSize: {
                        width: i.getWidth(),
                        height: i.getHeight()
                    },
                    seriesModel: t,
                    coordSys: l,
                    coordSysExtent: [
                        [h.x, h.x + h.width],
                        [h.y, h.y + h.height]
                    ],
                    isHorizontal: v,
                    valueDim: Th[+v],
                    categoryDim: Th[1 - +v]
                };
            o.diff(s).add(function (p) {
                if (o.hasValue(p)) {
                    var d = Dh(o, p),
                        g = Ch(o, p, d, c),
                        y = Ih(o, c, g);
                    o.setItemGraphicEl(p, y), n.add(y), Mh(y, c, g)
                }
            }).update(function (p, d) {
                var g = s.getItemGraphicEl(d);
                if (!o.hasValue(p)) {
                    n.remove(g);
                    return
                }
                var y = Dh(o, p),
                    x = Ch(o, p, y, c),
                    m = eg(o, x);
                g && m !== g.__pictorialShapeStr && (n.remove(g), o.setItemGraphicEl(p, null), g = null), g ? pT(g, c, x) : g = Ih(o, c, x, !0), o.setItemGraphicEl(p, g), g.__pictorialSymbolMeta = x, n.add(g), Mh(g, c, x)
            }).remove(function (p) {
                var d = s.getItemGraphicEl(p);
                d && Lh(s, p, d.__pictorialSymbolMeta.animationModel, d)
            }).execute();
            var f = t.get("clip", !0) ? cn(t.coordinateSystem, !1, t) : null;
            return f ? n.setClipPath(f) : n.removeClipPath(), this._data = o, this.group
        }, e.prototype.remove = function (t, r) {
            var i = this.group,
                n = this._data;
            t.get("animation") ? n && n.eachItemGraphicEl(function (o) {
                Lh(n, tt(o).dataIndex, t, o)
            }) : i.removeAll()
        }, e.type = "pictorialBar", e
    }(At);

function Ch(a, e, t, r) {
    var i = a.getItemLayout(e),
        n = t.get("symbolRepeat"),
        o = t.get("symbolClip"),
        s = t.get("symbolPosition") || "start",
        l = t.get("symbolRotate"),
        u = (l || 0) * Math.PI / 180 || 0,
        v = t.get("symbolPatternSize") || 2,
        h = t.isAnimationEnabled(),
        c = {
            dataIndex: e,
            layout: i,
            itemModel: t,
            symbolType: a.getItemVisual(e, "symbol") || "circle",
            style: a.getItemVisual(e, "style"),
            symbolClip: o,
            symbolRepeat: n,
            symbolRepeatDirection: t.get("symbolRepeatDirection"),
            symbolPatternSize: v,
            rotation: u,
            animationModel: h ? t : null,
            hoverScale: h && t.get(["emphasis", "scale"]),
            z2: t.getShallow("z", !0) || 0
        };
    lT(t, n, i, r, c), uT(a, e, i, n, o, c.boundingLength, c.pxSign, v, r, c), vT(t, c.symbolScale, u, r, c);
    var f = c.symbolSize,
        p = jr(t.get("symbolOffset"), f);
    return hT(t, f, i, n, o, p, s, c.valueLineWidth, c.boundingLength, c.repeatCutLength, r, c), c
}

function lT(a, e, t, r, i) {
    var n = r.valueDim,
        o = a.get("symbolBoundingData"),
        s = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()),
        l = s.toGlobalCoord(s.dataToCoord(0)),
        u = 1 - +(t[n.wh] <= 0),
        v;
    if (B(o)) {
        var h = [yo(s, o[0]) - l, yo(s, o[1]) - l];
        h[1] < h[0] && h.reverse(), v = h[u]
    } else o != null ? v = yo(s, o) - l : e ? v = r.coordSysExtent[n.index][u] - l : v = t[n.wh];
    i.boundingLength = v, e && (i.repeatCutLength = t[n.wh]), i.pxSign = v > 0 ? 1 : -1
}

function yo(a, e) {
    return a.toGlobalCoord(a.dataToCoord(a.scale.parse(e)))
}

function uT(a, e, t, r, i, n, o, s, l, u) {
    var v = l.valueDim,
        h = l.categoryDim,
        c = Math.abs(t[h.wh]),
        f = a.getItemVisual(e, "symbolSize"),
        p;
    B(f) ? p = f.slice() : f == null ? p = ["100%", "100%"] : p = [f, f], p[h.index] = H(p[h.index], c), p[v.index] = H(p[v.index], r ? c : Math.abs(n)), u.symbolSize = p;
    var d = u.symbolScale = [p[0] / s, p[1] / s];
    d[v.index] *= (l.isHorizontal ? -1 : 1) * o
}

function vT(a, e, t, r, i) {
    var n = a.get(oT) || 0;
    n && (go.attr({
        scaleX: e[0],
        scaleY: e[1],
        rotation: t
    }), go.updateTransform(), n /= go.getLineScale(), n *= e[r.valueDim.index]), i.valueLineWidth = n || 0
}

function hT(a, e, t, r, i, n, o, s, l, u, v, h) {
    var c = v.categoryDim,
        f = v.valueDim,
        p = h.pxSign,
        d = Math.max(e[f.index] + s, 0),
        g = d;
    if (r) {
        var y = Math.abs(l),
            x = Ut(a.get("symbolMargin"), "15%") + "",
            m = !1;
        x.lastIndexOf("!") === x.length - 1 && (m = !0, x = x.slice(0, x.length - 1));
        var S = H(x, e[f.index]),
            _ = Math.max(d + S * 2, 0),
            b = m ? 0 : S * 2,
            w = Tm(r),
            A = w ? r : Ph((y + b) / _),
            C = y - A * d;
        S = C / 2 / (m ? A : Math.max(A - 1, 1)), _ = d + S * 2, b = m ? 0 : S * 2, !w && r !== "fixed" && (A = u ? Ph((Math.abs(u) + b) / _) : 0), g = A * _ - b, h.repeatTimes = A, h.symbolMargin = S
    }
    var D = p * (g / 2),
        I = h.pathPosition = [];
    I[c.index] = t[c.wh] / 2, I[f.index] = o === "start" ? D : o === "end" ? l - D : l / 2, n && (I[0] += n[0], I[1] += n[1]);
    var L = h.bundlePosition = [];
    L[c.index] = t[c.xy], L[f.index] = t[f.xy];
    var M = h.barRectShape = W({}, t);
    M[f.wh] = p * Math.max(Math.abs(t[f.wh]), Math.abs(I[f.index] + D)), M[c.wh] = t[c.wh];
    var P = h.clipShape = {};
    P[c.xy] = -t[c.xy], P[c.wh] = v.ecSize[c.wh], P[f.xy] = 0, P[f.wh] = t[f.wh]
}

function qd(a) {
    var e = a.symbolPatternSize,
        t = Et(a.symbolType, -e / 2, -e / 2, e, e);
    return t.attr({
        culling: !0
    }), t.type !== "image" && t.setStyle({
        strokeNoScale: !0
    }), t
}

function jd(a, e, t, r) {
    var i = a.__pictorialBundle,
        n = t.symbolSize,
        o = t.valueLineWidth,
        s = t.pathPosition,
        l = e.valueDim,
        u = t.repeatTimes || 0,
        v = 0,
        h = n[e.valueDim.index] + o + t.symbolMargin * 2;
    for (Pl(a, function (d) {
            d.__pictorialAnimationIndex = v, d.__pictorialRepeatTimes = u, v < u ? Gr(d, null, p(v), t, r) : Gr(d, null, {
                scaleX: 0,
                scaleY: 0
            }, t, r, function () {
                i.remove(d)
            }), v++
        }); v < u; v++) {
        var c = qd(t);
        c.__pictorialAnimationIndex = v, c.__pictorialRepeatTimes = u, i.add(c);
        var f = p(v);
        Gr(c, {
            x: f.x,
            y: f.y,
            scaleX: 0,
            scaleY: 0
        }, {
            scaleX: f.scaleX,
            scaleY: f.scaleY,
            rotation: f.rotation
        }, t, r)
    }

    function p(d) {
        var g = s.slice(),
            y = t.pxSign,
            x = d;
        return (t.symbolRepeatDirection === "start" ? y > 0 : y < 0) && (x = u - 1 - d), g[l.index] = h * (x - u / 2 + .5) + s[l.index], {
            x: g[0],
            y: g[1],
            scaleX: t.symbolScale[0],
            scaleY: t.symbolScale[1],
            rotation: t.rotation
        }
    }
}

function Jd(a, e, t, r) {
    var i = a.__pictorialBundle,
        n = a.__pictorialMainPath;
    n ? Gr(n, null, {
        x: t.pathPosition[0],
        y: t.pathPosition[1],
        scaleX: t.symbolScale[0],
        scaleY: t.symbolScale[1],
        rotation: t.rotation
    }, t, r) : (n = a.__pictorialMainPath = qd(t), i.add(n), Gr(n, {
        x: t.pathPosition[0],
        y: t.pathPosition[1],
        scaleX: 0,
        scaleY: 0,
        rotation: t.rotation
    }, {
        scaleX: t.symbolScale[0],
        scaleY: t.symbolScale[1]
    }, t, r))
}

function Qd(a, e, t) {
    var r = W({}, e.barRectShape),
        i = a.__pictorialBarRect;
    i ? Gr(i, null, {
        shape: r
    }, e, t) : (i = a.__pictorialBarRect = new pt({
        z2: 2,
        shape: r,
        silent: !0,
        style: {
            stroke: "transparent",
            fill: "transparent",
            lineWidth: 0
        }
    }), i.disableMorphing = !0, a.add(i))
}

function tg(a, e, t, r) {
    if (t.symbolClip) {
        var i = a.__pictorialClipPath,
            n = W({}, t.clipShape),
            o = e.valueDim,
            s = t.animationModel,
            l = t.dataIndex;
        if (i) yt(i, {
            shape: n
        }, s, l);
        else {
            n[o.wh] = 0, i = new pt({
                shape: n
            }), a.__pictorialBundle.setClipPath(i), a.__pictorialClipPath = i;
            var u = {};
            u[o.wh] = t.clipShape[o.wh], Qr[r ? "updateProps" : "initProps"](i, {
                shape: u
            }, s, l)
        }
    }
}

function Dh(a, e) {
    var t = a.getItemModel(e);
    return t.getAnimationDelayParams = cT, t.isAnimationEnabled = fT, t
}

function cT(a) {
    return {
        index: a.__pictorialAnimationIndex,
        count: a.__pictorialRepeatTimes
    }
}

function fT() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation")
}

function Ih(a, e, t, r) {
    var i = new U,
        n = new U;
    return i.add(n), i.__pictorialBundle = n, n.x = t.bundlePosition[0], n.y = t.bundlePosition[1], t.symbolRepeat ? jd(i, e, t) : Jd(i, e, t), Qd(i, t, r), tg(i, e, t, r), i.__pictorialShapeStr = eg(a, t), i.__pictorialSymbolMeta = t, i
}

function pT(a, e, t) {
    var r = t.animationModel,
        i = t.dataIndex,
        n = a.__pictorialBundle;
    yt(n, {
        x: t.bundlePosition[0],
        y: t.bundlePosition[1]
    }, r, i), t.symbolRepeat ? jd(a, e, t, !0) : Jd(a, e, t, !0), Qd(a, t, !0), tg(a, e, t, !0)
}

function Lh(a, e, t, r) {
    var i = r.__pictorialBarRect;
    i && i.removeTextContent();
    var n = [];
    Pl(r, function (o) {
        n.push(o)
    }), r.__pictorialMainPath && n.push(r.__pictorialMainPath), r.__pictorialClipPath && (t = null), T(n, function (o) {
        Fr(o, {
            scaleX: 0,
            scaleY: 0
        }, t, e, function () {
            r.parent && r.parent.remove(r)
        })
    }), a.setItemGraphicEl(e, null)
}

function eg(a, e) {
    return [a.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":")
}

function Pl(a, e, t) {
    T(a.__pictorialBundle.children(), function (r) {
        r !== a.__pictorialBarRect && e.call(t, r)
    })
}

function Gr(a, e, t, r, i, n) {
    e && a.attr(e), r.symbolClip && !i ? t && a.attr(t) : t && Qr[i ? "updateProps" : "initProps"](a, t, r.animationModel, r.dataIndex, n)
}

function Mh(a, e, t) {
    var r = t.dataIndex,
        i = t.itemModel,
        n = i.getModel("emphasis"),
        o = n.getModel("itemStyle").getItemStyle(),
        s = i.getModel(["blur", "itemStyle"]).getItemStyle(),
        l = i.getModel(["select", "itemStyle"]).getItemStyle(),
        u = i.getShallow("cursor"),
        v = n.get("focus"),
        h = n.get("blurScope"),
        c = n.get("scale");
    Pl(a, function (d) {
        if (d instanceof ge) {
            var g = d.style;
            d.useStyle(W({
                image: g.image,
                x: g.x,
                y: g.y,
                width: g.width,
                height: g.height
            }, t.style))
        } else d.useStyle(t.style);
        var y = d.ensureState("emphasis");
        y.style = o, c && (y.scaleX = d.scaleX * 1.1, y.scaleY = d.scaleY * 1.1), d.ensureState("blur").style = s, d.ensureState("select").style = l, u && (d.cursor = u), d.z2 = t.z2
    });
    var f = e.valueDim.posDesc[+(t.boundingLength > 0)],
        p = a.__pictorialBarRect;
    p.ignoreClip = !0, Xt(p, Gt(i), {
        labelFetcher: e.seriesModel,
        labelDataIndex: r,
        defaultText: wa(e.seriesModel.getData(), r),
        inheritColor: t.style.fill,
        defaultOpacity: t.style.opacity,
        defaultOutsidePosition: f
    }), Tt(a, v, h, n.get("disabled"))
}

function Ph(a) {
    var e = Math.round(a);
    return Math.abs(a - e) < 1e-4 ? e : Math.ceil(a)
}
const dT = sT;
var gT = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t
    }
    return e.prototype.getInitialData = function (t) {
        return t.stack = null, a.prototype.getInitialData.apply(this, arguments)
    }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = mr(xu.defaultOption, {
        symbol: "circle",
        symbolSize: null,
        symbolRotate: null,
        symbolPosition: null,
        symbolOffset: null,
        symbolMargin: null,
        symbolRepeat: !1,
        symbolRepeatDirection: "end",
        symbolClip: !1,
        symbolBoundingData: null,
        symbolPatternSize: 400,
        barGap: "-100%",
        clip: !1,
        progressive: 0,
        emphasis: {
            scale: !1
        },
        select: {
            itemStyle: {
                borderColor: "#212121"
            }
        }
    }), e
}(xu);
const yT = gT;

function mT(a) {
    a.registerChartView(dT), a.registerSeriesModel(yT), a.registerLayout(a.PRIORITY.VISUAL.LAYOUT, K(Dm, "pictorialBar")), a.registerLayout(a.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, Cm("pictorialBar"))
}
var xT = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t._layers = [], t
    }
    return e.prototype.render = function (t, r, i) {
        var n = t.getData(),
            o = this,
            s = this.group,
            l = t.getLayerSeries(),
            u = n.getLayout("layoutInfo"),
            v = u.rect,
            h = u.boundaryGap;
        s.x = 0, s.y = v.y + h[0];

        function c(g) {
            return g.name
        }
        var f = new Be(this._layersSeries || [], l, c, c),
            p = [];
        f.add(F(d, this, "add")).update(F(d, this, "update")).remove(F(d, this, "remove")).execute();

        function d(g, y, x) {
            var m = o._layers;
            if (g === "remove") {
                s.remove(m[y]);
                return
            }
            for (var S = [], _ = [], b, w = l[y].indices, A = 0; A < w.length; A++) {
                var C = n.getItemLayout(w[A]),
                    D = C.x,
                    I = C.y0,
                    L = C.y;
                S.push(D, I), _.push(D, I + L), b = n.getItemVisual(w[A], "style")
            }
            var M, P = n.getItemLayout(w[0]),
                R = t.getModel("label"),
                k = R.get("margin"),
                V = t.getModel("emphasis");
            if (g === "add") {
                var O = p[y] = new U;
                M = new Np({
                    shape: {
                        points: S,
                        stackedOnPoints: _,
                        smooth: .4,
                        stackedOnSmooth: .4,
                        smoothConstraint: !1
                    },
                    z2: 0
                }), O.add(M), s.add(O), t.isAnimationEnabled() && M.setClipPath(ST(M.getBoundingRect(), t, function () {
                    M.removeClipPath()
                }))
            } else {
                var O = m[x];
                M = O.childAt(0), s.add(O), p[y] = O, yt(M, {
                    shape: {
                        points: S,
                        stackedOnPoints: _
                    }
                }, t), gr(M)
            }
            Xt(M, Gt(t), {
                labelDataIndex: w[A - 1],
                defaultText: n.getName(w[A - 1]),
                inheritColor: b.fill
            }, {
                normal: {
                    verticalAlign: "middle"
                }
            }), M.setTextConfig({
                position: null,
                local: !0
            });
            var z = M.getTextContent();
            z && (z.x = P.x - k, z.y = P.y0 + P.y / 2), M.useStyle(b), n.setItemGraphicEl(y, M), ee(M, t), Tt(M, V.get("focus"), V.get("blurScope"), V.get("disabled"))
        }
        this._layersSeries = l, this._layers = p
    }, e.type = "themeRiver", e
}(At);

function ST(a, e, t) {
    var r = new pt({
        shape: {
            x: a.x - 10,
            y: a.y - 10,
            width: 0,
            height: a.height + 20
        }
    });
    return Yt(r, {
        shape: {
            x: a.x - 50,
            width: a.width + 100,
            height: a.height + 20
        }
    }, e, t), r
}
const _T = xT;
var mo = 2,
    bT = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function (t) {
            a.prototype.init.apply(this, arguments), this.legendVisualProvider = new Js(F(this.getData, this), F(this.getRawData, this))
        }, e.prototype.fixData = function (t) {
            var r = t.length,
                i = {},
                n = Qo(t, function (c) {
                    return i.hasOwnProperty(c[0] + "") || (i[c[0] + ""] = -1), c[2]
                }),
                o = [];
            n.buckets.each(function (c, f) {
                o.push({
                    name: f,
                    dataList: c
                })
            });
            for (var s = o.length, l = 0; l < s; ++l) {
                for (var u = o[l].name, v = 0; v < o[l].dataList.length; ++v) {
                    var h = o[l].dataList[v][0] + "";
                    i[h] = l
                }
                for (var h in i) i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, t[r] = [h, 0, u], r++)
            }
            return t
        }, e.prototype.getInitialData = function (t, r) {
            for (var i = this.getReferringComponents("singleAxis", Kt).models[0], n = i.get("type"), o = Dt(t.data, function (p) {
                    return p[2] !== void 0
                }), s = this.fixData(o || []), l = [], u = this.nameMap = Q(), v = 0, h = 0; h < s.length; ++h) l.push(s[h][mo]), u.get(s[h][mo]) || (u.set(s[h][mo], v), v++);
            var c = qs(s, {
                    coordDimensions: ["single"],
                    dimensionsDefine: [{
                        name: "time",
                        type: ts(n)
                    }, {
                        name: "value",
                        type: "float"
                    }, {
                        name: "name",
                        type: "ordinal"
                    }],
                    encodeDefine: {
                        single: 0,
                        value: 1,
                        itemName: 2
                    }
                }).dimensions,
                f = new Qt(c, this);
            return f.initData(s), f
        }, e.prototype.getLayerSeries = function () {
            for (var t = this.getData(), r = t.count(), i = [], n = 0; n < r; ++n) i[n] = n;
            var o = t.mapDimension("single"),
                s = Qo(i, function (u) {
                    return t.get("name", u)
                }),
                l = [];
            return s.buckets.each(function (u, v) {
                u.sort(function (h, c) {
                    return t.get(o, h) - t.get(o, c)
                }), l.push({
                    name: v,
                    indices: u
                })
            }), l
        }, e.prototype.getAxisTooltipData = function (t, r, i) {
            B(t) || (t = t ? [t] : []);
            for (var n = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, v = 0; v < l; ++v) {
                for (var h = Number.MAX_VALUE, c = -1, f = o[v].indices.length, p = 0; p < f; ++p) {
                    var d = n.get(t[0], o[v].indices[p]),
                        g = Math.abs(d - r);
                    g <= h && (u = d, h = g, c = o[v].indices[p])
                }
                s.push(c)
            }
            return {
                dataIndices: s,
                nestestValue: u
            }
        }, e.prototype.formatTooltip = function (t, r, i) {
            var n = this.getData(),
                o = n.getName(t),
                s = n.get(n.mapDimension("value"), t);
            return qt("nameValue", {
                name: o,
                value: s
            })
        }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = {
            z: 2,
            colorBy: "data",
            coordinateSystem: "singleAxis",
            boundaryGap: ["10%", "10%"],
            singleAxisIndex: 0,
            animationEasing: "linear",
            label: {
                margin: 4,
                show: !0,
                position: "left",
                fontSize: 11
            },
            emphasis: {
                label: {
                    show: !0
                }
            }
        }, e
    }(Vt);
const wT = bT;

function AT(a, e) {
    a.eachSeriesByType("themeRiver", function (t) {
        var r = t.getData(),
            i = t.coordinateSystem,
            n = {},
            o = i.getRect();
        n.rect = o;
        var s = t.get("boundaryGap"),
            l = i.getAxis();
        if (n.boundaryGap = s, l.orient === "horizontal") {
            s[0] = H(s[0], o.height), s[1] = H(s[1], o.height);
            var u = o.height - s[0] - s[1];
            Rh(r, t, u)
        } else {
            s[0] = H(s[0], o.width), s[1] = H(s[1], o.width);
            var v = o.width - s[0] - s[1];
            Rh(r, t, v)
        }
        r.setLayout("layoutInfo", n)
    })
}

function Rh(a, e, t) {
    if (a.count())
        for (var r = e.coordinateSystem, i = e.getLayerSeries(), n = a.mapDimension("single"), o = a.mapDimension("value"), s = G(i, function (g) {
                return G(g.indices, function (y) {
                    var x = r.dataToPoint(a.get(n, y));
                    return x[1] = a.get(o, y), x
                })
            }), l = TT(s), u = l.y0, v = t / l.max, h = i.length, c = i[0].indices.length, f, p = 0; p < c; ++p) {
            f = u[p] * v, a.setItemLayout(i[0].indices[p], {
                layerIndex: 0,
                x: s[0][p][0],
                y0: f,
                y: s[0][p][1] * v
            });
            for (var d = 1; d < h; ++d) f += s[d - 1][p][1] * v, a.setItemLayout(i[d].indices[p], {
                layerIndex: d,
                x: s[d][p][0],
                y0: f,
                y: s[d][p][1] * v
            })
        }
}

function TT(a) {
    for (var e = a.length, t = a[0].length, r = [], i = [], n = 0, o = 0; o < t; ++o) {
        for (var s = 0, l = 0; l < e; ++l) s += a[l][o][1];
        s > n && (n = s), r.push(s)
    }
    for (var u = 0; u < t; ++u) i[u] = (n - r[u]) / 2;
    n = 0;
    for (var v = 0; v < t; ++v) {
        var h = r[v] + i[v];
        h > n && (n = h)
    }
    return {
        y0: i,
        max: n
    }
}

function CT(a) {
    a.registerChartView(_T), a.registerSeriesModel(wT), a.registerLayout(AT), a.registerProcessor(Qs("themeRiver"))
}
var DT = 2,
    IT = 4,
    Eh = function (a) {
        E(e, a);

        function e(t, r, i, n) {
            var o = a.call(this) || this;
            o.z2 = DT, o.textConfig = {
                inside: !0
            }, tt(o).seriesIndex = r.seriesIndex;
            var s = new ut({
                z2: IT,
                silent: t.getModel().get(["label", "silent"])
            });
            return o.setTextContent(s), o.updateData(!0, t, r, i, n), o
        }
        return e.prototype.updateData = function (t, r, i, n, o) {
            this.node = r, r.piece = this, i = i || this._seriesModel, n = n || this._ecModel;
            var s = this;
            tt(s).dataIndex = r.dataIndex;
            var l = r.getModel(),
                u = l.getModel("emphasis"),
                v = r.getLayout(),
                h = W({}, v);
            h.label = null;
            var c = r.getVisual("style");
            c.lineJoin = "bevel";
            var f = r.getVisual("decal");
            f && (c.decal = on(f, o));
            var p = Su(l.getModel("itemStyle"), h, !0);
            W(h, p), T(Aa, function (x) {
                var m = s.ensureState(x),
                    S = l.getModel([x, "itemStyle"]);
                m.style = S.getItemStyle();
                var _ = Su(S, h);
                _ && (m.shape = _)
            }), t ? (s.setShape(h), s.shape.r = v.r0, Yt(s, {
                shape: {
                    r: v.r
                }
            }, i, r.dataIndex)) : (yt(s, {
                shape: h
            }, i), gr(s)), s.useStyle(c), this._updateLabel(i);
            var d = l.getShallow("cursor");
            d && s.attr("cursor", d), this._seriesModel = i || this._seriesModel, this._ecModel = n || this._ecModel;
            var g = u.get("focus"),
                y = g === "ancestor" ? r.getAncestorsIndices() : g === "descendant" ? r.getDescendantIndices() : g;
            Tt(this, y, u.get("blurScope"), u.get("disabled"))
        }, e.prototype._updateLabel = function (t) {
            var r = this,
                i = this.node.getModel(),
                n = i.getModel("label"),
                o = this.node.getLayout(),
                s = o.endAngle - o.startAngle,
                l = (o.startAngle + o.endAngle) / 2,
                u = Math.cos(l),
                v = Math.sin(l),
                h = this,
                c = h.getTextContent(),
                f = this.node.dataIndex,
                p = n.get("minAngle") / 180 * Math.PI,
                d = n.get("show") && !(p != null && Math.abs(s) < p);
            c.ignore = !d, T(Im, function (y) {
                var x = y === "normal" ? i.getModel("label") : i.getModel([y, "label"]),
                    m = y === "normal",
                    S = m ? c : c.ensureState(y),
                    _ = t.getFormattedLabel(f, y);
                m && (_ = _ || r.node.name), S.style = mt(x, {}, null, y !== "normal", !0), _ && (S.style.text = _);
                var b = x.get("show");
                b != null && !m && (S.ignore = !b);
                var w = g(x, "position"),
                    A = m ? h : h.states[y],
                    C = A.style.fill;
                A.textConfig = {
                    outsideFill: x.get("color") === "inherit" ? C : null,
                    inside: w !== "outside"
                };
                var D, I = g(x, "distance") || 0,
                    L = g(x, "align"),
                    M = g(x, "rotate"),
                    P = Math.PI * .5,
                    R = Math.PI * 1.5,
                    k = ua(M === "tangential" ? Math.PI / 2 - l : l),
                    V = k > P && !Lm(k - P) && k < R;
                w === "outside" ? (D = o.r + I, L = V ? "right" : "left") : !L || L === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? D = 0 : D = (o.r + o.r0) / 2, L = "center") : L === "left" ? (D = o.r0 + I, L = V ? "right" : "left") : L === "right" && (D = o.r - I, L = V ? "left" : "right"), S.style.align = L, S.style.verticalAlign = g(x, "verticalAlign") || "middle", S.x = D * u + o.cx, S.y = D * v + o.cy;
                var O = 0;
                M === "radial" ? O = ua(-l) + (V ? Math.PI : 0) : M === "tangential" ? O = ua(Math.PI / 2 - l) + (V ? Math.PI : 0) : te(M) && (O = M * Math.PI / 180), S.rotation = ua(O)
            });

            function g(y, x) {
                var m = y.get(x);
                return m ? ? n.get(x)
            }
            c.dirtyStyle()
        }, e
    }(cr),
    Ts = "sunburstRootToNode",
    kh = "sunburstHighlight",
    LT = "sunburstUnhighlight";

function MT(a) {
    a.registerAction({
        type: Ts,
        update: "updateView"
    }, function (e, t) {
        t.eachComponent({
            mainType: "series",
            subType: "sunburst",
            query: e
        }, r);

        function r(i, n) {
            var o = Ma(e, [Ts], i);
            if (o) {
                var s = i.getViewRoot();
                s && (e.direction = gl(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node)
            }
        }
    }), a.registerAction({
        type: kh,
        update: "none"
    }, function (e, t, r) {
        e = W({}, e), t.eachComponent({
            mainType: "series",
            subType: "sunburst",
            query: e
        }, i);

        function i(n) {
            var o = Ma(e, [kh], n);
            o && (e.dataIndex = o.node.dataIndex)
        }
        r.dispatchAction(W(e, {
            type: "highlight"
        }))
    }), a.registerAction({
        type: LT,
        update: "updateView"
    }, function (e, t, r) {
        e = W({}, e), r.dispatchAction(W(e, {
            type: "downplay"
        }))
    })
}
var PT = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i, n) {
        var o = this;
        this.seriesModel = t, this.api = i, this.ecModel = r;
        var s = t.getData(),
            l = s.tree.root,
            u = t.getViewRoot(),
            v = this.group,
            h = t.get("renderLabelForZeroData"),
            c = [];
        u.eachNode(function (x) {
            c.push(x)
        });
        var f = this._oldChildren || [];
        p(c, f), y(l, u), this._initEvents(), this._oldChildren = c;

        function p(x, m) {
            if (x.length === 0 && m.length === 0) return;
            new Be(m, x, S, S).add(_).update(_).remove(K(_, null)).execute();

            function S(b) {
                return b.getId()
            }

            function _(b, w) {
                var A = b == null ? null : x[b],
                    C = w == null ? null : m[w];
                d(A, C)
            }
        }

        function d(x, m) {
            if (!h && x && !x.getValue() && (x = null), x !== l && m !== l) {
                if (m && m.piece) x ? (m.piece.updateData(!1, x, t, r, i), s.setItemGraphicEl(x.dataIndex, m.piece)) : g(m);
                else if (x) {
                    var S = new Eh(x, t, r, i);
                    v.add(S), s.setItemGraphicEl(x.dataIndex, S)
                }
            }
        }

        function g(x) {
            x && x.piece && (v.remove(x.piece), x.piece = null)
        }

        function y(x, m) {
            m.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, x, t, r, i) : (o.virtualPiece = new Eh(x, t, r, i), v.add(o.virtualPiece)), m.piece.off("click"), o.virtualPiece.on("click", function (S) {
                o._rootToNode(m.parentNode)
            })) : o.virtualPiece && (v.remove(o.virtualPiece), o.virtualPiece = null)
        }
    }, e.prototype._initEvents = function () {
        var t = this;
        this.group.off("click"), this.group.on("click", function (r) {
            var i = !1,
                n = t.seriesModel.getViewRoot();
            n.eachNode(function (o) {
                if (!i && o.piece && o.piece === r.target) {
                    var s = o.getModel().get("nodeClick");
                    if (s === "rootToNode") t._rootToNode(o);
                    else if (s === "link") {
                        var l = o.getModel(),
                            u = l.get("link");
                        if (u) {
                            var v = l.get("target", !0) || "_blank";
                            Ci(u, v)
                        }
                    }
                    i = !0
                }
            })
        })
    }, e.prototype._rootToNode = function (t) {
        t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
            type: Ts,
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: t
        })
    }, e.prototype.containPoint = function (t, r) {
        var i = r.getData(),
            n = i.getItemLayout(0);
        if (n) {
            var o = t[0] - n.cx,
                s = t[1] - n.cy,
                l = Math.sqrt(o * o + s * s);
            return l <= n.r && l >= n.r0
        }
    }, e.type = "sunburst", e
}(At);
const RT = PT;
var ET = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.ignoreStyleOnData = !0, t
    }
    return e.prototype.getInitialData = function (t, r) {
        var i = {
            name: t.name,
            children: t.data
        };
        rg(i);
        var n = this._levelModels = G(t.levels || [], function (l) {
                return new Rt(l, this, r)
            }, this),
            o = dl.createTree(i, this, s);

        function s(l) {
            l.wrapMethod("getItemModel", function (u, v) {
                var h = o.getNodeByDataIndex(v),
                    c = n[h.depth];
                return c && (u.parentModel = c), u
            })
        }
        return o.data
    }, e.prototype.optionUpdated = function () {
        this.resetViewRoot()
    }, e.prototype.getDataParams = function (t) {
        var r = a.prototype.getDataParams.apply(this, arguments),
            i = this.getData().tree.getNodeByDataIndex(t);
        return r.treePathInfo = xn(i, this), r
    }, e.prototype.getLevelModel = function (t) {
        return this._levelModels && this._levelModels[t.depth]
    }, e.prototype.getViewRoot = function () {
        return this._viewRoot
    }, e.prototype.resetViewRoot = function (t) {
        t ? this._viewRoot = t : t = this._viewRoot;
        var r = this.getRawData().tree.root;
        (!t || t !== r && !r.contains(t)) && (this._viewRoot = r)
    }, e.prototype.enableAriaDecal = function () {
        od(this)
    }, e.type = "series.sunburst", e.defaultOption = {
        z: 2,
        center: ["50%", "50%"],
        radius: [0, "75%"],
        clockwise: !0,
        startAngle: 90,
        minAngle: 0,
        stillShowZeroSum: !0,
        nodeClick: "rootToNode",
        renderLabelForZeroData: !1,
        label: {
            rotate: "radial",
            show: !0,
            opacity: 1,
            align: "center",
            position: "inside",
            distance: 5,
            silent: !0
        },
        itemStyle: {
            borderWidth: 1,
            borderColor: "white",
            borderType: "solid",
            shadowBlur: 0,
            shadowColor: "rgba(0, 0, 0, 0.2)",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            opacity: 1
        },
        emphasis: {
            focus: "descendant"
        },
        blur: {
            itemStyle: {
                opacity: .2
            },
            label: {
                opacity: .1
            }
        },
        animationType: "expansion",
        animationDuration: 1e3,
        animationDurationUpdate: 500,
        data: [],
        sort: "desc"
    }, e
}(Vt);

function rg(a) {
    var e = 0;
    T(a.children, function (r) {
        rg(r);
        var i = r.value;
        B(i) && (i = i[0]), e += i
    });
    var t = a.value;
    B(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), B(a.value) ? a.value[0] = t : a.value = t
}
const kT = ET;
var Vh = Math.PI / 180;

function VT(a, e, t) {
    e.eachSeriesByType(a, function (r) {
        var i = r.get("center"),
            n = r.get("radius");
        B(n) || (n = [0, n]), B(i) || (i = [i, i]);
        var o = t.getWidth(),
            s = t.getHeight(),
            l = Math.min(o, s),
            u = H(i[0], o),
            v = H(i[1], s),
            h = H(n[0], l / 2),
            c = H(n[1], l / 2),
            f = -r.get("startAngle") * Vh,
            p = r.get("minAngle") * Vh,
            d = r.getData().tree.root,
            g = r.getViewRoot(),
            y = g.depth,
            x = r.get("sort");
        x != null && ag(g, x);
        var m = 0;
        T(g.children, function (k) {
            !isNaN(k.getValue()) && m++
        });
        var S = g.getValue(),
            _ = Math.PI / (S || m) * 2,
            b = g.depth > 0,
            w = g.height - (b ? -1 : 1),
            A = (c - h) / (w || 1),
            C = r.get("clockwise"),
            D = r.get("stillShowZeroSum"),
            I = C ? 1 : -1,
            L = function (k, V) {
                if (k) {
                    var O = V;
                    if (k !== d) {
                        var z = k.getValue(),
                            $ = S === 0 && D ? _ : z * _;
                        $ < p && ($ = p), O = V + I * $;
                        var Z = k.depth - y - (b ? -1 : 1),
                            et = h + A * Z,
                            J = h + A * (Z + 1),
                            X = r.getLevelModel(k);
                        if (X) {
                            var nt = X.get("r0", !0),
                                st = X.get("r", !0),
                                it = X.get("radius", !0);
                            it != null && (nt = it[0], st = it[1]), nt != null && (et = H(nt, l / 2)), st != null && (J = H(st, l / 2))
                        }
                        k.setLayout({
                            angle: $,
                            startAngle: V,
                            endAngle: O,
                            clockwise: C,
                            cx: u,
                            cy: v,
                            r0: et,
                            r: J
                        })
                    }
                    if (k.children && k.children.length) {
                        var Y = 0;
                        T(k.children, function (vt) {
                            Y += L(vt, V + Y)
                        })
                    }
                    return O - V
                }
            };
        if (b) {
            var M = h,
                P = h + A,
                R = Math.PI * 2;
            d.setLayout({
                angle: R,
                startAngle: f,
                endAngle: f + R,
                clockwise: C,
                cx: u,
                cy: v,
                r0: M,
                r: P
            })
        }
        L(g, f)
    })
}

function ag(a, e) {
    var t = a.children || [];
    a.children = OT(t, e), t.length && T(a.children, function (r) {
        ag(r, e)
    })
}

function OT(a, e) {
    if (rt(e)) {
        var t = G(a, function (i, n) {
            var o = i.getValue();
            return {
                params: {
                    depth: i.depth,
                    height: i.height,
                    dataIndex: i.dataIndex,
                    getValue: function () {
                        return o
                    }
                },
                index: n
            }
        });
        return t.sort(function (i, n) {
            return e(i.params, n.params)
        }), G(t, function (i) {
            return a[i.index]
        })
    } else {
        var r = e === "asc";
        return a.sort(function (i, n) {
            var o = (i.getValue() - n.getValue()) * (r ? 1 : -1);
            return o === 0 ? (i.dataIndex - n.dataIndex) * (r ? -1 : 1) : o
        })
    }
}

function zT(a) {
    var e = {};

    function t(r, i, n) {
        for (var o = r; o && o.depth > 1;) o = o.parentNode;
        var s = i.getColorFromPalette(o.name || o.dataIndex + "", e);
        return r.depth > 1 && q(s) && (s = Mm(s, (r.depth - 1) / (n - 1) * .5)), s
    }
    a.eachSeriesByType("sunburst", function (r) {
        var i = r.getData(),
            n = i.tree;
        n.eachNode(function (o) {
            var s = o.getModel(),
                l = s.getModel("itemStyle").getItemStyle();
            l.fill || (l.fill = t(o, r, n.root.height));
            var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
            W(u, l)
        })
    })
}

function NT(a) {
    a.registerChartView(RT), a.registerSeriesModel(kT), a.registerLayout(K(VT, "sunburst")), a.registerProcessor(K(Qs, "sunburst")), a.registerVisual(zT), MT(a)
}
var Oh = {
        color: "fill",
        borderColor: "stroke"
    },
    GT = {
        symbol: 1,
        symbolSize: 1,
        symbolKeepAspect: 1,
        legendIcon: 1,
        visualMeta: 1,
        liftZ: 1,
        decal: 1
    },
    Ae = xt(),
    BT = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.optionUpdated = function () {
            this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0)
        }, e.prototype.getInitialData = function (t, r) {
            return dr(null, this)
        }, e.prototype.getDataParams = function (t, r, i) {
            var n = a.prototype.getDataParams.call(this, t, r);
            return i && (n.info = Ae(i).info), n
        }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
            coordinateSystem: "cartesian2d",
            z: 2,
            legendHoverLink: !0,
            clip: !1
        }, e
    }(Vt);
const HT = BT;

function FT(a, e) {
    return e = e || [0, 0], G(["x", "y"], function (t, r) {
        var i = this.getAxis(t),
            n = e[r],
            o = a[r] / 2;
        return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(n - o) - i.dataToCoord(n + o))
    }, this)
}

function WT(a) {
    var e = a.master.getRect();
    return {
        coordSys: {
            type: "cartesian2d",
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height
        },
        api: {
            coord: function (t) {
                return a.dataToPoint(t)
            },
            size: F(FT, a)
        }
    }
}

function $T(a, e) {
    return e = e || [0, 0], G([0, 1], function (t) {
        var r = e[t],
            i = a[t] / 2,
            n = [],
            o = [];
        return n[t] = r - i, o[t] = r + i, n[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(n)[t] - this.dataToPoint(o)[t])
    }, this)
}

function ZT(a) {
    var e = a.getBoundingRect();
    return {
        coordSys: {
            type: "geo",
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height,
            zoom: a.getZoom()
        },
        api: {
            coord: function (t) {
                return a.dataToPoint(t)
            },
            size: F($T, a)
        }
    }
}

function UT(a, e) {
    var t = this.getAxis(),
        r = e instanceof Array ? e[0] : e,
        i = (a instanceof Array ? a[0] : a) / 2;
    return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(r - i) - t.dataToCoord(r + i))
}

function YT(a) {
    var e = a.getRect();
    return {
        coordSys: {
            type: "singleAxis",
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height
        },
        api: {
            coord: function (t) {
                return a.dataToPoint(t)
            },
            size: F(UT, a)
        }
    }
}

function XT(a, e) {
    return e = e || [0, 0], G(["Radius", "Angle"], function (t, r) {
        var i = "get" + t + "Axis",
            n = this[i](),
            o = e[r],
            s = a[r] / 2,
            l = n.type === "category" ? n.getBandWidth() : Math.abs(n.dataToCoord(o - s) - n.dataToCoord(o + s));
        return t === "Angle" && (l = l * Math.PI / 180), l
    }, this)
}

function KT(a) {
    var e = a.getRadiusAxis(),
        t = a.getAngleAxis(),
        r = e.getExtent();
    return r[0] > r[1] && r.reverse(), {
        coordSys: {
            type: "polar",
            cx: a.cx,
            cy: a.cy,
            r: r[1],
            r0: r[0]
        },
        api: {
            coord: function (i) {
                var n = e.dataToRadius(i[0]),
                    o = t.dataToAngle(i[1]),
                    s = a.coordToPoint([n, o]);
                return s.push(n, o * Math.PI / 180), s
            },
            size: F(XT, a)
        }
    }
}

function qT(a) {
    var e = a.getRect(),
        t = a.getRangeInfo();
    return {
        coordSys: {
            type: "calendar",
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height,
            cellWidth: a.getCellWidth(),
            cellHeight: a.getCellHeight(),
            rangeInfo: {
                start: t.start,
                end: t.end,
                weeks: t.weeks,
                dayCount: t.allDay
            }
        },
        api: {
            coord: function (r, i) {
                return a.dataToPoint(r, i)
            }
        }
    }
}

function ig(a, e, t, r) {
    return a && (a.legacy || a.legacy !== !1 && !t && !r && e !== "tspan" && (e === "text" || N(a, "text")))
}

function ng(a, e, t) {
    var r = a,
        i, n, o;
    if (e === "text") o = r;
    else {
        o = {}, N(r, "text") && (o.text = r.text), N(r, "rich") && (o.rich = r.rich), N(r, "textFill") && (o.fill = r.textFill), N(r, "textStroke") && (o.stroke = r.textStroke), N(r, "fontFamily") && (o.fontFamily = r.fontFamily), N(r, "fontSize") && (o.fontSize = r.fontSize), N(r, "fontStyle") && (o.fontStyle = r.fontStyle), N(r, "fontWeight") && (o.fontWeight = r.fontWeight), n = {
            type: "text",
            style: o,
            silent: !0
        }, i = {};
        var s = N(r, "textPosition");
        t ? i.position = s ? r.textPosition : "inside" : s && (i.position = r.textPosition), N(r, "textPosition") && (i.position = r.textPosition), N(r, "textOffset") && (i.offset = r.textOffset), N(r, "textRotation") && (i.rotation = r.textRotation), N(r, "textDistance") && (i.distance = r.textDistance)
    }
    return zh(o, a), T(o.rich, function (l) {
        zh(l, l)
    }), {
        textConfig: i,
        textContent: n
    }
}

function zh(a, e) {
    e && (e.font = e.textFont || e.font, N(e, "textStrokeWidth") && (a.lineWidth = e.textStrokeWidth), N(e, "textAlign") && (a.align = e.textAlign), N(e, "textVerticalAlign") && (a.verticalAlign = e.textVerticalAlign), N(e, "textLineHeight") && (a.lineHeight = e.textLineHeight), N(e, "textWidth") && (a.width = e.textWidth), N(e, "textHeight") && (a.height = e.textHeight), N(e, "textBackgroundColor") && (a.backgroundColor = e.textBackgroundColor), N(e, "textPadding") && (a.padding = e.textPadding), N(e, "textBorderColor") && (a.borderColor = e.textBorderColor), N(e, "textBorderWidth") && (a.borderWidth = e.textBorderWidth), N(e, "textBorderRadius") && (a.borderRadius = e.textBorderRadius), N(e, "textBoxShadowColor") && (a.shadowColor = e.textBoxShadowColor), N(e, "textBoxShadowBlur") && (a.shadowBlur = e.textBoxShadowBlur), N(e, "textBoxShadowOffsetX") && (a.shadowOffsetX = e.textBoxShadowOffsetX), N(e, "textBoxShadowOffsetY") && (a.shadowOffsetY = e.textBoxShadowOffsetY))
}

function Nh(a, e, t) {
    var r = a;
    r.textPosition = r.textPosition || t.position || "inside", t.offset != null && (r.textOffset = t.offset), t.rotation != null && (r.textRotation = t.rotation), t.distance != null && (r.textDistance = t.distance);
    var i = r.textPosition.indexOf("inside") >= 0,
        n = a.fill || "#000";
    Gh(r, e);
    var o = r.textFill == null;
    return i ? o && (r.textFill = t.insideFill || "#fff", !r.textStroke && t.insideStroke && (r.textStroke = t.insideStroke), !r.textStroke && (r.textStroke = n), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (o && (r.textFill = a.fill || t.outsideFill || "#000"), !r.textStroke && t.outsideStroke && (r.textStroke = t.outsideStroke)), r.text = e.text, r.rich = e.rich, T(e.rich, function (s) {
        Gh(s, s)
    }), r
}

function Gh(a, e) {
    e && (N(e, "fill") && (a.textFill = e.fill), N(e, "stroke") && (a.textStroke = e.fill), N(e, "lineWidth") && (a.textStrokeWidth = e.lineWidth), N(e, "font") && (a.font = e.font), N(e, "fontStyle") && (a.fontStyle = e.fontStyle), N(e, "fontWeight") && (a.fontWeight = e.fontWeight), N(e, "fontSize") && (a.fontSize = e.fontSize), N(e, "fontFamily") && (a.fontFamily = e.fontFamily), N(e, "align") && (a.textAlign = e.align), N(e, "verticalAlign") && (a.textVerticalAlign = e.verticalAlign), N(e, "lineHeight") && (a.textLineHeight = e.lineHeight), N(e, "width") && (a.textWidth = e.width), N(e, "height") && (a.textHeight = e.height), N(e, "backgroundColor") && (a.textBackgroundColor = e.backgroundColor), N(e, "padding") && (a.textPadding = e.padding), N(e, "borderColor") && (a.textBorderColor = e.borderColor), N(e, "borderWidth") && (a.textBorderWidth = e.borderWidth), N(e, "borderRadius") && (a.textBorderRadius = e.borderRadius), N(e, "shadowColor") && (a.textBoxShadowColor = e.shadowColor), N(e, "shadowBlur") && (a.textBoxShadowBlur = e.shadowBlur), N(e, "shadowOffsetX") && (a.textBoxShadowOffsetX = e.shadowOffsetX), N(e, "shadowOffsetY") && (a.textBoxShadowOffsetY = e.shadowOffsetY), N(e, "textShadowColor") && (a.textShadowColor = e.textShadowColor), N(e, "textShadowBlur") && (a.textShadowBlur = e.textShadowBlur), N(e, "textShadowOffsetX") && (a.textShadowOffsetX = e.textShadowOffsetX), N(e, "textShadowOffsetY") && (a.textShadowOffsetY = e.textShadowOffsetY))
}
var og = {
        position: ["x", "y"],
        scale: ["scaleX", "scaleY"],
        origin: ["originX", "originY"]
    },
    Bh = wt(og);
Qf(Ca, function (a, e) {
    return a[e] = 1, a
}, {});
Ca.join(", ");
var zi = ["", "style", "shape", "extra"],
    Kr = xt();

function Rl(a, e, t, r, i) {
    var n = a + "Animation",
        o = Za(a, r, i) || {},
        s = Kr(e).userDuring;
    return o.duration > 0 && (o.during = s ? F(eC, {
        el: e,
        userDuring: s
    }) : null, o.setToFinal = !0, o.scope = a), W(o, t[n]), o
}

function _i(a, e, t, r) {
    r = r || {};
    var i = r.dataIndex,
        n = r.isInit,
        o = r.clearStyle,
        s = t.isAnimationEnabled(),
        l = Kr(a),
        u = e.style;
    l.userDuring = e.during;
    var v = {},
        h = {};
    if (aC(a, e, h), Fh("shape", e, h), Fh("extra", e, h), !n && s && (rC(a, e, v), Hh("shape", a, e, v), Hh("extra", a, e, v), iC(a, e, u, v)), h.style = u, jT(a, h, o), QT(a, e), s)
        if (n) {
            var c = {};
            T(zi, function (p) {
                var d = p ? e[p] : e;
                d && d.enterFrom && (p && (c[p] = c[p] || {}), W(p ? c[p] : c, d.enterFrom))
            });
            var f = Rl("enter", a, e, t, i);
            f.duration > 0 && a.animateFrom(c, f)
        } else JT(a, e, i || 0, t, v);
    sg(a, e), u ? a.dirty() : a.markRedraw()
}

function sg(a, e) {
    for (var t = Kr(a).leaveToProps, r = 0; r < zi.length; r++) {
        var i = zi[r],
            n = i ? e[i] : e;
        n && n.leaveTo && (t || (t = Kr(a).leaveToProps = {}), i && (t[i] = t[i] || {}), W(i ? t[i] : t, n.leaveTo))
    }
}

function bn(a, e, t, r) {
    if (a) {
        var i = a.parent,
            n = Kr(a).leaveToProps;
        if (n) {
            var o = Rl("update", a, e, t, 0);
            o.done = function () {
                i.remove(a), r && r()
            }, a.animateTo(n, o)
        } else i.remove(a), r && r()
    }
}

function ur(a) {
    return a === "all"
}

function jT(a, e, t) {
    var r = e.style;
    if (!a.isGroup && r) {
        if (t) {
            a.useStyle({});
            for (var i = a.animators, n = 0; n < i.length; n++) {
                var o = i[n];
                o.targetName === "style" && o.changeTarget(a.style)
            }
        }
        a.setStyle(r)
    }
    e && (e.style = null, e && a.attr(e), e.style = r)
}

function JT(a, e, t, r, i) {
    if (i) {
        var n = Rl("update", a, e, r, t);
        n.duration > 0 && a.animateFrom(i, n)
    }
}

function QT(a, e) {
    N(e, "silent") && (a.silent = e.silent), N(e, "ignore") && (a.ignore = e.ignore), a instanceof hr && N(e, "invisible") && (a.invisible = e.invisible), a instanceof Pt && N(e, "autoBatch") && (a.autoBatch = e.autoBatch)
}
var he = {},
    tC = {
        setTransform: function (a, e) {
            return he.el[a] = e, this
        },
        getTransform: function (a) {
            return he.el[a]
        },
        setShape: function (a, e) {
            var t = he.el,
                r = t.shape || (t.shape = {});
            return r[a] = e, t.dirtyShape && t.dirtyShape(), this
        },
        getShape: function (a) {
            var e = he.el.shape;
            if (e) return e[a]
        },
        setStyle: function (a, e) {
            var t = he.el,
                r = t.style;
            return r && (r[a] = e, t.dirtyStyle && t.dirtyStyle()), this
        },
        getStyle: function (a) {
            var e = he.el.style;
            if (e) return e[a]
        },
        setExtra: function (a, e) {
            var t = he.el.extra || (he.el.extra = {});
            return t[a] = e, this
        },
        getExtra: function (a) {
            var e = he.el.extra;
            if (e) return e[a]
        }
    };

function eC() {
    var a = this,
        e = a.el;
    if (e) {
        var t = Kr(e).userDuring,
            r = a.userDuring;
        if (t !== r) {
            a.el = a.userDuring = null;
            return
        }
        he.el = e, r(tC)
    }
}

function Hh(a, e, t, r) {
    var i = t[a];
    if (i) {
        var n = e[a],
            o;
        if (n) {
            var s = t.transition,
                l = i.transition;
            if (l)
                if (!o && (o = r[a] = {}), ur(l)) W(o, n);
                else
                    for (var u = Wt(l), v = 0; v < u.length; v++) {
                        var h = u[v],
                            c = n[h];
                        o[h] = c
                    } else if (ur(s) || ft(s, a) >= 0) {
                        !o && (o = r[a] = {});
                        for (var f = wt(n), v = 0; v < f.length; v++) {
                            var h = f[v],
                                c = n[h];
                            nC(i[h], c) && (o[h] = c)
                        }
                    }
        }
    }
}

function Fh(a, e, t) {
    var r = e[a];
    if (r)
        for (var i = t[a] = {}, n = wt(r), o = 0; o < n.length; o++) {
            var s = n[o];
            i[s] = Pm(r[s])
        }
}

function rC(a, e, t) {
    for (var r = e.transition, i = ur(r) ? Ca : Wt(r || []), n = 0; n < i.length; n++) {
        var o = i[n];
        if (!(o === "style" || o === "shape" || o === "extra")) {
            var s = a[o];
            t[o] = s
        }
    }
}

function aC(a, e, t) {
    for (var r = 0; r < Bh.length; r++) {
        var i = Bh[r],
            n = og[i],
            o = e[i];
        o && (t[n[0]] = o[0], t[n[1]] = o[1])
    }
    for (var r = 0; r < Ca.length; r++) {
        var s = Ca[r];
        e[s] != null && (t[s] = e[s])
    }
}

function iC(a, e, t, r) {
    if (t) {
        var i = a.style,
            n;
        if (i) {
            var o = t.transition,
                s = e.transition;
            if (o && !ur(o)) {
                var l = Wt(o);
                !n && (n = r.style = {});
                for (var u = 0; u < l.length; u++) {
                    var v = l[u],
                        h = i[v];
                    n[v] = h
                }
            } else if (a.getAnimationStyleProps && (ur(s) || ur(o) || ft(s, "style") >= 0)) {
                var c = a.getAnimationStyleProps(),
                    f = c ? c.style : null;
                if (f) {
                    !n && (n = r.style = {});
                    for (var p = wt(t), u = 0; u < p.length; u++) {
                        var v = p[u];
                        if (f[v]) {
                            var h = i[v];
                            n[v] = h
                        }
                    }
                }
            }
        }
    }
}

function nC(a, e) {
    return op(a) ? a !== e : a != null && isFinite(a)
}
var lg = xt(),
    oC = ["percent", "easing", "shape", "style", "extra"];

function ug(a) {
    a.stopAnimation("keyframe"), a.attr(lg(a))
}

function Ni(a, e, t) {
    if (!(!t.isAnimationEnabled() || !e)) {
        if (B(e)) {
            T(e, function (s) {
                Ni(a, s, t)
            });
            return
        }
        var r = e.keyframes,
            i = e.duration;
        if (t && i == null) {
            var n = Za("enter", t, 0);
            i = n && n.duration
        }
        if (!(!r || !i)) {
            var o = lg(a);
            T(zi, function (s) {
                if (!(s && !a[s])) {
                    var l;
                    r.sort(function (u, v) {
                        return u.percent - v.percent
                    }), T(r, function (u) {
                        var v = a.animators,
                            h = s ? u[s] : u;
                        if (h) {
                            var c = wt(h);
                            if (s || (c = Dt(c, function (d) {
                                    return ft(oC, d) < 0
                                })), !!c.length) {
                                l || (l = a.animate(s, e.loop, !0), l.scope = "keyframe");
                                for (var f = 0; f < v.length; f++) v[f] !== l && v[f].targetName === l.targetName && v[f].stopTracks(c);
                                s && (o[s] = o[s] || {});
                                var p = s ? o[s] : o;
                                T(c, function (d) {
                                    p[d] = ((s ? a[s] : a) || {})[d]
                                }), l.whenWithKeys(i * u.percent, h, c, u.easing)
                            }
                        }
                    }), l && l.delay(e.delay || 0).duration(i).start(e.easing)
                }
            })
        }
    }
}
var Te = "emphasis",
    Ee = "normal",
    El = "blur",
    kl = "select",
    Fe = [Ee, Te, El, kl],
    xo = {
        normal: ["itemStyle"],
        emphasis: [Te, "itemStyle"],
        blur: [El, "itemStyle"],
        select: [kl, "itemStyle"]
    },
    So = {
        normal: ["label"],
        emphasis: [Te, "label"],
        blur: [El, "label"],
        select: [kl, "label"]
    },
    sC = ["x", "y"],
    lC = "e\0\0",
    ae = {
        normal: {},
        emphasis: {},
        blur: {},
        select: {}
    },
    uC = {
        cartesian2d: WT,
        geo: ZT,
        single: YT,
        polar: KT,
        calendar: qT
    };

function Cs(a) {
    return a instanceof Pt
}

function Ds(a) {
    return a instanceof hr
}

function vC(a, e) {
    e.copyTransform(a), Ds(e) && Ds(a) && (e.setStyle(a.style), e.z = a.z, e.z2 = a.z2, e.zlevel = a.zlevel, e.invisible = a.invisible, e.ignore = a.ignore, Cs(e) && Cs(a) && e.setShape(a.shape))
}
var hC = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i, n) {
        this._progressiveEls = null;
        var o = this._data,
            s = t.getData(),
            l = this.group,
            u = Wh(t, s, r, i);
        o || l.removeAll(), s.diff(o).add(function (h) {
            _o(i, null, h, u(h, n), t, l, s)
        }).remove(function (h) {
            var c = o.getItemGraphicEl(h);
            c && bn(c, Ae(c).option, t)
        }).update(function (h, c) {
            var f = o.getItemGraphicEl(c);
            _o(i, f, h, u(h, n), t, l, s)
        }).execute();
        var v = t.get("clip", !0) ? cn(t.coordinateSystem, !1, t) : null;
        v ? l.setClipPath(v) : l.removeClipPath(), this._data = s
    }, e.prototype.incrementalPrepareRender = function (t, r, i) {
        this.group.removeAll(), this._data = null
    }, e.prototype.incrementalRender = function (t, r, i, n, o) {
        var s = r.getData(),
            l = Wh(r, s, i, n),
            u = this._progressiveEls = [];

        function v(f) {
            f.isGroup || (f.incremental = !0, f.ensureState("emphasis").hoverLayer = !0)
        }
        for (var h = t.start; h < t.end; h++) {
            var c = _o(null, null, h, l(h, o), r, this.group, s);
            c && (c.traverse(v), u.push(c))
        }
    }, e.prototype.eachRendered = function (t) {
        Ga(this._progressiveEls || this.group, t)
    }, e.prototype.filterForExposedEvent = function (t, r, i, n) {
        var o = r.element;
        if (o == null || i.name === o) return !0;
        for (;
            (i = i.__hostTarget || i.parent) && i !== this.group;)
            if (i.name === o) return !0;
        return !1
    }, e.type = "custom", e
}(At);
const cC = hC;

function Vl(a) {
    var e = a.type,
        t;
    if (e === "path") {
        var r = a.shape,
            i = r.width != null && r.height != null ? {
                x: r.x || 0,
                y: r.y || 0,
                width: r.width,
                height: r.height
            } : null,
            n = cg(r);
        t = Em(n, null, i, r.layout || "center"), Ae(t).customPathData = n
    } else if (e === "image") t = new ge({}), Ae(t).customImagePath = a.style.image;
    else if (e === "text") t = new ut({});
    else if (e === "group") t = new U;
    else {
        if (e === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
        var o = lp(e);
        if (!o) {
            var s = "";
            bt(s)
        }
        t = new o
    }
    return Ae(t).customGraphicType = e, t.name = a.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t
}

function Ol(a, e, t, r, i, n, o) {
    ug(e);
    var s = i && i.normal.cfg;
    s && e.setTextConfig(s), r && r.transition == null && (r.transition = sC);
    var l = r && r.style;
    if (l) {
        if (e.type === "text") {
            var u = l;
            N(u, "textFill") && (u.fill = u.textFill), N(u, "textStroke") && (u.stroke = u.textStroke)
        }
        var v = void 0,
            h = Cs(e) ? l.decal : null;
        a && h && (h.dirty = !0, v = on(h, a)), l.__decalPattern = v
    }
    if (Ds(e) && l) {
        var v = l.__decalPattern;
        v && (l.decal = v)
    }
    _i(e, r, n, {
        dataIndex: t,
        isInit: o,
        clearStyle: !0
    }), Ni(e, r.keyframeAnimation, n)
}

function vg(a, e, t, r, i) {
    var n = e.isGroup ? null : e,
        o = i && i[a].cfg;
    if (n) {
        var s = n.ensureState(a);
        if (r === !1) {
            var l = n.getState(a);
            l && (l.style = null)
        } else s.style = r || null;
        o && (s.textConfig = o), Ur(n)
    }
}

function fC(a, e, t) {
    if (!a.isGroup) {
        var r = a,
            i = t.currentZ,
            n = t.currentZLevel;
        r.z = i, r.zlevel = n;
        var o = e.z2;
        o != null && (r.z2 = o || 0);
        for (var s = 0; s < Fe.length; s++) pC(r, e, Fe[s])
    }
}

function pC(a, e, t) {
    var r = t === Ee,
        i = r ? e : Gi(e, t),
        n = i ? i.z2 : null,
        o;
    n != null && (o = r ? a : a.ensureState(t), o.z2 = n || 0)
}

function Wh(a, e, t, r) {
    var i = a.get("renderItem"),
        n = a.coordinateSystem,
        o = {};
    n && (o = n.prepareCustoms ? n.prepareCustoms(n) : uC[n.type](n));
    for (var s = at({
            getWidth: r.getWidth,
            getHeight: r.getHeight,
            getZr: r.getZr,
            getDevicePixelRatio: r.getDevicePixelRatio,
            value: S,
            style: b,
            ordinalRawValue: _,
            styleEmphasis: w,
            visual: D,
            barLayout: I,
            currentSeriesIndices: L,
            font: M
        }, o.api || {}), l = {
            context: {},
            seriesId: a.id,
            seriesName: a.name,
            seriesIndex: a.seriesIndex,
            coordSys: o.coordSys,
            dataInsideLength: e.count(),
            encode: dC(a.getData())
        }, u, v, h = {}, c = {}, f = {}, p = {}, d = 0; d < Fe.length; d++) {
        var g = Fe[d];
        f[g] = a.getModel(xo[g]), p[g] = a.getModel(So[g])
    }

    function y(P) {
        return P === u ? v || (v = e.getItemModel(P)) : e.getItemModel(P)
    }

    function x(P, R) {
        return e.hasItemOption ? P === u ? h[R] || (h[R] = y(P).getModel(xo[R])) : y(P).getModel(xo[R]) : f[R]
    }

    function m(P, R) {
        return e.hasItemOption ? P === u ? c[R] || (c[R] = y(P).getModel(So[R])) : y(P).getModel(So[R]) : p[R]
    }
    return function (P, R) {
        return u = P, v = null, h = {}, c = {}, i && i(at({
            dataIndexInside: P,
            dataIndex: e.getRawIndex(P),
            actionType: R ? R.type : null
        }, l), s)
    };

    function S(P, R) {
        return R == null && (R = u), e.getStore().get(e.getDimensionIndex(P || 0), R)
    }

    function _(P, R) {
        R == null && (R = u), P = P || 0;
        var k = e.getDimensionInfo(P);
        if (!k) {
            var V = e.getDimensionIndex(P);
            return V >= 0 ? e.getStore().get(V, R) : void 0
        }
        var O = e.get(k.name, R),
            z = k && k.ordinalMeta;
        return z ? z.categories[O] : O
    }

    function b(P, R) {
        R == null && (R = u);
        var k = e.getItemVisual(R, "style"),
            V = k && k.fill,
            O = k && k.opacity,
            z = x(R, Ee).getItemStyle();
        V != null && (z.fill = V), O != null && (z.opacity = O);
        var $ = {
                inheritColor: q(V) ? V : "#000"
            },
            Z = m(R, Ee),
            et = mt(Z, null, $, !1, !0);
        et.text = Z.getShallow("show") ? Lt(a.getFormattedLabel(R, Ee), wa(e, R)) : null;
        var J = _u(Z, $, !1);
        return C(P, z), z = Nh(z, et, J), P && A(z, P), z.legacy = !0, z
    }

    function w(P, R) {
        R == null && (R = u);
        var k = x(R, Te).getItemStyle(),
            V = m(R, Te),
            O = mt(V, null, null, !0, !0);
        O.text = V.getShallow("show") ? Wa(a.getFormattedLabel(R, Te), a.getFormattedLabel(R, Ee), wa(e, R)) : null;
        var z = _u(V, null, !0);
        return C(P, k), k = Nh(k, O, z), P && A(k, P), k.legacy = !0, k
    }

    function A(P, R) {
        for (var k in R) N(R, k) && (P[k] = R[k])
    }

    function C(P, R) {
        P && (P.textFill && (R.textFill = P.textFill), P.textPosition && (R.textPosition = P.textPosition))
    }

    function D(P, R) {
        if (R == null && (R = u), N(Oh, P)) {
            var k = e.getItemVisual(R, "style");
            return k ? k[Oh[P]] : null
        }
        if (N(GT, P)) return e.getItemVisual(R, P)
    }

    function I(P) {
        if (n.type === "cartesian2d") {
            var R = n.getBaseAxis();
            return Rm(at({
                axis: R
            }, P))
        }
    }

    function L() {
        return t.getCurrentSeriesIndices()
    }

    function M(P) {
        return sp(P, t)
    }
}

function dC(a) {
    var e = {};
    return T(a.dimensions, function (t) {
        var r = a.getDimensionInfo(t);
        if (!r.isExtraCoord) {
            var i = r.coordDim,
                n = e[i] = e[i] || [];
            n[r.coordDimIndex] = a.getDimensionIndex(t)
        }
    }), e
}

function _o(a, e, t, r, i, n, o) {
    if (!r) {
        n.remove(e);
        return
    }
    var s = zl(a, e, t, r, i, n);
    return s && o.setItemGraphicEl(t, s), s && Tt(s, r.focus, r.blurScope, r.emphasisDisabled), s
}

function zl(a, e, t, r, i, n) {
    var o = -1,
        s = e;
    e && hg(e, r, i) && (o = ft(n.childrenRef(), e), e = null);
    var l = !e,
        u = e;
    u ? u.clearStates() : (u = Vl(r), s && vC(s, u)), r.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), ae.normal.cfg = ae.normal.conOpt = ae.emphasis.cfg = ae.emphasis.conOpt = ae.blur.cfg = ae.blur.conOpt = ae.select.cfg = ae.select.conOpt = null, ae.isLegacy = !1, yC(u, t, r, i, l, ae), gC(u, t, r, i, l), Ol(a, u, t, r, ae, i, l), N(r, "info") && (Ae(u).info = r.info);
    for (var v = 0; v < Fe.length; v++) {
        var h = Fe[v];
        if (h !== Ee) {
            var c = Gi(r, h),
                f = Nl(r, c, h);
            vg(h, u, c, f, ae)
        }
    }
    return fC(u, r, i), r.type === "group" && mC(a, u, t, r, i), o >= 0 ? n.replaceAt(u, o) : n.add(u), u
}

function hg(a, e, t) {
    var r = Ae(a),
        i = e.type,
        n = e.shape,
        o = e.style;
    return t.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && bC(n) && cg(n) !== r.customPathData || i === "image" && N(o, "image") && o.image !== r.customImagePath
}

function gC(a, e, t, r, i) {
    var n = t.clipPath;
    if (n === !1) a && a.getClipPath() && a.removeClipPath();
    else if (n) {
        var o = a.getClipPath();
        o && hg(o, n, r) && (o = null), o || (o = Vl(n), a.setClipPath(o)), Ol(null, o, e, n, null, r, i)
    }
}

function yC(a, e, t, r, i, n) {
    if (!a.isGroup) {
        $h(t, null, n), $h(t, Te, n);
        var o = n.normal.conOpt,
            s = n.emphasis.conOpt,
            l = n.blur.conOpt,
            u = n.select.conOpt;
        if (o != null || s != null || u != null || l != null) {
            var v = a.getTextContent();
            if (o === !1) v && a.removeTextContent();
            else {
                o = n.normal.conOpt = o || {
                    type: "text"
                }, v ? v.clearStates() : (v = Vl(o), a.setTextContent(v)), Ol(null, v, e, o, null, r, i);
                for (var h = o && o.style, c = 0; c < Fe.length; c++) {
                    var f = Fe[c];
                    if (f !== Ee) {
                        var p = n[f].conOpt;
                        vg(f, v, p, Nl(o, p, f), null)
                    }
                }
                h ? v.dirty() : v.markRedraw()
            }
        }
    }
}

function $h(a, e, t) {
    var r = e ? Gi(a, e) : a,
        i = e ? Nl(a, r, Te) : a.style,
        n = a.type,
        o = r ? r.textConfig : null,
        s = a.textContent,
        l = s ? e ? Gi(s, e) : s : null;
    if (i && (t.isLegacy || ig(i, n, !!o, !!l))) {
        t.isLegacy = !0;
        var u = ng(i, n, !e);
        !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent)
    }
    if (!e && l) {
        var v = l;
        !v.type && (v.type = "text")
    }
    var h = e ? t[e] : t.normal;
    h.cfg = o, h.conOpt = l
}

function Gi(a, e) {
    return e ? a ? a[e] : null : a
}

function Nl(a, e, t) {
    var r = e && e.style;
    return r == null && t === Te && a && (r = a.styleEmphasis), r
}

function mC(a, e, t, r, i) {
    var n = r.children,
        o = n ? n.length : 0,
        s = r.$mergeChildren,
        l = s === "byName" || r.diffChildrenByName,
        u = s === !1;
    if (!(!o && !l && !u)) {
        if (l) {
            SC({
                api: a,
                oldChildren: e.children() || [],
                newChildren: n || [],
                dataIndex: t,
                seriesModel: i,
                group: e
            });
            return
        }
        u && e.removeAll();
        for (var v = 0; v < o; v++) {
            var h = n[v],
                c = e.childAt(v);
            h ? (h.ignore == null && (h.ignore = !1), zl(a, c, t, h, i, e)) : c.ignore = !0
        }
        for (var f = e.childCount() - 1; f >= v; f--) {
            var p = e.childAt(f);
            xC(e, p, i)
        }
    }
}

function xC(a, e, t) {
    e && bn(e, Ae(a).option, t)
}

function SC(a) {
    new Be(a.oldChildren, a.newChildren, Zh, Zh, a).add(Uh).update(Uh).remove(_C).execute()
}

function Zh(a, e) {
    var t = a && a.name;
    return t ? ? lC + e
}

function Uh(a, e) {
    var t = this.context,
        r = a != null ? t.newChildren[a] : null,
        i = e != null ? t.oldChildren[e] : null;
    zl(t.api, i, t.dataIndex, r, t.seriesModel, t.group)
}

function _C(a) {
    var e = this.context,
        t = e.oldChildren[a];
    t && bn(t, Ae(t).option, e.seriesModel)
}

function cg(a) {
    return a && (a.pathData || a.d)
}

function bC(a) {
    return a && (N(a, "pathData") || N(a, "d"))
}

function wC(a) {
    a.registerChartView(cC), a.registerSeriesModel(HT)
}
var ir = xt(),
    Yh = ot,
    bo = F,
    AC = function () {
        function a() {
            this._dragging = !1, this.animationThreshold = 15
        }
        return a.prototype.render = function (e, t, r, i) {
            var n = t.get("value"),
                o = t.get("status");
            if (this._axisModel = e, this._axisPointerModel = t, this._api = r, !(!i && this._lastValue === n && this._lastStatus === o)) {
                this._lastValue = n, this._lastStatus = o;
                var s = this._group,
                    l = this._handle;
                if (!o || o === "hide") {
                    s && s.hide(), l && l.hide();
                    return
                }
                s && s.show(), l && l.show();
                var u = {};
                this.makeElOption(u, n, e, t, r);
                var v = u.graphicKey;
                v !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = v;
                var h = this._moveAnimation = this.determineAnimation(e, t);
                if (!s) s = this._group = new U, this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), r.getZr().add(s);
                else {
                    var c = K(Xh, t, h);
                    this.updatePointerEl(s, u, c), this.updateLabelEl(s, u, c, t)
                }
                qh(s, t, !0), this._renderHandle(n)
            }
        }, a.prototype.remove = function (e) {
            this.clear(e)
        }, a.prototype.dispose = function (e) {
            this.clear(e)
        }, a.prototype.determineAnimation = function (e, t) {
            var r = t.get("animation"),
                i = e.axis,
                n = i.type === "category",
                o = t.get("snap");
            if (!o && !n) return !1;
            if (r === "auto" || r == null) {
                var s = this.animationThreshold;
                if (n && i.getBandWidth() > s) return !0;
                if (o) {
                    var l = ll(e).seriesDataCount,
                        u = i.getExtent();
                    return Math.abs(u[0] - u[1]) / l > s
                }
                return !1
            }
            return r === !0
        }, a.prototype.makeElOption = function (e, t, r, i, n) {}, a.prototype.createPointerEl = function (e, t, r, i) {
            var n = t.pointer;
            if (n) {
                var o = ir(e).pointerEl = new Qr[n.type](Yh(t.pointer));
                e.add(o)
            }
        }, a.prototype.createLabelEl = function (e, t, r, i) {
            if (t.label) {
                var n = ir(e).labelEl = new ut(Yh(t.label));
                e.add(n), Kh(n, i)
            }
        }, a.prototype.updatePointerEl = function (e, t, r) {
            var i = ir(e).pointerEl;
            i && t.pointer && (i.setStyle(t.pointer.style), r(i, {
                shape: t.pointer.shape
            }))
        }, a.prototype.updateLabelEl = function (e, t, r, i) {
            var n = ir(e).labelEl;
            n && (n.setStyle(t.label.style), r(n, {
                x: t.label.x,
                y: t.label.y
            }), Kh(n, i))
        }, a.prototype._renderHandle = function (e) {
            if (!(this._dragging || !this.updateHandleTransform)) {
                var t = this._axisPointerModel,
                    r = this._api.getZr(),
                    i = this._handle,
                    n = t.getModel("handle"),
                    o = t.get("status");
                if (!n.get("show") || !o || o === "hide") {
                    i && r.remove(i), this._handle = null;
                    return
                }
                var s;
                this._handle || (s = !0, i = this._handle = fn(n.get("icon"), {
                    cursor: "move",
                    draggable: !0,
                    onmousemove: function (u) {
                        Ne(u.event)
                    },
                    onmousedown: bo(this._onHandleDragMove, this, 0, 0),
                    drift: bo(this._onHandleDragMove, this),
                    ondragend: bo(this._onHandleDragEnd, this)
                }), r.add(i)), qh(i, t, !1), i.setStyle(n.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
                var l = n.get("size");
                B(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Jr(this, "_doDispatchAxisPointer", n.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s)
            }
        }, a.prototype._moveHandleToValue = function (e, t) {
            Xh(this._axisPointerModel, !t && this._moveAnimation, this._handle, wo(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)))
        }, a.prototype._onHandleDragMove = function (e, t) {
            var r = this._handle;
            if (r) {
                this._dragging = !0;
                var i = this.updateHandleTransform(wo(r), [e, t], this._axisModel, this._axisPointerModel);
                this._payloadInfo = i, r.stopAnimation(), r.attr(wo(i)), ir(r).lastProp = null, this._doDispatchAxisPointer()
            }
        }, a.prototype._doDispatchAxisPointer = function () {
            var e = this._handle;
            if (e) {
                var t = this._payloadInfo,
                    r = this._axisModel;
                this._api.dispatchAction({
                    type: "updateAxisPointer",
                    x: t.cursorPoint[0],
                    y: t.cursorPoint[1],
                    tooltipOption: t.tooltipOption,
                    axesInfo: [{
                        axisDim: r.axis.dim,
                        axisIndex: r.componentIndex
                    }]
                })
            }
        }, a.prototype._onHandleDragEnd = function () {
            this._dragging = !1;
            var e = this._handle;
            if (e) {
                var t = this._axisPointerModel.get("value");
                this._moveHandleToValue(t), this._api.dispatchAction({
                    type: "hideTip"
                })
            }
        }, a.prototype.clear = function (e) {
            this._lastValue = null, this._lastStatus = null;
            var t = e.getZr(),
                r = this._group,
                i = this._handle;
            t && r && (this._lastGraphicKey = null, r && t.remove(r), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Ta(this, "_doDispatchAxisPointer")
        }, a.prototype.doClear = function () {}, a.prototype.buildLabel = function (e, t, r) {
            return r = r || 0, {
                x: e[r],
                y: e[1 - r],
                width: t[r],
                height: t[1 - r]
            }
        }, a
    }();

function Xh(a, e, t, r) {
    fg(ir(t).lastProp, r) || (ir(t).lastProp = r, e ? yt(t, r, a) : (t.stopAnimation(), t.attr(r)))
}

function fg(a, e) {
    if (St(a) && St(e)) {
        var t = !0;
        return T(e, function (r, i) {
            t = t && fg(a[i], r)
        }), !!t
    } else return a === e
}

function Kh(a, e) {
    a[e.get(["label", "show"]) ? "show" : "hide"]()
}

function wo(a) {
    return {
        x: a.x || 0,
        y: a.y || 0,
        rotation: a.rotation || 0
    }
}

function qh(a, e, t) {
    var r = e.get("z"),
        i = e.get("zlevel");
    a && a.traverse(function (n) {
        n.type !== "group" && (r != null && (n.z = r), i != null && (n.zlevel = i), n.silent = t)
    })
}
const Gl = AC;

function Bl(a) {
    var e = a.get("type"),
        t = a.getModel(e + "Style"),
        r;
    return e === "line" ? (r = t.getLineStyle(), r.fill = null) : e === "shadow" && (r = t.getAreaStyle(), r.stroke = null), r
}

function pg(a, e, t, r, i) {
    var n = t.get("value"),
        o = dg(n, e.axis, e.ecModel, t.get("seriesDataIndices"), {
            precision: t.get(["label", "precision"]),
            formatter: t.get(["label", "formatter"])
        }),
        s = t.getModel("label"),
        l = pn(s.get("padding") || 0),
        u = s.getFont(),
        v = el(o, u),
        h = i.position,
        c = v.width + l[1] + l[3],
        f = v.height + l[0] + l[2],
        p = i.align;
    p === "right" && (h[0] -= c), p === "center" && (h[0] -= c / 2);
    var d = i.verticalAlign;
    d === "bottom" && (h[1] -= f), d === "middle" && (h[1] -= f / 2), TC(h, c, f, r);
    var g = s.get("backgroundColor");
    (!g || g === "auto") && (g = e.get(["axisLine", "lineStyle", "color"])), a.label = {
        x: h[0],
        y: h[1],
        style: mt(s, {
            text: o,
            font: u,
            fill: s.getTextColor(),
            padding: l,
            backgroundColor: g
        }),
        z2: 10
    }
}

function TC(a, e, t, r) {
    var i = r.getWidth(),
        n = r.getHeight();
    a[0] = Math.min(a[0] + e, i) - e, a[1] = Math.min(a[1] + t, n) - t, a[0] = Math.max(a[0], 0), a[1] = Math.max(a[1], 0)
}

function dg(a, e, t, r, i) {
    a = e.scale.parse(a);
    var n = e.scale.getLabel({
            value: a
        }, {
            precision: i.precision
        }),
        o = i.formatter;
    if (o) {
        var s = {
            value: up(e, {
                value: a
            }),
            axisDimension: e.dim,
            axisIndex: e.index,
            seriesData: []
        };
        T(r, function (l) {
            var u = t.getSeriesByIndex(l.seriesIndex),
                v = l.dataIndexInside,
                h = u && u.getDataParams(v);
            h && s.seriesData.push(h)
        }), q(o) ? n = o.replace("{value}", n) : rt(o) && (n = o(s))
    }
    return n
}

function Hl(a, e, t) {
    var r = yr();
    return Ha(r, r, t.rotation), Ge(r, r, t.position), we([a.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], r)
}

function gg(a, e, t, r, i, n) {
    var o = ze.innerTextLayout(t.rotation, 0, t.labelDirection);
    t.labelMargin = i.get(["label", "margin"]), pg(e, r, i, n, {
        position: Hl(r.axis, a, t),
        align: o.textAlign,
        verticalAlign: o.textVerticalAlign
    })
}

function Fl(a, e, t) {
    return t = t || 0, {
        x1: a[t],
        y1: a[1 - t],
        x2: e[t],
        y2: e[1 - t]
    }
}

function yg(a, e, t) {
    return t = t || 0, {
        x: a[t],
        y: a[1 - t],
        width: e[t],
        height: e[1 - t]
    }
}

function jh(a, e, t, r, i, n) {
    return {
        cx: a,
        cy: e,
        r0: t,
        r,
        startAngle: i,
        endAngle: n,
        clockwise: !0
    }
}
var CC = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.makeElOption = function (t, r, i, n, o) {
        var s = i.axis,
            l = s.grid,
            u = n.get("type"),
            v = Jh(l, s).getOtherAxis(s).getGlobalExtent(),
            h = s.toGlobalCoord(s.dataToCoord(r, !0));
        if (u && u !== "none") {
            var c = Bl(n),
                f = DC[u](s, h, v);
            f.style = c, t.graphicKey = f.type, t.pointer = f
        }
        var p = us(l.model, i);
        gg(r, t, p, i, n, o)
    }, e.prototype.getHandleTransform = function (t, r, i) {
        var n = us(r.axis.grid.model, r, {
            labelInside: !1
        });
        n.labelMargin = i.get(["handle", "margin"]);
        var o = Hl(r.axis, t, n);
        return {
            x: o[0],
            y: o[1],
            rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
        }
    }, e.prototype.updateHandleTransform = function (t, r, i, n) {
        var o = i.axis,
            s = o.grid,
            l = o.getGlobalExtent(!0),
            u = Jh(s, o).getOtherAxis(o).getGlobalExtent(),
            v = o.dim === "x" ? 0 : 1,
            h = [t.x, t.y];
        h[v] += r[v], h[v] = Math.min(l[1], h[v]), h[v] = Math.max(l[0], h[v]);
        var c = (u[1] + u[0]) / 2,
            f = [c, c];
        f[v] = h[v];
        var p = [{
            verticalAlign: "middle"
        }, {
            align: "center"
        }];
        return {
            x: h[0],
            y: h[1],
            rotation: t.rotation,
            cursorPoint: f,
            tooltipOption: p[v]
        }
    }, e
}(Gl);

function Jh(a, e) {
    var t = {};
    return t[e.dim + "AxisIndex"] = e.index, a.getCartesian(t)
}
var DC = {
    line: function (a, e, t) {
        var r = Fl([e, t[0]], [e, t[1]], Qh(a));
        return {
            type: "Line",
            subPixelOptimize: !0,
            shape: r
        }
    },
    shadow: function (a, e, t) {
        var r = Math.max(1, a.getBandWidth()),
            i = t[1] - t[0];
        return {
            type: "Rect",
            shape: yg([e - r / 2, t[0]], [r, i], Qh(a))
        }
    }
};

function Qh(a) {
    return a.dim === "x" ? 0 : 1
}
const IC = CC;
var LC = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "axisPointer", e.defaultOption = {
        show: "auto",
        z: 50,
        type: "line",
        snap: !1,
        triggerTooltip: !0,
        triggerEmphasis: !0,
        value: null,
        status: null,
        link: [],
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
            color: "#B9BEC9",
            width: 1,
            type: "dashed"
        },
        shadowStyle: {
            color: "rgba(210,219,238,0.2)"
        },
        label: {
            show: !0,
            formatter: null,
            precision: "auto",
            margin: 3,
            color: "#fff",
            padding: [5, 7, 5, 7],
            backgroundColor: "auto",
            borderColor: null,
            borderWidth: 0,
            borderRadius: 3
        },
        handle: {
            show: !1,
            icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
            size: 45,
            margin: 50,
            color: "#333",
            shadowBlur: 3,
            shadowColor: "#aaa",
            shadowOffsetX: 0,
            shadowOffsetY: 2,
            throttle: 40
        }
    }, e
}(Ct);
const MC = LC;
var be = xt(),
    PC = T;

function mg(a, e, t) {
    if (!Nt.node) {
        var r = e.getZr();
        be(r).records || (be(r).records = {}), RC(r, e);
        var i = be(r).records[a] || (be(r).records[a] = {});
        i.handler = t
    }
}

function RC(a, e) {
    if (be(a).initialized) return;
    be(a).initialized = !0, t("click", K(tc, "click")), t("mousemove", K(tc, "mousemove")), t("globalout", kC);

    function t(r, i) {
        a.on(r, function (n) {
            var o = VC(e);
            PC(be(a).records, function (s) {
                s && i(s, n, o.dispatchAction)
            }), EC(o.pendings, e)
        })
    }
}

function EC(a, e) {
    var t = a.showTip.length,
        r = a.hideTip.length,
        i;
    t ? i = a.showTip[t - 1] : r && (i = a.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i))
}

function kC(a, e, t) {
    a.handler("leave", null, t)
}

function tc(a, e, t, r) {
    e.handler(a, t, r)
}

function VC(a) {
    var e = {
            showTip: [],
            hideTip: []
        },
        t = function (r) {
            var i = e[r.type];
            i ? i.push(r) : (r.dispatchAction = t, a.dispatchAction(r))
        };
    return {
        dispatchAction: t,
        pendings: e
    }
}

function Is(a, e) {
    if (!Nt.node) {
        var t = e.getZr(),
            r = (be(t).records || {})[a];
        r && (be(t).records[a] = null)
    }
}
var OC = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i) {
        var n = r.getComponent("tooltip"),
            o = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click";
        mg("axisPointer", i, function (s, l, u) {
            o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
                type: "updateAxisPointer",
                currTrigger: s,
                x: l && l.offsetX,
                y: l && l.offsetY
            })
        })
    }, e.prototype.remove = function (t, r) {
        Is("axisPointer", r)
    }, e.prototype.dispose = function (t, r) {
        Is("axisPointer", r)
    }, e.type = "axisPointer", e
}(It);
const zC = OC;

function xg(a, e) {
    var t = [],
        r = a.seriesIndex,
        i;
    if (r == null || !(i = e.getSeriesByIndex(r))) return {
        point: []
    };
    var n = i.getData(),
        o = Uo(n, a);
    if (o == null || o < 0 || B(o)) return {
        point: []
    };
    var s = n.getItemGraphicEl(o),
        l = i.coordinateSystem;
    if (i.getTooltipPosition) t = i.getTooltipPosition(o) || [];
    else if (l && l.dataToPoint)
        if (a.isStacked) {
            var u = l.getBaseAxis(),
                v = l.getOtherAxis(u),
                h = v.dim,
                c = u.dim,
                f = h === "x" || h === "radius" ? 1 : 0,
                p = n.mapDimension(c),
                d = [];
            d[f] = n.get(p, o), d[1 - f] = n.get(n.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(d) || []
        } else t = l.dataToPoint(n.getValues(G(l.dimensions, function (y) {
            return n.mapDimension(y)
        }), o)) || [];
    else if (s) {
        var g = s.getBoundingRect().clone();
        g.applyTransform(s.transform), t = [g.x + g.width / 2, g.y + g.height / 2]
    }
    return {
        point: t,
        el: s
    }
}
var ec = xt();

function NC(a, e, t) {
    var r = a.currTrigger,
        i = [a.x, a.y],
        n = a,
        o = a.dispatchAction || F(t.dispatchAction, t),
        s = e.getComponent("axisPointer").coordSysAxesInfo;
    if (s) {
        bi(i) && (i = xg({
            seriesIndex: n.seriesIndex,
            dataIndex: n.dataIndex
        }, e).point);
        var l = bi(i),
            u = n.axesInfo,
            v = s.axesInfo,
            h = r === "leave" || bi(i),
            c = {},
            f = {},
            p = {
                list: [],
                map: {}
            },
            d = {
                showPointer: K(BC, f),
                showTooltip: K(HC, p)
            };
        T(s.coordSysMap, function (y, x) {
            var m = l || y.containPoint(i);
            T(s.coordSysAxesInfo[x], function (S, _) {
                var b = S.axis,
                    w = ZC(u, S);
                if (!h && m && (!u || w)) {
                    var A = w && w.value;
                    A == null && !l && (A = b.pointToData(i)), A != null && rc(S, A, d, !1, c)
                }
            })
        });
        var g = {};
        return T(v, function (y, x) {
            var m = y.linkGroup;
            m && !f[x] && T(m.axesInfo, function (S, _) {
                var b = f[_];
                if (S !== y && b) {
                    var w = b.value;
                    m.mapper && (w = y.axis.scale.parse(m.mapper(w, ac(S), ac(y)))), g[y.key] = w
                }
            })
        }), T(g, function (y, x) {
            rc(v[x], y, d, !0, c)
        }), FC(f, v, c), WC(p, i, a, o), $C(v, o, t), c
    }
}

function rc(a, e, t, r, i) {
    var n = a.axis;
    if (!(n.scale.isBlank() || !n.containData(e))) {
        if (!a.involveSeries) {
            t.showPointer(a, e);
            return
        }
        var o = GC(e, a),
            s = o.payloadBatch,
            l = o.snapToValue;
        s[0] && i.seriesIndex == null && W(i, s[0]), !r && a.snap && n.containData(l) && l != null && (e = l), t.showPointer(a, e, s), t.showTooltip(a, o, l)
    }
}

function GC(a, e) {
    var t = e.axis,
        r = t.dim,
        i = a,
        n = [],
        o = Number.MAX_VALUE,
        s = -1;
    return T(e.seriesModels, function (l, u) {
        var v = l.getData().mapDimensionsAll(r),
            h, c;
        if (l.getAxisTooltipData) {
            var f = l.getAxisTooltipData(v, a, t);
            c = f.dataIndices, h = f.nestestValue
        } else {
            if (c = l.getData().indicesOfNearest(v[0], a, t.type === "category" ? .5 : null), !c.length) return;
            h = l.getData().get(v[0], c[0])
        }
        if (!(h == null || !isFinite(h))) {
            var p = a - h,
                d = Math.abs(p);
            d <= o && ((d < o || p >= 0 && s < 0) && (o = d, s = p, i = h, n.length = 0), T(c, function (g) {
                n.push({
                    seriesIndex: l.seriesIndex,
                    dataIndexInside: g,
                    dataIndex: l.getData().getRawIndex(g)
                })
            }))
        }
    }), {
        payloadBatch: n,
        snapToValue: i
    }
}

function BC(a, e, t, r) {
    a[e.key] = {
        value: t,
        payloadBatch: r
    }
}

function HC(a, e, t, r) {
    var i = t.payloadBatch,
        n = e.axis,
        o = n.model,
        s = e.axisPointerModel;
    if (!(!e.triggerTooltip || !i.length)) {
        var l = e.coordSys.model,
            u = La(l),
            v = a.map[u];
        v || (v = a.map[u] = {
            coordSysId: l.id,
            coordSysIndex: l.componentIndex,
            coordSysType: l.type,
            coordSysMainType: l.mainType,
            dataByAxis: []
        }, a.list.push(v)), v.dataByAxis.push({
            axisDim: n.dim,
            axisIndex: o.componentIndex,
            axisType: o.type,
            axisId: o.id,
            value: r,
            valueLabelOpt: {
                precision: s.get(["label", "precision"]),
                formatter: s.get(["label", "formatter"])
            },
            seriesDataIndices: i.slice()
        })
    }
}

function FC(a, e, t) {
    var r = t.axesInfo = [];
    T(e, function (i, n) {
        var o = i.axisPointerModel.option,
            s = a[n];
        s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && r.push({
            axisDim: i.axis.dim,
            axisIndex: i.axis.model.componentIndex,
            value: o.value
        })
    })
}

function WC(a, e, t, r) {
    if (bi(e) || !a.list.length) {
        r({
            type: "hideTip"
        });
        return
    }
    var i = ((a.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    r({
        type: "showTip",
        escapeConnect: !0,
        x: e[0],
        y: e[1],
        tooltipOption: t.tooltipOption,
        position: t.position,
        dataIndexInside: i.dataIndexInside,
        dataIndex: i.dataIndex,
        seriesIndex: i.seriesIndex,
        dataByCoordSys: a.list
    })
}

function $C(a, e, t) {
    var r = t.getZr(),
        i = "axisPointerLastHighlights",
        n = ec(r)[i] || {},
        o = ec(r)[i] = {};
    T(a, function (u, v) {
        var h = u.axisPointerModel.option;
        h.status === "show" && u.triggerEmphasis && T(h.seriesDataIndices, function (c) {
            var f = c.seriesIndex + " | " + c.dataIndex;
            o[f] = c
        })
    });
    var s = [],
        l = [];
    T(n, function (u, v) {
        !o[v] && l.push(u)
    }), T(o, function (u, v) {
        !n[v] && s.push(u)
    }), l.length && t.dispatchAction({
        type: "downplay",
        escapeConnect: !0,
        notBlur: !0,
        batch: l
    }), s.length && t.dispatchAction({
        type: "highlight",
        escapeConnect: !0,
        notBlur: !0,
        batch: s
    })
}

function ZC(a, e) {
    for (var t = 0; t < (a || []).length; t++) {
        var r = a[t];
        if (e.axis.dim === r.axisDim && e.axis.model.componentIndex === r.axisIndex) return r
    }
}

function ac(a) {
    var e = a.axis.model,
        t = {},
        r = t.axisDim = a.axis.dim;
    return t.axisIndex = t[r + "AxisIndex"] = e.componentIndex, t.axisName = t[r + "AxisName"] = e.name, t.axisId = t[r + "AxisId"] = e.id, t
}

function bi(a) {
    return !a || a[0] == null || isNaN(a[0]) || a[1] == null || isNaN(a[1])
}

function ja(a) {
    xr.registerAxisPointerClass("CartesianAxisPointer", IC), a.registerComponentModel(MC), a.registerComponentView(zC), a.registerPreprocessor(function (e) {
        if (e) {
            (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
            var t = e.axisPointer.link;
            t && !B(t) && (e.axisPointer.link = [t])
        }
    }), a.registerProcessor(a.PRIORITY.PROCESSOR.STATISTIC, function (e, t) {
        e.getComponent("axisPointer").coordSysAxesInfo = nS(e, t)
    }), a.registerAction({
        type: "updateAxisPointer",
        event: "updateAxisPointer",
        update: ":updateAxisPointer"
    }, NC)
}

function UC(a) {
    j(Zp), j(ja)
}
var YC = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.makeElOption = function (t, r, i, n, o) {
        var s = i.axis;
        s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
        var l = s.polar,
            u = l.getOtherAxis(s),
            v = u.getExtent(),
            h = s.dataToCoord(r),
            c = n.get("type");
        if (c && c !== "none") {
            var f = Bl(n),
                p = KC[c](s, l, h, v);
            p.style = f, t.graphicKey = p.type, t.pointer = p
        }
        var d = n.get(["label", "margin"]),
            g = XC(r, i, n, l, d);
        pg(t, i, n, o, g)
    }, e
}(Gl);

function XC(a, e, t, r, i) {
    var n = e.axis,
        o = n.dataToCoord(a),
        s = r.getAngleAxis().getExtent()[0];
    s = s / 180 * Math.PI;
    var l = r.getRadiusAxis().getExtent(),
        u, v, h;
    if (n.dim === "radius") {
        var c = yr();
        Ha(c, c, s), Ge(c, c, [r.cx, r.cy]), u = we([o, -i], c);
        var f = e.getModel("axisLabel").get("rotate") || 0,
            p = ze.innerTextLayout(s, f * Math.PI / 180, -1);
        v = p.textAlign, h = p.textVerticalAlign
    } else {
        var d = l[1];
        u = r.coordToPoint([d + i, o]);
        var g = r.cx,
            y = r.cy;
        v = Math.abs(u[0] - g) / d < .3 ? "center" : u[0] > g ? "left" : "right", h = Math.abs(u[1] - y) / d < .3 ? "middle" : u[1] > y ? "top" : "bottom"
    }
    return {
        position: u,
        align: v,
        verticalAlign: h
    }
}
var KC = {
    line: function (a, e, t, r) {
        return a.dim === "angle" ? {
            type: "Line",
            shape: Fl(e.coordToPoint([r[0], t]), e.coordToPoint([r[1], t]))
        } : {
            type: "Circle",
            shape: {
                cx: e.cx,
                cy: e.cy,
                r: t
            }
        }
    },
    shadow: function (a, e, t, r) {
        var i = Math.max(1, a.getBandWidth()),
            n = Math.PI / 180;
        return a.dim === "angle" ? {
            type: "Sector",
            shape: jh(e.cx, e.cy, r[0], r[1], (-t - i / 2) * n, (-t + i / 2) * n)
        } : {
            type: "Sector",
            shape: jh(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2)
        }
    }
};
const qC = YC;
var jC = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.findAxisModel = function (t) {
        var r, i = this.ecModel;
        return i.eachComponent(t, function (n) {
            n.getCoordSysModel() === this && (r = n)
        }, this), r
    }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = {
        z: 0,
        center: ["50%", "50%"],
        radius: "80%"
    }, e
}(Ct);
const JC = jC;
var Wl = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.getCoordSysModel = function () {
        return this.getReferringComponents("polar", Kt).models[0]
    }, e.type = "polarAxis", e
}(Ct);
le(Wl, Ji);
var QC = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.type = "angleAxis", e
    }(Wl),
    tD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.type = "radiusAxis", e
    }(Wl),
    $l = function (a) {
        E(e, a);

        function e(t, r) {
            return a.call(this, "radius", t, r) || this
        }
        return e.prototype.pointToData = function (t, r) {
            return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1]
        }, e
    }(ye);
$l.prototype.dataToRadius = ye.prototype.dataToCoord;
$l.prototype.radiusToData = ye.prototype.coordToData;
var eD = xt(),
    Zl = function (a) {
        E(e, a);

        function e(t, r) {
            return a.call(this, "angle", t, r || [0, 360]) || this
        }
        return e.prototype.pointToData = function (t, r) {
            return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1]
        }, e.prototype.calculateCategoryInterval = function () {
            var t = this,
                r = t.getLabelModel(),
                i = t.scale,
                n = i.getExtent(),
                o = i.count();
            if (n[1] - n[0] < 1) return 0;
            var s = n[0],
                l = t.dataToCoord(s + 1) - t.dataToCoord(s),
                u = Math.abs(l),
                v = el(s == null ? "" : s + "", r.getFont(), "center", "top"),
                h = Math.max(v.height, 7),
                c = h / u;
            isNaN(c) && (c = 1 / 0);
            var f = Math.max(0, Math.floor(c)),
                p = eD(t.model),
                d = p.lastAutoInterval,
                g = p.lastTickCount;
            return d != null && g != null && Math.abs(d - f) <= 1 && Math.abs(g - o) <= 1 && d > f ? f = d : (p.lastTickCount = o, p.lastAutoInterval = f), f
        }, e
    }(ye);
Zl.prototype.dataToAngle = ye.prototype.dataToCoord;
Zl.prototype.angleToData = ye.prototype.coordToData;
var Sg = ["radius", "angle"],
    rD = function () {
        function a(e) {
            this.dimensions = Sg, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new $l, this._angleAxis = new Zl, this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this
        }
        return a.prototype.containPoint = function (e) {
            var t = this.pointToCoord(e);
            return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1])
        }, a.prototype.containData = function (e) {
            return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1])
        }, a.prototype.getAxis = function (e) {
            var t = "_" + e + "Axis";
            return this[t]
        }, a.prototype.getAxes = function () {
            return [this._radiusAxis, this._angleAxis]
        }, a.prototype.getAxesByScale = function (e) {
            var t = [],
                r = this._angleAxis,
                i = this._radiusAxis;
            return r.scale.type === e && t.push(r), i.scale.type === e && t.push(i), t
        }, a.prototype.getAngleAxis = function () {
            return this._angleAxis
        }, a.prototype.getRadiusAxis = function () {
            return this._radiusAxis
        }, a.prototype.getOtherAxis = function (e) {
            var t = this._angleAxis;
            return e === t ? this._radiusAxis : t
        }, a.prototype.getBaseAxis = function () {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
        }, a.prototype.getTooltipAxes = function (e) {
            var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
            return {
                baseAxes: [t],
                otherAxes: [this.getOtherAxis(t)]
            }
        }, a.prototype.dataToPoint = function (e, t) {
            return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)])
        }, a.prototype.pointToData = function (e, t) {
            var r = this.pointToCoord(e);
            return [this._radiusAxis.radiusToData(r[0], t), this._angleAxis.angleToData(r[1], t)]
        }, a.prototype.pointToCoord = function (e) {
            var t = e[0] - this.cx,
                r = e[1] - this.cy,
                i = this.getAngleAxis(),
                n = i.getExtent(),
                o = Math.min(n[0], n[1]),
                s = Math.max(n[0], n[1]);
            i.inverse ? o = s - 360 : s = o + 360;
            var l = Math.sqrt(t * t + r * r);
            t /= l, r /= l;
            for (var u = Math.atan2(-r, t) / Math.PI * 180, v = u < o ? 1 : -1; u < o || u > s;) u += v * 360;
            return [l, u]
        }, a.prototype.coordToPoint = function (e) {
            var t = e[0],
                r = e[1] / 180 * Math.PI,
                i = Math.cos(r) * t + this.cx,
                n = -Math.sin(r) * t + this.cy;
            return [i, n]
        }, a.prototype.getArea = function () {
            var e = this.getAngleAxis(),
                t = this.getRadiusAxis(),
                r = t.getExtent().slice();
            r[0] > r[1] && r.reverse();
            var i = e.getExtent(),
                n = Math.PI / 180;
            return {
                cx: this.cx,
                cy: this.cy,
                r0: r[0],
                r: r[1],
                startAngle: -i[0] * n,
                endAngle: -i[1] * n,
                clockwise: e.inverse,
                contain: function (o, s) {
                    var l = o - this.cx,
                        u = s - this.cy,
                        v = l * l + u * u - 1e-4,
                        h = this.r,
                        c = this.r0;
                    return v <= h * h && v >= c * c
                }
            }
        }, a.prototype.convertToPixel = function (e, t, r) {
            var i = ic(t);
            return i === this ? this.dataToPoint(r) : null
        }, a.prototype.convertFromPixel = function (e, t, r) {
            var i = ic(t);
            return i === this ? this.pointToData(r) : null
        }, a
    }();

function ic(a) {
    var e = a.seriesModel,
        t = a.polarModel;
    return t && t.coordinateSystem || e && e.coordinateSystem
}
const aD = rD;

function iD(a, e, t) {
    var r = e.get("center"),
        i = t.getWidth(),
        n = t.getHeight();
    a.cx = H(r[0], i), a.cy = H(r[1], n);
    var o = a.getRadiusAxis(),
        s = Math.min(i, n) / 2,
        l = e.get("radius");
    l == null ? l = [0, "100%"] : B(l) || (l = [0, l]);
    var u = [H(l[0], s), H(l[1], s)];
    o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1])
}

function nD(a, e) {
    var t = this,
        r = t.getAngleAxis(),
        i = t.getRadiusAxis();
    if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), a.eachSeries(function (s) {
            if (s.coordinateSystem === t) {
                var l = s.getData();
                T(Yo(l, "radius"), function (u) {
                    i.scale.unionExtentFromData(l, u)
                }), T(Yo(l, "angle"), function (u) {
                    r.scale.unionExtentFromData(l, u)
                })
            }
        }), Zr(r.scale, r.model), Zr(i.scale, i.model), r.type === "category" && !r.onBand) {
        var n = r.getExtent(),
            o = 360 / r.scale.count();
        r.inverse ? n[1] += o : n[1] -= o, r.setExtent(n[0], n[1])
    }
}

function oD(a) {
    return a.mainType === "angleAxis"
}

function nc(a, e) {
    var t;
    if (a.type = e.get("type"), a.scale = en(e), a.onBand = e.get("boundaryGap") && a.type === "category", a.inverse = e.get("inverse"), oD(e)) {
        a.inverse = a.inverse !== e.get("clockwise");
        var r = e.get("startAngle"),
            i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : r + (a.inverse ? -360 : 360);
        a.setExtent(r, i)
    }
    e.axis = a, a.model = e
}
var sD = {
    dimensions: Sg,
    create: function (a, e) {
        var t = [];
        return a.eachComponent("polar", function (r, i) {
            var n = new aD(i + "");
            n.update = nD;
            var o = n.getRadiusAxis(),
                s = n.getAngleAxis(),
                l = r.findAxisModel("radiusAxis"),
                u = r.findAxisModel("angleAxis");
            nc(o, l), nc(s, u), iD(n, r, e), t.push(n), r.coordinateSystem = n, n.model = r
        }), a.eachSeries(function (r) {
            if (r.get("coordinateSystem") === "polar") {
                var i = r.getReferringComponents("polar", Kt).models[0];
                r.coordinateSystem = i.coordinateSystem
            }
        }), t
    }
};
const lD = sD;
var uD = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];

function vi(a, e, t) {
    e[1] > e[0] && (e = e.slice().reverse());
    var r = a.coordToPoint([e[0], t]),
        i = a.coordToPoint([e[1], t]);
    return {
        x1: r[0],
        y1: r[1],
        x2: i[0],
        y2: i[1]
    }
}

function hi(a) {
    var e = a.getRadiusAxis();
    return e.inverse ? 0 : 1
}

function oc(a) {
    var e = a[0],
        t = a[a.length - 1];
    e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && a.pop()
}
var vD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t
        }
        return e.prototype.render = function (t, r) {
            if (this.group.removeAll(), !!t.get("show")) {
                var i = t.axis,
                    n = i.polar,
                    o = n.getRadiusAxis().getExtent(),
                    s = i.getTicksCoords(),
                    l = i.getMinorTicksCoords(),
                    u = G(i.getViewLabels(), function (v) {
                        v = ot(v);
                        var h = i.scale,
                            c = h.type === "ordinal" ? h.getRawOrdinalNumber(v.tickValue) : v.tickValue;
                        return v.coord = i.dataToCoord(c), v
                    });
                oc(u), oc(s), T(uD, function (v) {
                    t.get([v, "show"]) && (!i.scale.isBlank() || v === "axisLine") && hD[v](this.group, t, n, s, l, o, u)
                }, this)
            }
        }, e.type = "angleAxis", e
    }(xr),
    hD = {
        axisLine: function (a, e, t, r, i, n) {
            var o = e.getModel(["axisLine", "lineStyle"]),
                s = t.getAngleAxis(),
                l = Math.PI / 180,
                u = s.getExtent(),
                v = hi(t),
                h = v ? 0 : 1,
                c, f = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
            n[h] === 0 ? c = new Qr[f]({
                shape: {
                    cx: t.cx,
                    cy: t.cy,
                    r: n[v],
                    startAngle: -u[0] * l,
                    endAngle: -u[1] * l,
                    clockwise: s.inverse
                },
                style: o.getLineStyle(),
                z2: 1,
                silent: !0
            }) : c = new km({
                shape: {
                    cx: t.cx,
                    cy: t.cy,
                    r: n[v],
                    r0: n[h]
                },
                style: o.getLineStyle(),
                z2: 1,
                silent: !0
            }), c.style.fill = null, a.add(c)
        },
        axisTick: function (a, e, t, r, i, n) {
            var o = e.getModel("axisTick"),
                s = (o.get("inside") ? -1 : 1) * o.get("length"),
                l = n[hi(t)],
                u = G(r, function (v) {
                    return new Jt({
                        shape: vi(t, [l, l + s], v.coord)
                    })
                });
            a.add(xe(u, {
                style: at(o.getModel("lineStyle").getLineStyle(), {
                    stroke: e.get(["axisLine", "lineStyle", "color"])
                })
            }))
        },
        minorTick: function (a, e, t, r, i, n) {
            if (i.length) {
                for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = n[hi(t)], v = [], h = 0; h < i.length; h++)
                    for (var c = 0; c < i[h].length; c++) v.push(new Jt({
                        shape: vi(t, [u, u + l], i[h][c].coord)
                    }));
                a.add(xe(v, {
                    style: at(s.getModel("lineStyle").getLineStyle(), at(o.getLineStyle(), {
                        stroke: e.get(["axisLine", "lineStyle", "color"])
                    }))
                }))
            }
        },
        axisLabel: function (a, e, t, r, i, n, o) {
            var s = e.getCategories(!0),
                l = e.getModel("axisLabel"),
                u = l.get("margin"),
                v = e.get("triggerEvent");
            T(o, function (h, c) {
                var f = l,
                    p = h.tickValue,
                    d = n[hi(t)],
                    g = t.coordToPoint([d + u, h.coord]),
                    y = t.cx,
                    x = t.cy,
                    m = Math.abs(g[0] - y) / d < .3 ? "center" : g[0] > y ? "left" : "right",
                    S = Math.abs(g[1] - x) / d < .3 ? "middle" : g[1] > x ? "top" : "bottom";
                if (s && s[p]) {
                    var _ = s[p];
                    St(_) && _.textStyle && (f = new Rt(_.textStyle, l, l.ecModel))
                }
                var b = new ut({
                    silent: ze.isLabelSilent(e),
                    style: mt(f, {
                        x: g[0],
                        y: g[1],
                        fill: f.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
                        text: h.formattedLabel,
                        align: m,
                        verticalAlign: S
                    })
                });
                if (a.add(b), v) {
                    var w = ze.makeAxisEventDataBase(e);
                    w.targetType = "axisLabel", w.value = h.rawLabel, tt(b).eventData = w
                }
            }, this)
        },
        splitLine: function (a, e, t, r, i, n) {
            var o = e.getModel("splitLine"),
                s = o.getModel("lineStyle"),
                l = s.get("color"),
                u = 0;
            l = l instanceof Array ? l : [l];
            for (var v = [], h = 0; h < r.length; h++) {
                var c = u++ % l.length;
                v[c] = v[c] || [], v[c].push(new Jt({
                    shape: vi(t, n, r[h].coord)
                }))
            }
            for (var h = 0; h < v.length; h++) a.add(xe(v[h], {
                style: at({
                    stroke: l[h % l.length]
                }, s.getLineStyle()),
                silent: !0,
                z: e.get("z")
            }))
        },
        minorSplitLine: function (a, e, t, r, i, n) {
            if (i.length) {
                for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
                    for (var v = 0; v < i[u].length; v++) l.push(new Jt({
                        shape: vi(t, n, i[u][v].coord)
                    }));
                a.add(xe(l, {
                    style: s.getLineStyle(),
                    silent: !0,
                    z: e.get("z")
                }))
            }
        },
        splitArea: function (a, e, t, r, i, n) {
            if (r.length) {
                var o = e.getModel("splitArea"),
                    s = o.getModel("areaStyle"),
                    l = s.get("color"),
                    u = 0;
                l = l instanceof Array ? l : [l];
                for (var v = [], h = Math.PI / 180, c = -r[0].coord * h, f = Math.min(n[0], n[1]), p = Math.max(n[0], n[1]), d = e.get("clockwise"), g = 1, y = r.length; g <= y; g++) {
                    var x = g === y ? r[0].coord : r[g].coord,
                        m = u++ % l.length;
                    v[m] = v[m] || [], v[m].push(new cr({
                        shape: {
                            cx: t.cx,
                            cy: t.cy,
                            r0: f,
                            r: p,
                            startAngle: c,
                            endAngle: -x * h,
                            clockwise: d
                        },
                        silent: !0
                    })), c = -x * h
                }
                for (var g = 0; g < v.length; g++) a.add(xe(v[g], {
                    style: at({
                        fill: l[g % l.length]
                    }, s.getAreaStyle()),
                    silent: !0
                }))
            }
        }
    };
const cD = vD;
var fD = ["axisLine", "axisTickLabel", "axisName"],
    pD = ["splitLine", "splitArea", "minorSplitLine"],
    dD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t
        }
        return e.prototype.render = function (t, r) {
            if (this.group.removeAll(), !!t.get("show")) {
                var i = this._axisGroup,
                    n = this._axisGroup = new U;
                this.group.add(n);
                var o = t.axis,
                    s = o.polar,
                    l = s.getAngleAxis(),
                    u = o.getTicksCoords(),
                    v = o.getMinorTicksCoords(),
                    h = l.getExtent()[0],
                    c = o.getExtent(),
                    f = yD(s, t, h),
                    p = new ze(t, f);
                T(fD, p.add, p), n.add(p.getGroup()), rn(i, n, t), T(pD, function (d) {
                    t.get([d, "show"]) && !o.scale.isBlank() && gD[d](this.group, t, s, h, c, u, v)
                }, this)
            }
        }, e.type = "radiusAxis", e
    }(xr),
    gD = {
        splitLine: function (a, e, t, r, i, n) {
            var o = e.getModel("splitLine"),
                s = o.getModel("lineStyle"),
                l = s.get("color"),
                u = 0,
                v = t.getAngleAxis(),
                h = Math.PI / 180,
                c = v.getExtent(),
                f = Math.abs(c[1] - c[0]) === 360 ? "Circle" : "Arc";
            l = l instanceof Array ? l : [l];
            for (var p = [], d = 0; d < n.length; d++) {
                var g = u++ % l.length;
                p[g] = p[g] || [], p[g].push(new Qr[f]({
                    shape: {
                        cx: t.cx,
                        cy: t.cy,
                        r: Math.max(n[d].coord, 0),
                        startAngle: -c[0] * h,
                        endAngle: -c[1] * h,
                        clockwise: v.inverse
                    }
                }))
            }
            for (var d = 0; d < p.length; d++) a.add(xe(p[d], {
                style: at({
                    stroke: l[d % l.length],
                    fill: null
                }, s.getLineStyle()),
                silent: !0
            }))
        },
        minorSplitLine: function (a, e, t, r, i, n, o) {
            if (o.length) {
                for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], v = 0; v < o.length; v++)
                    for (var h = 0; h < o[v].length; h++) u.push(new nn({
                        shape: {
                            cx: t.cx,
                            cy: t.cy,
                            r: o[v][h].coord
                        }
                    }));
                a.add(xe(u, {
                    style: at({
                        fill: null
                    }, l.getLineStyle()),
                    silent: !0
                }))
            }
        },
        splitArea: function (a, e, t, r, i, n) {
            if (n.length) {
                var o = e.getModel("splitArea"),
                    s = o.getModel("areaStyle"),
                    l = s.get("color"),
                    u = 0;
                l = l instanceof Array ? l : [l];
                for (var v = [], h = n[0].coord, c = 1; c < n.length; c++) {
                    var f = u++ % l.length;
                    v[f] = v[f] || [], v[f].push(new cr({
                        shape: {
                            cx: t.cx,
                            cy: t.cy,
                            r0: h,
                            r: n[c].coord,
                            startAngle: 0,
                            endAngle: Math.PI * 2
                        },
                        silent: !0
                    })), h = n[c].coord
                }
                for (var c = 0; c < v.length; c++) a.add(xe(v[c], {
                    style: at({
                        fill: l[c % l.length]
                    }, s.getAreaStyle()),
                    silent: !0
                }))
            }
        }
    };

function yD(a, e, t) {
    return {
        position: [a.cx, a.cy],
        rotation: t / 180 * Math.PI,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1,
        labelRotate: e.getModel("axisLabel").get("rotate"),
        z2: 1
    }
}
const mD = dD;

function _g(a) {
    return a.get("stack") || "__ec_stack_" + a.seriesIndex
}

function bg(a, e) {
    return e.dim + a.model.componentIndex
}

function xD(a, e, t) {
    var r = {},
        i = SD(Dt(e.getSeriesByType(a), function (n) {
            return !e.isSeriesFiltered(n) && n.coordinateSystem && n.coordinateSystem.type === "polar"
        }));
    e.eachSeriesByType(a, function (n) {
        if (n.coordinateSystem.type === "polar") {
            var o = n.getData(),
                s = n.coordinateSystem,
                l = s.getBaseAxis(),
                u = bg(s, l),
                v = _g(n),
                h = i[u][v],
                c = h.offset,
                f = h.width,
                p = s.getOtherAxis(l),
                d = n.coordinateSystem.cx,
                g = n.coordinateSystem.cy,
                y = n.get("barMinHeight") || 0,
                x = n.get("barMinAngle") || 0;
            r[v] = r[v] || [];
            for (var m = o.mapDimension(p.dim), S = o.mapDimension(l.dim), _ = Wr(o, m), b = l.dim !== "radius" || !n.get("roundCap", !0), w = p.dataToCoord(0), A = 0, C = o.count(); A < C; A++) {
                var D = o.get(m, A),
                    I = o.get(S, A),
                    L = D >= 0 ? "p" : "n",
                    M = w;
                _ && (r[v][I] || (r[v][I] = {
                    p: w,
                    n: w
                }), M = r[v][I][L]);
                var P = void 0,
                    R = void 0,
                    k = void 0,
                    V = void 0;
                if (p.dim === "radius") {
                    var O = p.dataToCoord(D) - w,
                        z = l.dataToCoord(I);
                    Math.abs(O) < y && (O = (O < 0 ? -1 : 1) * y), P = M, R = M + O, k = z - c, V = k - f, _ && (r[v][I][L] = R)
                } else {
                    var $ = p.dataToCoord(D, b) - w,
                        Z = l.dataToCoord(I);
                    Math.abs($) < x && ($ = ($ < 0 ? -1 : 1) * x), P = Z + c, R = P + f, k = M, V = M + $, _ && (r[v][I][L] = V)
                }
                o.setItemLayout(A, {
                    cx: d,
                    cy: g,
                    r0: P,
                    r: R,
                    startAngle: -k * Math.PI / 180,
                    endAngle: -V * Math.PI / 180,
                    clockwise: k >= V
                })
            }
        }
    })
}

function SD(a) {
    var e = {};
    T(a, function (r, i) {
        var n = r.getData(),
            o = r.coordinateSystem,
            s = o.getBaseAxis(),
            l = bg(o, s),
            u = s.getExtent(),
            v = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / n.count(),
            h = e[l] || {
                bandWidth: v,
                remainedWidth: v,
                autoWidthCount: 0,
                categoryGap: "20%",
                gap: "30%",
                stacks: {}
            },
            c = h.stacks;
        e[l] = h;
        var f = _g(r);
        c[f] || h.autoWidthCount++, c[f] = c[f] || {
            width: 0,
            maxWidth: 0
        };
        var p = H(r.get("barWidth"), v),
            d = H(r.get("barMaxWidth"), v),
            g = r.get("barGap"),
            y = r.get("barCategoryGap");
        p && !c[f].width && (p = Math.min(h.remainedWidth, p), c[f].width = p, h.remainedWidth -= p), d && (c[f].maxWidth = d), g != null && (h.gap = g), y != null && (h.categoryGap = y)
    });
    var t = {};
    return T(e, function (r, i) {
        t[i] = {};
        var n = r.stacks,
            o = r.bandWidth,
            s = H(r.categoryGap, o),
            l = H(r.gap, 1),
            u = r.remainedWidth,
            v = r.autoWidthCount,
            h = (u - s) / (v + (v - 1) * l);
        h = Math.max(h, 0), T(n, function (d, g) {
            var y = d.maxWidth;
            y && y < h && (y = Math.min(y, u), d.width && (y = Math.min(y, d.width)), u -= y, d.width = y, v--)
        }), h = (u - s) / (v + (v - 1) * l), h = Math.max(h, 0);
        var c = 0,
            f;
        T(n, function (d, g) {
            d.width || (d.width = h), f = d, c += d.width * (1 + l)
        }), f && (c -= f.width * l);
        var p = -c / 2;
        T(n, function (d, g) {
            t[i][g] = t[i][g] || {
                offset: p,
                width: d.width
            }, p += d.width * (1 + l)
        })
    }), t
}
var _D = {
        startAngle: 90,
        clockwise: !0,
        splitNumber: 12,
        axisLabel: {
            rotate: 0
        }
    },
    bD = {
        splitNumber: 5
    },
    wD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.type = "polar", e
    }(It);

function AD(a) {
    j(ja), xr.registerAxisPointerClass("PolarAxisPointer", qC), a.registerCoordinateSystem("polar", lD), a.registerComponentModel(JC), a.registerComponentView(wD), Yr(a, "angle", QC, _D), Yr(a, "radius", tD, bD), a.registerComponentView(cD), a.registerComponentView(mD), a.registerLayout(K(xD, "bar"))
}

function Ls(a, e) {
    e = e || {};
    var t = a.coordinateSystem,
        r = a.axis,
        i = {},
        n = r.position,
        o = r.orient,
        s = t.getRect(),
        l = [s.x, s.x + s.width, s.y, s.y + s.height],
        u = {
            horizontal: {
                top: l[2],
                bottom: l[3]
            },
            vertical: {
                left: l[0],
                right: l[1]
            }
        };
    i.position = [o === "vertical" ? u.vertical[n] : l[0], o === "horizontal" ? u.horizontal[n] : l[3]];
    var v = {
        horizontal: 0,
        vertical: 1
    };
    i.rotation = Math.PI / 2 * v[o];
    var h = {
        top: -1,
        bottom: 1,
        right: 1,
        left: -1
    };
    i.labelDirection = i.tickDirection = i.nameDirection = h[n], a.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), Ut(e.labelInside, a.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
    var c = e.rotate;
    return c == null && (c = a.get(["axisLabel", "rotate"])), i.labelRotation = n === "top" ? -c : c, i.z2 = 1, i
}
var TD = ["axisLine", "axisTickLabel", "axisName"],
    CD = ["splitArea", "splitLine"],
    DD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t
        }
        return e.prototype.render = function (t, r, i, n) {
            var o = this.group;
            o.removeAll();
            var s = this._axisGroup;
            this._axisGroup = new U;
            var l = Ls(t),
                u = new ze(t, l);
            T(TD, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), T(CD, function (v) {
                t.get([v, "show"]) && ID[v](this, this.group, this._axisGroup, t)
            }, this), rn(s, this._axisGroup, t), a.prototype.render.call(this, t, r, i, n)
        }, e.prototype.remove = function () {
            Fp(this)
        }, e.type = "singleAxis", e
    }(xr),
    ID = {
        splitLine: function (a, e, t, r) {
            var i = r.axis;
            if (!i.scale.isBlank()) {
                var n = r.getModel("splitLine"),
                    o = n.getModel("lineStyle"),
                    s = o.get("color");
                s = s instanceof Array ? s : [s];
                for (var l = o.get("width"), u = r.coordinateSystem.getRect(), v = i.isHorizontal(), h = [], c = 0, f = i.getTicksCoords({
                        tickModel: n
                    }), p = [], d = [], g = 0; g < f.length; ++g) {
                    var y = i.toGlobalCoord(f[g].coord);
                    v ? (p[0] = y, p[1] = u.y, d[0] = y, d[1] = u.y + u.height) : (p[0] = u.x, p[1] = y, d[0] = u.x + u.width, d[1] = y);
                    var x = new Jt({
                        shape: {
                            x1: p[0],
                            y1: p[1],
                            x2: d[0],
                            y2: d[1]
                        },
                        silent: !0
                    });
                    Ko(x.shape, l);
                    var m = c++ % s.length;
                    h[m] = h[m] || [], h[m].push(x)
                }
                for (var S = o.getLineStyle(["color"]), g = 0; g < h.length; ++g) e.add(xe(h[g], {
                    style: at({
                        stroke: s[g % s.length]
                    }, S),
                    silent: !0
                }))
            }
        },
        splitArea: function (a, e, t, r) {
            Hp(a, t, r, r)
        }
    };
const LD = DD;
var wg = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.getCoordSysModel = function () {
        return this
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
        left: "5%",
        top: "5%",
        right: "5%",
        bottom: "5%",
        type: "value",
        position: "bottom",
        orient: "horizontal",
        axisLine: {
            show: !0,
            lineStyle: {
                width: 1,
                type: "solid"
            }
        },
        tooltip: {
            show: !0
        },
        axisTick: {
            show: !0,
            length: 6,
            lineStyle: {
                width: 1
            }
        },
        axisLabel: {
            show: !0,
            interval: "auto"
        },
        splitLine: {
            show: !0,
            lineStyle: {
                type: "dashed",
                opacity: .2
            }
        }
    }, e
}(Ct);
le(wg, Ji.prototype);
const Ao = wg;
var MD = function (a) {
    E(e, a);

    function e(t, r, i, n, o) {
        var s = a.call(this, t, r, i) || this;
        return s.type = n || "value", s.position = o || "bottom", s
    }
    return e.prototype.isHorizontal = function () {
        var t = this.position;
        return t === "top" || t === "bottom"
    }, e.prototype.pointToData = function (t, r) {
        return this.coordinateSystem.pointToData(t)[0]
    }, e
}(ye);
const PD = MD;
var Ag = ["single"],
    RD = function () {
        function a(e, t, r) {
            this.type = "single", this.dimension = "single", this.dimensions = Ag, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, r)
        }
        return a.prototype._init = function (e, t, r) {
            var i = this.dimension,
                n = new PD(i, en(e), [0, 0], e.get("type"), e.get("position")),
                o = n.type === "category";
            n.onBand = o && e.get("boundaryGap"), n.inverse = e.get("inverse"), n.orient = e.get("orient"), e.axis = n, n.model = e, n.coordinateSystem = this, this._axis = n
        }, a.prototype.update = function (e, t) {
            e.eachSeries(function (r) {
                if (r.coordinateSystem === this) {
                    var i = r.getData();
                    T(i.mapDimensionsAll(this.dimension), function (n) {
                        this._axis.scale.unionExtentFromData(i, n)
                    }, this), Zr(this._axis.scale, this._axis.model)
                }
            }, this)
        }, a.prototype.resize = function (e, t) {
            this._rect = kt({
                left: e.get("left"),
                top: e.get("top"),
                right: e.get("right"),
                bottom: e.get("bottom"),
                width: e.get("width"),
                height: e.get("height")
            }, {
                width: t.getWidth(),
                height: t.getHeight()
            }), this._adjustAxis()
        }, a.prototype.getRect = function () {
            return this._rect
        }, a.prototype._adjustAxis = function () {
            var e = this._rect,
                t = this._axis,
                r = t.isHorizontal(),
                i = r ? [0, e.width] : [0, e.height],
                n = t.inverse ? 1 : 0;
            t.setExtent(i[n], i[1 - n]), this._updateAxisTransform(t, r ? e.x : e.y)
        }, a.prototype._updateAxisTransform = function (e, t) {
            var r = e.getExtent(),
                i = r[0] + r[1],
                n = e.isHorizontal();
            e.toGlobalCoord = n ? function (o) {
                return o + t
            } : function (o) {
                return i - o + t
            }, e.toLocalCoord = n ? function (o) {
                return o - t
            } : function (o) {
                return i - o + t
            }
        }, a.prototype.getAxis = function () {
            return this._axis
        }, a.prototype.getBaseAxis = function () {
            return this._axis
        }, a.prototype.getAxes = function () {
            return [this._axis]
        }, a.prototype.getTooltipAxes = function () {
            return {
                baseAxes: [this.getAxis()],
                otherAxes: []
            }
        }, a.prototype.containPoint = function (e) {
            var t = this.getRect(),
                r = this.getAxis(),
                i = r.orient;
            return i === "horizontal" ? r.contain(r.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : r.contain(r.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height
        }, a.prototype.pointToData = function (e) {
            var t = this.getAxis();
            return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))]
        }, a.prototype.dataToPoint = function (e) {
            var t = this.getAxis(),
                r = this.getRect(),
                i = [],
                n = t.orient === "horizontal" ? 0 : 1;
            return e instanceof Array && (e = e[0]), i[n] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - n] = n === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i
        }, a.prototype.convertToPixel = function (e, t, r) {
            var i = sc(t);
            return i === this ? this.dataToPoint(r) : null
        }, a.prototype.convertFromPixel = function (e, t, r) {
            var i = sc(t);
            return i === this ? this.pointToData(r) : null
        }, a
    }();

function sc(a) {
    var e = a.seriesModel,
        t = a.singleAxisModel;
    return t && t.coordinateSystem || e && e.coordinateSystem
}

function ED(a, e) {
    var t = [];
    return a.eachComponent("singleAxis", function (r, i) {
        var n = new RD(r, a, e);
        n.name = "single_" + i, n.resize(r, e), r.coordinateSystem = n, t.push(n)
    }), a.eachSeries(function (r) {
        if (r.get("coordinateSystem") === "singleAxis") {
            var i = r.getReferringComponents("singleAxis", Kt).models[0];
            r.coordinateSystem = i && i.coordinateSystem
        }
    }), t
}
var kD = {
    create: ED,
    dimensions: Ag
};
const VD = kD;
var lc = ["x", "y"],
    OD = ["width", "height"],
    zD = function (a) {
        E(e, a);

        function e() {
            return a !== null && a.apply(this, arguments) || this
        }
        return e.prototype.makeElOption = function (t, r, i, n, o) {
            var s = i.axis,
                l = s.coordinateSystem,
                u = To(l, 1 - Bi(s)),
                v = l.dataToPoint(r)[0],
                h = n.get("type");
            if (h && h !== "none") {
                var c = Bl(n),
                    f = ND[h](s, v, u);
                f.style = c, t.graphicKey = f.type, t.pointer = f
            }
            var p = Ls(i);
            gg(r, t, p, i, n, o)
        }, e.prototype.getHandleTransform = function (t, r, i) {
            var n = Ls(r, {
                labelInside: !1
            });
            n.labelMargin = i.get(["handle", "margin"]);
            var o = Hl(r.axis, t, n);
            return {
                x: o[0],
                y: o[1],
                rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
            }
        }, e.prototype.updateHandleTransform = function (t, r, i, n) {
            var o = i.axis,
                s = o.coordinateSystem,
                l = Bi(o),
                u = To(s, l),
                v = [t.x, t.y];
            v[l] += r[l], v[l] = Math.min(u[1], v[l]), v[l] = Math.max(u[0], v[l]);
            var h = To(s, 1 - l),
                c = (h[1] + h[0]) / 2,
                f = [c, c];
            return f[l] = v[l], {
                x: v[0],
                y: v[1],
                rotation: t.rotation,
                cursorPoint: f,
                tooltipOption: {
                    verticalAlign: "middle"
                }
            }
        }, e
    }(Gl),
    ND = {
        line: function (a, e, t) {
            var r = Fl([e, t[0]], [e, t[1]], Bi(a));
            return {
                type: "Line",
                subPixelOptimize: !0,
                shape: r
            }
        },
        shadow: function (a, e, t) {
            var r = a.getBandWidth(),
                i = t[1] - t[0];
            return {
                type: "Rect",
                shape: yg([e - r / 2, t[0]], [r, i], Bi(a))
            }
        }
    };

function Bi(a) {
    return a.isHorizontal() ? 0 : 1
}

function To(a, e) {
    var t = a.getRect();
    return [t[lc[e]], t[lc[e]] + t[OD[e]]]
}
const GD = zD;
var BD = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "single", e
}(It);

function HD(a) {
    j(ja), xr.registerAxisPointerClass("SingleAxisPointer", GD), a.registerComponentView(BD), a.registerComponentView(LD), a.registerComponentModel(Ao), Yr(a, "single", Ao, Ao.defaultOption), a.registerCoordinateSystem("single", VD)
}
var FD = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function (t, r, i) {
        var n = Qi(t);
        a.prototype.init.apply(this, arguments), uc(t, n)
    }, e.prototype.mergeOption = function (t) {
        a.prototype.mergeOption.apply(this, arguments), uc(this.option, t)
    }, e.prototype.getCellSize = function () {
        return this.option.cellSize
    }, e.type = "calendar", e.defaultOption = {
        z: 2,
        left: 80,
        top: 60,
        cellSize: 20,
        orient: "horizontal",
        splitLine: {
            show: !0,
            lineStyle: {
                color: "#000",
                width: 1,
                type: "solid"
            }
        },
        itemStyle: {
            color: "#fff",
            borderWidth: 1,
            borderColor: "#ccc"
        },
        dayLabel: {
            show: !0,
            firstDay: 0,
            position: "start",
            margin: "50%",
            color: "#000"
        },
        monthLabel: {
            show: !0,
            position: "start",
            margin: 5,
            align: "center",
            formatter: null,
            color: "#000"
        },
        yearLabel: {
            show: !0,
            position: null,
            margin: 30,
            formatter: null,
            color: "#ccc",
            fontFamily: "sans-serif",
            fontWeight: "bolder",
            fontSize: 20
        }
    }, e
}(Ct);

function uc(a, e) {
    var t = a.cellSize,
        r;
    B(t) ? r = t : r = a.cellSize = [t, t], r.length === 1 && (r[1] = r[0]);
    var i = G([0, 1], function (n) {
        return Vm(e, n) && (r[n] = "auto"), r[n] != null && r[n] !== "auto"
    });
    tn(a, e, {
        type: "box",
        ignoreSize: i
    })
}
const WD = FD;
var $D = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i) {
        var n = this.group;
        n.removeAll();
        var o = t.coordinateSystem,
            s = o.getRangeInfo(),
            l = o.getOrient(),
            u = r.getLocaleModel();
        this._renderDayRect(t, s, n), this._renderLines(t, s, l, n), this._renderYearText(t, s, l, n), this._renderMonthText(t, u, l, n), this._renderWeekText(t, u, s, l, n)
    }, e.prototype._renderDayRect = function (t, r, i) {
        for (var n = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = n.getCellWidth(), l = n.getCellHeight(), u = r.start.time; u <= r.end.time; u = n.getNextNDay(u, 1).time) {
            var v = n.dataToRect([u], !1).tl,
                h = new pt({
                    shape: {
                        x: v[0],
                        y: v[1],
                        width: s,
                        height: l
                    },
                    cursor: "default",
                    style: o
                });
            i.add(h)
        }
    }, e.prototype._renderLines = function (t, r, i, n) {
        var o = this,
            s = t.coordinateSystem,
            l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(),
            u = t.get(["splitLine", "show"]),
            v = l.lineWidth;
        this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
        for (var h = r.start, c = 0; h.time <= r.end.time; c++) {
            p(h.formatedDate), c === 0 && (h = s.getDateInfo(r.start.y + "-" + r.start.m));
            var f = h.date;
            f.setMonth(f.getMonth() + 1), h = s.getDateInfo(f)
        }
        p(s.getNextNDay(r.end.time, 1).formatedDate);

        function p(d) {
            o._firstDayOfMonth.push(s.getDateInfo(d)), o._firstDayPoints.push(s.dataToRect([d], !1).tl);
            var g = o._getLinePointsOfOneWeek(t, d, i);
            o._tlpoints.push(g[0]), o._blpoints.push(g[g.length - 1]), u && o._drawSplitline(g, l, n)
        }
        u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, v, i), l, n), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, v, i), l, n)
    }, e.prototype._getEdgesPoints = function (t, r, i) {
        var n = [t[0].slice(), t[t.length - 1].slice()],
            o = i === "horizontal" ? 0 : 1;
        return n[0][o] = n[0][o] - r / 2, n[1][o] = n[1][o] + r / 2, n
    }, e.prototype._drawSplitline = function (t, r, i) {
        var n = new $e({
            z2: 20,
            shape: {
                points: t
            },
            style: r
        });
        i.add(n)
    }, e.prototype._getLinePointsOfOneWeek = function (t, r, i) {
        for (var n = t.coordinateSystem, o = n.getDateInfo(r), s = [], l = 0; l < 7; l++) {
            var u = n.getNextNDay(o.time, l),
                v = n.dataToRect([u.time], !1);
            s[2 * u.day] = v.tl, s[2 * u.day + 1] = v[i === "horizontal" ? "bl" : "tr"]
        }
        return s
    }, e.prototype._formatterLabel = function (t, r) {
        return q(t) && t ? Om(t, r) : rt(t) ? t(r) : r.nameMap
    }, e.prototype._yearTextPositionControl = function (t, r, i, n, o) {
        var s = r[0],
            l = r[1],
            u = ["center", "bottom"];
        n === "bottom" ? (l += o, u = ["center", "top"]) : n === "left" ? s -= o : n === "right" ? (s += o, u = ["center", "top"]) : l -= o;
        var v = 0;
        return (n === "left" || n === "right") && (v = Math.PI / 2), {
            rotation: v,
            x: s,
            y: l,
            style: {
                align: u[0],
                verticalAlign: u[1]
            }
        }
    }, e.prototype._renderYearText = function (t, r, i, n) {
        var o = t.getModel("yearLabel");
        if (o.get("show")) {
            var s = o.get("margin"),
                l = o.get("position");
            l || (l = i !== "horizontal" ? "top" : "left");
            var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
                v = (u[0][0] + u[1][0]) / 2,
                h = (u[0][1] + u[1][1]) / 2,
                c = i === "horizontal" ? 0 : 1,
                f = {
                    top: [v, u[c][1]],
                    bottom: [v, u[1 - c][1]],
                    left: [u[1 - c][0], h],
                    right: [u[c][0], h]
                },
                p = r.start.y; + r.end.y > +r.start.y && (p = p + "-" + r.end.y);
            var d = o.get("formatter"),
                g = {
                    start: r.start.y,
                    end: r.end.y,
                    nameMap: p
                },
                y = this._formatterLabel(d, g),
                x = new ut({
                    z2: 30,
                    style: mt(o, {
                        text: y
                    })
                });
            x.attr(this._yearTextPositionControl(x, f[l], i, l, s)), n.add(x)
        }
    }, e.prototype._monthTextPositionControl = function (t, r, i, n, o) {
        var s = "left",
            l = "top",
            u = t[0],
            v = t[1];
        return i === "horizontal" ? (v = v + o, r && (s = "center"), n === "start" && (l = "bottom")) : (u = u + o, r && (l = "middle"), n === "start" && (s = "right")), {
            x: u,
            y: v,
            align: s,
            verticalAlign: l
        }
    }, e.prototype._renderMonthText = function (t, r, i, n) {
        var o = t.getModel("monthLabel");
        if (o.get("show")) {
            var s = o.get("nameMap"),
                l = o.get("margin"),
                u = o.get("position"),
                v = o.get("align"),
                h = [this._tlpoints, this._blpoints];
            (!s || q(s)) && (s && (r = bu(s) || r), s = r.get(["time", "monthAbbr"]) || []);
            var c = u === "start" ? 0 : 1,
                f = i === "horizontal" ? 0 : 1;
            l = u === "start" ? -l : l;
            for (var p = v === "center", d = 0; d < h[c].length - 1; d++) {
                var g = h[c][d].slice(),
                    y = this._firstDayOfMonth[d];
                if (p) {
                    var x = this._firstDayPoints[d];
                    g[f] = (x[f] + h[0][d + 1][f]) / 2
                }
                var m = o.get("formatter"),
                    S = s[+y.m - 1],
                    _ = {
                        yyyy: y.y,
                        yy: (y.y + "").slice(2),
                        MM: y.m,
                        M: +y.m,
                        nameMap: S
                    },
                    b = this._formatterLabel(m, _),
                    w = new ut({
                        z2: 30,
                        style: W(mt(o, {
                            text: b
                        }), this._monthTextPositionControl(g, p, i, u, l))
                    });
                n.add(w)
            }
        }
    }, e.prototype._weekTextPositionControl = function (t, r, i, n, o) {
        var s = "center",
            l = "middle",
            u = t[0],
            v = t[1],
            h = i === "start";
        return r === "horizontal" ? (u = u + n + (h ? 1 : -1) * o[0] / 2, s = h ? "right" : "left") : (v = v + n + (h ? 1 : -1) * o[1] / 2, l = h ? "bottom" : "top"), {
            x: u,
            y: v,
            align: s,
            verticalAlign: l
        }
    }, e.prototype._renderWeekText = function (t, r, i, n, o) {
        var s = t.getModel("dayLabel");
        if (s.get("show")) {
            var l = t.coordinateSystem,
                u = s.get("position"),
                v = s.get("nameMap"),
                h = s.get("margin"),
                c = l.getFirstDayOfWeek();
            if (!v || q(v)) {
                v && (r = bu(v) || r);
                var f = r.get(["time", "dayOfWeekShort"]);
                v = f || G(r.get(["time", "dayOfWeekAbbr"]), function (_) {
                    return _[0]
                })
            }
            var p = l.getNextNDay(i.end.time, 7 - i.lweek).time,
                d = [l.getCellWidth(), l.getCellHeight()];
            h = H(h, Math.min(d[1], d[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
            for (var g = 0; g < 7; g++) {
                var y = l.getNextNDay(p, g),
                    x = l.dataToRect([y.time], !1).center,
                    m = g;
                m = Math.abs((g + c) % 7);
                var S = new ut({
                    z2: 30,
                    style: W(mt(s, {
                        text: v[m]
                    }), this._weekTextPositionControl(x, n, u, h, d))
                });
                o.add(S)
            }
        }
    }, e.type = "calendar", e
}(It);
const ZD = $D;
var Co = 864e5,
    UD = function () {
        function a(e, t, r) {
            this.type = "calendar", this.dimensions = a.dimensions, this.getDimensionsInfo = a.getDimensionsInfo, this._model = e
        }
        return a.getDimensionsInfo = function () {
            return [{
                name: "time",
                type: "time"
            }, "value"]
        }, a.prototype.getRangeInfo = function () {
            return this._rangeInfo
        }, a.prototype.getModel = function () {
            return this._model
        }, a.prototype.getRect = function () {
            return this._rect
        }, a.prototype.getCellWidth = function () {
            return this._sw
        }, a.prototype.getCellHeight = function () {
            return this._sh
        }, a.prototype.getOrient = function () {
            return this._orient
        }, a.prototype.getFirstDayOfWeek = function () {
            return this._firstDayOfWeek
        }, a.prototype.getDateInfo = function (e) {
            e = zm(e);
            var t = e.getFullYear(),
                r = e.getMonth() + 1,
                i = r < 10 ? "0" + r : "" + r,
                n = e.getDate(),
                o = n < 10 ? "0" + n : "" + n,
                s = e.getDay();
            return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
                y: t + "",
                m: i,
                d: o,
                day: s,
                time: e.getTime(),
                formatedDate: t + "-" + i + "-" + o,
                date: e
            }
        }, a.prototype.getNextNDay = function (e, t) {
            return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e))
        }, a.prototype.update = function (e, t) {
            this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
            var r = this._rangeInfo.weeks || 1,
                i = ["width", "height"],
                n = this._model.getCellSize().slice(),
                o = this._model.getBoxLayoutParams(),
                s = this._orient === "horizontal" ? [r, 7] : [7, r];
            T([0, 1], function (h) {
                v(n, h) && (o[i[h]] = n[h] * s[h])
            });
            var l = {
                    width: t.getWidth(),
                    height: t.getHeight()
                },
                u = this._rect = kt(o, l);
            T([0, 1], function (h) {
                v(n, h) || (n[h] = u[i[h]] / s[h])
            });

            function v(h, c) {
                return h[c] != null && h[c] !== "auto"
            }
            this._sw = n[0], this._sh = n[1]
        }, a.prototype.dataToPoint = function (e, t) {
            B(e) && (e = e[0]), t == null && (t = !0);
            var r = this.getDateInfo(e),
                i = this._rangeInfo,
                n = r.formatedDate;
            if (t && !(r.time >= i.start.time && r.time < i.end.time + Co)) return [NaN, NaN];
            var o = r.day,
                s = this._getRangeInfo([i.start.time, n]).nthWeek;
            return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2]
        }, a.prototype.pointToData = function (e) {
            var t = this.pointToDate(e);
            return t && t.time
        }, a.prototype.dataToRect = function (e, t) {
            var r = this.dataToPoint(e, t);
            return {
                contentShape: {
                    x: r[0] - (this._sw - this._lineWidth) / 2,
                    y: r[1] - (this._sh - this._lineWidth) / 2,
                    width: this._sw - this._lineWidth,
                    height: this._sh - this._lineWidth
                },
                center: r,
                tl: [r[0] - this._sw / 2, r[1] - this._sh / 2],
                tr: [r[0] + this._sw / 2, r[1] - this._sh / 2],
                br: [r[0] + this._sw / 2, r[1] + this._sh / 2],
                bl: [r[0] - this._sw / 2, r[1] + this._sh / 2]
            }
        }, a.prototype.pointToDate = function (e) {
            var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1,
                r = Math.floor((e[1] - this._rect.y) / this._sh) + 1,
                i = this._rangeInfo.range;
            return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, t - 1, i) : this._getDateByWeeksAndDay(t, r - 1, i)
        }, a.prototype.convertToPixel = function (e, t, r) {
            var i = vc(t);
            return i === this ? i.dataToPoint(r) : null
        }, a.prototype.convertFromPixel = function (e, t, r) {
            var i = vc(t);
            return i === this ? i.pointToData(r) : null
        }, a.prototype.containPoint = function (e) {
            return console.warn("Not implemented."), !1
        }, a.prototype._initRangeOption = function () {
            var e = this._model.get("range"),
                t;
            if (B(e) && e.length === 1 && (e = e[0]), B(e)) t = e;
            else {
                var r = e.toString();
                if (/^\d{4}$/.test(r) && (t = [r + "-01-01", r + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
                    var i = this.getDateInfo(r),
                        n = i.date;
                    n.setMonth(n.getMonth() + 1);
                    var o = this.getNextNDay(n, -1);
                    t = [i.formatedDate, o.formatedDate]
                }
                /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (t = [r, r])
            }
            if (!t) return e;
            var s = this._getRangeInfo(t);
            return s.start.time > s.end.time && t.reverse(), t
        }, a.prototype._getRangeInfo = function (e) {
            var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])],
                r;
            t[0].time > t[1].time && (r = !0, t.reverse());
            var i = Math.floor(t[1].time / Co) - Math.floor(t[0].time / Co) + 1,
                n = new Date(t[0].time),
                o = n.getDate(),
                s = t[1].date.getDate();
            n.setDate(o + i - 1);
            var l = n.getDate();
            if (l !== s)
                for (var u = n.getTime() - t[1].time > 0 ? 1 : -1;
                    (l = n.getDate()) !== s && (n.getTime() - t[1].time) * u > 0;) i -= u, n.setDate(l - u);
            var v = Math.floor((i + t[0].day + 6) / 7),
                h = r ? -v + 1 : v - 1;
            return r && t.reverse(), {
                range: [t[0].formatedDate, t[1].formatedDate],
                start: t[0],
                end: t[1],
                allDay: i,
                weeks: v,
                nthWeek: h,
                fweek: t[0].day,
                lweek: t[1].day
            }
        }, a.prototype._getDateByWeeksAndDay = function (e, t, r) {
            var i = this._getRangeInfo(r);
            if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek) return null;
            var n = (e - 1) * 7 - i.fweek + t,
                o = new Date(i.start.time);
            return o.setDate(+i.start.d + n), this.getDateInfo(o)
        }, a.create = function (e, t) {
            var r = [];
            return e.eachComponent("calendar", function (i) {
                var n = new a(i);
                r.push(n), i.coordinateSystem = n
            }), e.eachSeries(function (i) {
                i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0])
            }), r
        }, a.dimensions = ["time", "value"], a
    }();

function vc(a) {
    var e = a.calendarModel,
        t = a.seriesModel,
        r = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
    return r
}
const YD = UD;

function XD(a) {
    a.registerComponentModel(WD), a.registerComponentView(ZD), a.registerCoordinateSystem("calendar", YD)
}

function KD(a, e) {
    var t = a.existing;
    if (e.id = a.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
        var r = e.parentOption;
        r ? e.parentId = r.id : t && (e.parentId = t.parentId)
    }
    e.parentOption = null
}

function hc(a, e) {
    var t;
    return T(e, function (r) {
        a[r] != null && a[r] !== "auto" && (t = !0)
    }), t
}

function qD(a, e, t) {
    var r = W({}, t),
        i = a[e],
        n = t.$action || "merge";
    n === "merge" ? i ? (ct(i, r, !0), tn(i, r, {
        ignoreSize: !0
    }), Gm(t, i), ci(t, i), ci(t, i, "shape"), ci(t, i, "style"), ci(t, i, "extra"), t.clipPath = i.clipPath) : a[e] = r : n === "replace" ? a[e] = r : n === "remove" && i && (a[e] = null)
}
var Tg = ["transition", "enterFrom", "leaveTo"],
    jD = Tg.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);

function ci(a, e, t) {
    if (t && (!a[t] && e[t] && (a[t] = {}), a = a[t], e = e[t]), !(!a || !e))
        for (var r = t ? Tg : jD, i = 0; i < r.length; i++) {
            var n = r[i];
            a[n] == null && e[n] != null && (a[n] = e[n])
        }
}

function JD(a, e) {
    if (a && (a.hv = e.hv = [hc(e, ["left", "right"]), hc(e, ["top", "bottom"])], a.type === "group")) {
        var t = a,
            r = e;
        t.width == null && (t.width = r.width = 0), t.height == null && (t.height = r.height = 0)
    }
}
var QD = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.preventAutoZ = !0, t
        }
        return e.prototype.mergeOption = function (t, r) {
            var i = this.option.elements;
            this.option.elements = null, a.prototype.mergeOption.call(this, t, r), this.option.elements = i
        }, e.prototype.optionUpdated = function (t, r) {
            var i = this.option,
                n = (r ? i : t).elements,
                o = i.elements = r ? [] : i.elements,
                s = [];
            this._flatten(n, s, null);
            var l = Nm(o, s, "normalMerge"),
                u = this._elOptionsToUpdate = [];
            T(l, function (v, h) {
                var c = v.newOption;
                c && (u.push(c), KD(v, c), qD(o, h, c), JD(o[h], c))
            }, this), i.elements = Dt(o, function (v) {
                return v && delete v.$action, v != null
            })
        }, e.prototype._flatten = function (t, r, i) {
            T(t, function (n) {
                if (n) {
                    i && (n.parentOption = i), r.push(n);
                    var o = n.children;
                    o && o.length && this._flatten(o, r, n), delete n.children
                }
            }, this)
        }, e.prototype.useElOptionsToUpdate = function () {
            var t = this._elOptionsToUpdate;
            return this._elOptionsToUpdate = null, t
        }, e.type = "graphic", e.defaultOption = {
            elements: []
        }, e
    }(Ct),
    cc = {
        path: null,
        compoundPath: null,
        group: U,
        image: ge,
        text: ut
    },
    ie = xt(),
    tI = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function () {
            this._elMap = Q()
        }, e.prototype.render = function (t, r, i) {
            t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i)
        }, e.prototype._updateElements = function (t) {
            var r = t.useElOptionsToUpdate();
            if (r) {
                var i = this._elMap,
                    n = this.group,
                    o = t.get("z"),
                    s = t.get("zlevel");
                T(r, function (l) {
                    var u = Se(l.id, null),
                        v = u != null ? i.get(u) : null,
                        h = Se(l.parentId, null),
                        c = h != null ? i.get(h) : n,
                        f = l.type,
                        p = l.style;
                    f === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
                    var d = l.textContent,
                        g = l.textConfig;
                    if (p && ig(p, f, !!g, !!d)) {
                        var y = ng(p, f, !0);
                        !g && y.textConfig && (g = l.textConfig = y.textConfig), !d && y.textContent && (d = y.textContent)
                    }
                    var x = eI(l),
                        m = l.$action || "merge",
                        S = m === "merge",
                        _ = m === "replace";
                    if (S) {
                        var b = !v,
                            w = v;
                        b ? w = fc(u, c, l.type, i) : (w && (ie(w).isNew = !1), ug(w)), w && (_i(w, x, t, {
                            isInit: b
                        }), pc(w, l, o, s))
                    } else if (_) {
                        wi(v, l, i, t);
                        var A = fc(u, c, l.type, i);
                        A && (_i(A, x, t, {
                            isInit: !0
                        }), pc(A, l, o, s))
                    } else m === "remove" && (sg(v, l), wi(v, l, i, t));
                    var C = i.get(u);
                    if (C && d)
                        if (S) {
                            var D = C.getTextContent();
                            D ? D.attr(d) : C.setTextContent(new ut(d))
                        } else _ && C.setTextContent(new ut(d));
                    if (C) {
                        var I = l.clipPath;
                        if (I) {
                            var L = I.type,
                                M = void 0,
                                b = !1;
                            if (S) {
                                var P = C.getClipPath();
                                b = !P || ie(P).type !== L, M = b ? Ms(L) : P
                            } else _ && (b = !0, M = Ms(L));
                            C.setClipPath(M), _i(M, I, t, {
                                isInit: b
                            }), Ni(M, I.keyframeAnimation, t)
                        }
                        var R = ie(C);
                        C.setTextConfig(g), R.option = l, rI(C, t, l), sn({
                            el: C,
                            componentModel: t,
                            itemName: C.name,
                            itemTooltipOption: l.tooltip
                        }), Ni(C, l.keyframeAnimation, t)
                    }
                })
            }
        }, e.prototype._relocate = function (t, r) {
            for (var i = t.option.elements, n = this.group, o = this._elMap, s = r.getWidth(), l = r.getHeight(), u = ["x", "y"], v = 0; v < i.length; v++) {
                var h = i[v],
                    c = Se(h.id, null),
                    f = c != null ? o.get(c) : null;
                if (!(!f || !f.isGroup)) {
                    var p = f.parent,
                        d = p === n,
                        g = ie(f),
                        y = ie(p);
                    g.width = H(g.option.width, d ? s : y.width) || 0, g.height = H(g.option.height, d ? l : y.height) || 0
                }
            }
            for (var v = i.length - 1; v >= 0; v--) {
                var h = i[v],
                    c = Se(h.id, null),
                    f = c != null ? o.get(c) : null;
                if (f) {
                    var p = f.parent,
                        y = ie(p),
                        x = p === n ? {
                            width: s,
                            height: l
                        } : {
                            width: y.width,
                            height: y.height
                        },
                        m = {},
                        S = hn(f, h, x, null, {
                            hv: h.hv,
                            boundingMode: h.bounding
                        }, m);
                    if (!ie(f).isNew && S) {
                        for (var _ = h.transition, b = {}, w = 0; w < u.length; w++) {
                            var A = u[w],
                                C = m[A];
                            _ && (ur(_) || ft(_, A) >= 0) ? b[A] = C : f[A] = C
                        }
                        yt(f, b, t, 0)
                    } else f.attr(m)
                }
            }
        }, e.prototype._clear = function () {
            var t = this,
                r = this._elMap;
            r.each(function (i) {
                wi(i, ie(i).option, r, t._lastGraphicModel)
            }), this._elMap = Q()
        }, e.prototype.dispose = function () {
            this._clear()
        }, e.type = "graphic", e
    }(It);

function Ms(a) {
    var e = N(cc, a) ? cc[a] : lp(a),
        t = new e({});
    return ie(t).type = a, t
}

function fc(a, e, t, r) {
    var i = Ms(t);
    return e.add(i), r.set(a, i), ie(i).id = a, ie(i).isNew = !0, i
}

function wi(a, e, t, r) {
    var i = a && a.parent;
    i && (a.type === "group" && a.traverse(function (n) {
        wi(n, e, t, r)
    }), bn(a, e, r), t.removeKey(ie(a).id))
}

function pc(a, e, t, r) {
    a.isGroup || T([
        ["cursor", hr.prototype.cursor],
        ["zlevel", r || 0],
        ["z", t || 0],
        ["z2", 0]
    ], function (i) {
        var n = i[0];
        N(e, n) ? a[n] = Lt(e[n], i[1]) : a[n] == null && (a[n] = i[1])
    }), T(wt(e), function (i) {
        if (i.indexOf("on") === 0) {
            var n = e[i];
            a[i] = rt(n) ? n : null
        }
    }), N(e, "draggable") && (a.draggable = e.draggable), e.name != null && (a.name = e.name), e.id != null && (a.id = e.id)
}

function eI(a) {
    return a = W({}, a), T(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(Bm), function (e) {
        delete a[e]
    }), a
}

function rI(a, e, t) {
    var r = tt(a).eventData;
    !a.silent && !a.ignore && !r && (r = tt(a).eventData = {
        componentType: "graphic",
        componentIndex: e.componentIndex,
        name: a.name
    }), r && (r.info = t.info)
}

function aI(a) {
    a.registerComponentModel(QD), a.registerComponentView(tI), a.registerPreprocessor(function (e) {
        var t = e.graphic;
        B(t) ? !t[0] || !t[0].elements ? e.graphic = [{
            elements: t
        }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{
            elements: [t]
        }])
    })
}
var dc = ["x", "y", "radius", "angle", "single"],
    iI = ["cartesian2d", "polar", "singleAxis"];

function nI(a) {
    var e = a.get("coordinateSystem");
    return ft(iI, e) >= 0
}

function ke(a) {
    return a + "Axis"
}

function oI(a, e) {
    var t = Q(),
        r = [],
        i = Q();
    a.eachComponent({
        mainType: "dataZoom",
        query: e
    }, function (v) {
        i.get(v.uid) || s(v)
    });
    var n;
    do n = !1, a.eachComponent("dataZoom", o); while (n);

    function o(v) {
        !i.get(v.uid) && l(v) && (s(v), n = !0)
    }

    function s(v) {
        i.set(v.uid, !0), r.push(v), u(v)
    }

    function l(v) {
        var h = !1;
        return v.eachTargetAxis(function (c, f) {
            var p = t.get(c);
            p && p[f] && (h = !0)
        }), h
    }

    function u(v) {
        v.eachTargetAxis(function (h, c) {
            (t.get(h) || t.set(h, []))[c] = !0
        })
    }
    return r
}

function Cg(a) {
    var e = a.ecModel,
        t = {
            infoList: [],
            infoMap: Q()
        };
    return a.eachTargetAxis(function (r, i) {
        var n = e.getComponent(ke(r), i);
        if (n) {
            var o = n.getCoordSysModel();
            if (o) {
                var s = o.uid,
                    l = t.infoMap.get(s);
                l || (l = {
                    model: o,
                    axisModels: []
                }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(n)
            }
        }
    }), t
}
var Do = function () {
        function a() {
            this.indexList = [], this.indexMap = []
        }
        return a.prototype.add = function (e) {
            this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0)
        }, a
    }(),
    Va = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t
        }
        return e.prototype.init = function (t, r, i) {
            var n = gc(t);
            this.settledOption = n, this.mergeDefaultAndTheme(t, i), this._doInit(n)
        }, e.prototype.mergeOption = function (t) {
            var r = gc(t);
            ct(this.option, t, !0), ct(this.settledOption, r, !0), this._doInit(r)
        }, e.prototype._doInit = function (t) {
            var r = this.option;
            this._setDefaultThrottle(t), this._updateRangeUse(t);
            var i = this.settledOption;
            T([
                ["start", "startValue"],
                ["end", "endValue"]
            ], function (n, o) {
                this._rangePropMode[o] === "value" && (r[n[0]] = i[n[0]] = null)
            }, this), this._resetTarget()
        }, e.prototype._resetTarget = function () {
            var t = this.get("orient", !0),
                r = this._targetAxisInfoMap = Q(),
                i = this._fillSpecifiedTargetAxis(r);
            i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = !0, r.each(function (n) {
                n.indexList.length && (this._noTarget = !1)
            }, this)
        }, e.prototype._fillSpecifiedTargetAxis = function (t) {
            var r = !1;
            return T(dc, function (i) {
                var n = this.getReferringComponents(ke(i), Hm);
                if (n.specified) {
                    r = !0;
                    var o = new Do;
                    T(n.models, function (s) {
                        o.add(s.componentIndex)
                    }), t.set(i, o)
                }
            }, this), r
        }, e.prototype._fillAutoTargetAxisByOrient = function (t, r) {
            var i = this.ecModel,
                n = !0;
            if (n) {
                var o = r === "vertical" ? "y" : "x",
                    s = i.findComponents({
                        mainType: o + "Axis"
                    });
                l(s, o)
            }
            if (n) {
                var s = i.findComponents({
                    mainType: "singleAxis",
                    filter: function (v) {
                        return v.get("orient", !0) === r
                    }
                });
                l(s, "single")
            }

            function l(u, v) {
                var h = u[0];
                if (h) {
                    var c = new Do;
                    if (c.add(h.componentIndex), t.set(v, c), n = !1, v === "x" || v === "y") {
                        var f = h.getReferringComponents("grid", Kt).models[0];
                        f && T(u, function (p) {
                            h.componentIndex !== p.componentIndex && f === p.getReferringComponents("grid", Kt).models[0] && c.add(p.componentIndex)
                        })
                    }
                }
            }
            n && T(dc, function (u) {
                if (n) {
                    var v = i.findComponents({
                        mainType: ke(u),
                        filter: function (c) {
                            return c.get("type", !0) === "category"
                        }
                    });
                    if (v[0]) {
                        var h = new Do;
                        h.add(v[0].componentIndex), t.set(u, h), n = !1
                    }
                }
            }, this)
        }, e.prototype._makeAutoOrientByTargetAxis = function () {
            var t;
            return this.eachTargetAxis(function (r) {
                !t && (t = r)
            }, this), t === "y" ? "vertical" : "horizontal"
        }, e.prototype._setDefaultThrottle = function (t) {
            if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                var r = this.ecModel.option;
                this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20
            }
        }, e.prototype._updateRangeUse = function (t) {
            var r = this._rangePropMode,
                i = this.get("rangeMode");
            T([
                ["start", "startValue"],
                ["end", "endValue"]
            ], function (n, o) {
                var s = t[n[0]] != null,
                    l = t[n[1]] != null;
                s && !l ? r[o] = "percent" : !s && l ? r[o] = "value" : i ? r[o] = i[o] : s && (r[o] = "percent")
            })
        }, e.prototype.noTarget = function () {
            return this._noTarget
        }, e.prototype.getFirstTargetAxisModel = function () {
            var t;
            return this.eachTargetAxis(function (r, i) {
                t == null && (t = this.ecModel.getComponent(ke(r), i))
            }, this), t
        }, e.prototype.eachTargetAxis = function (t, r) {
            this._targetAxisInfoMap.each(function (i, n) {
                T(i.indexList, function (o) {
                    t.call(r, n, o)
                })
            })
        }, e.prototype.getAxisProxy = function (t, r) {
            var i = this.getAxisModel(t, r);
            if (i) return i.__dzAxisProxy
        }, e.prototype.getAxisModel = function (t, r) {
            var i = this._targetAxisInfoMap.get(t);
            if (i && i.indexMap[r]) return this.ecModel.getComponent(ke(t), r)
        }, e.prototype.setRawRange = function (t) {
            var r = this.option,
                i = this.settledOption;
            T([
                ["start", "startValue"],
                ["end", "endValue"]
            ], function (n) {
                (t[n[0]] != null || t[n[1]] != null) && (r[n[0]] = i[n[0]] = t[n[0]], r[n[1]] = i[n[1]] = t[n[1]])
            }, this), this._updateRangeUse(t)
        }, e.prototype.setCalculatedRange = function (t) {
            var r = this.option;
            T(["start", "startValue", "end", "endValue"], function (i) {
                r[i] = t[i]
            })
        }, e.prototype.getPercentRange = function () {
            var t = this.findRepresentativeAxisProxy();
            if (t) return t.getDataPercentWindow()
        }, e.prototype.getValueRange = function (t, r) {
            if (t == null && r == null) {
                var i = this.findRepresentativeAxisProxy();
                if (i) return i.getDataValueWindow()
            } else return this.getAxisProxy(t, r).getDataValueWindow()
        }, e.prototype.findRepresentativeAxisProxy = function (t) {
            if (t) return t.__dzAxisProxy;
            for (var r, i = this._targetAxisInfoMap.keys(), n = 0; n < i.length; n++)
                for (var o = i[n], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
                    var u = this.getAxisProxy(o, s.indexList[l]);
                    if (u.hostedBy(this)) return u;
                    r || (r = u)
                }
            return r
        }, e.prototype.getRangePropMode = function () {
            return this._rangePropMode.slice()
        }, e.prototype.getOrient = function () {
            return this._orient
        }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
            z: 4,
            filterMode: "filter",
            start: 0,
            end: 100
        }, e
    }(Ct);

function gc(a) {
    var e = {};
    return T(["start", "end", "startValue", "endValue", "throttle"], function (t) {
        a.hasOwnProperty(t) && (e[t] = a[t])
    }), e
}
var sI = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "dataZoom.select", e
}(Va);
const lI = sI;
var uI = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.render = function (t, r, i, n) {
        this.dataZoomModel = t, this.ecModel = r, this.api = i
    }, e.type = "dataZoom", e
}(It);
const Ul = uI;
var vI = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "dataZoom.select", e
}(Ul);
const hI = vI;
var Pr = T,
    yc = oe,
    cI = function () {
        function a(e, t, r, i) {
            this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = r
        }
        return a.prototype.hostedBy = function (e) {
            return this._dataZoomModel === e
        }, a.prototype.getDataValueWindow = function () {
            return this._valueWindow.slice()
        }, a.prototype.getDataPercentWindow = function () {
            return this._percentWindow.slice()
        }, a.prototype.getTargetSeriesModels = function () {
            var e = [];
            return this.ecModel.eachSeries(function (t) {
                if (nI(t)) {
                    var r = ke(this._dimName),
                        i = t.getReferringComponents(r, Kt).models[0];
                    i && this._axisIndex === i.componentIndex && e.push(t)
                }
            }, this), e
        }, a.prototype.getAxisModel = function () {
            return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
        }, a.prototype.getMinMaxSpan = function () {
            return ot(this._minMaxSpan)
        }, a.prototype.calculateDataWindow = function (e) {
            var t = this._dataExtent,
                r = this.getAxisModel(),
                i = r.axis.scale,
                n = this._dataZoomModel.getRangePropMode(),
                o = [0, 100],
                s = [],
                l = [],
                u;
            Pr(["start", "end"], function (c, f) {
                var p = e[c],
                    d = e[c + "Value"];
                n[f] === "percent" ? (p == null && (p = o[f]), d = i.parse(ht(p, o, t))) : (u = !0, d = d == null ? t[f] : i.parse(d), p = ht(d, t, o)), l[f] = d == null || isNaN(d) ? t[f] : d, s[f] = p == null || isNaN(p) ? o[f] : p
            }), yc(l), yc(s);
            var v = this._minMaxSpan;
            u ? h(l, s, t, o, !1) : h(s, l, o, t, !0);

            function h(c, f, p, d, g) {
                var y = g ? "Span" : "ValueSpan";
                Sr(0, c, p, "all", v["min" + y], v["max" + y]);
                for (var x = 0; x < 2; x++) f[x] = ht(c[x], p, d, !0), g && (f[x] = i.parse(f[x]))
            }
            return {
                valueWindow: l,
                percentWindow: s
            }
        }, a.prototype.reset = function (e) {
            if (e === this._dataZoomModel) {
                var t = this.getTargetSeriesModels();
                this._dataExtent = fI(this, this._dimName, t), this._updateMinMaxSpan();
                var r = this.calculateDataWindow(e.settledOption);
                this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel()
            }
        }, a.prototype.filterData = function (e, t) {
            if (e !== this._dataZoomModel) return;
            var r = this._dimName,
                i = this.getTargetSeriesModels(),
                n = e.get("filterMode"),
                o = this._valueWindow;
            if (n === "none") return;
            Pr(i, function (l) {
                var u = l.getData(),
                    v = u.mapDimensionsAll(r);
                if (v.length) {
                    if (n === "weakFilter") {
                        var h = u.getStore(),
                            c = G(v, function (f) {
                                return u.getDimensionIndex(f)
                            }, u);
                        u.filterSelf(function (f) {
                            for (var p, d, g, y = 0; y < v.length; y++) {
                                var x = h.get(c[y], f),
                                    m = !isNaN(x),
                                    S = x < o[0],
                                    _ = x > o[1];
                                if (m && !S && !_) return !0;
                                m && (g = !0), S && (p = !0), _ && (d = !0)
                            }
                            return g && p && d
                        })
                    } else Pr(v, function (f) {
                        if (n === "empty") l.setData(u = u.map(f, function (d) {
                            return s(d) ? d : NaN
                        }));
                        else {
                            var p = {};
                            p[f] = o, u.selectRange(p)
                        }
                    });
                    Pr(v, function (f) {
                        u.setApproximateExtent(o, f)
                    })
                }
            });

            function s(l) {
                return l >= o[0] && l <= o[1]
            }
        }, a.prototype._updateMinMaxSpan = function () {
            var e = this._minMaxSpan = {},
                t = this._dataZoomModel,
                r = this._dataExtent;
            Pr(["min", "max"], function (i) {
                var n = t.get(i + "Span"),
                    o = t.get(i + "ValueSpan");
                o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? n = ht(r[0] + o, r, [0, 100], !0) : n != null && (o = ht(n, [0, 100], r, !0) - r[0]), e[i + "Span"] = n, e[i + "ValueSpan"] = o
            }, this)
        }, a.prototype._setAxisModel = function () {
            var e = this.getAxisModel(),
                t = this._percentWindow,
                r = this._valueWindow;
            if (t) {
                var i = Fm(r, [0, 500]);
                i = Math.min(i, 20);
                var n = e.axis.scale.rawExtentInfo;
                t[0] !== 0 && n.setDeterminedMinMax("min", +r[0].toFixed(i)), t[1] !== 100 && n.setDeterminedMinMax("max", +r[1].toFixed(i)), n.freeze()
            }
        }, a
    }();

function fI(a, e, t) {
    var r = [1 / 0, -1 / 0];
    Pr(t, function (o) {
        Wm(r, o.getData(), e)
    });
    var i = a.getAxisModel(),
        n = $m(i.axis.scale, i, r).calculate();
    return [n.min, n.max]
}
var pI = {
    getTargetSeries: function (a) {
        function e(i) {
            a.eachComponent("dataZoom", function (n) {
                n.eachTargetAxis(function (o, s) {
                    var l = a.getComponent(ke(o), s);
                    i(o, s, l, n)
                })
            })
        }
        e(function (i, n, o, s) {
            o.__dzAxisProxy = null
        });
        var t = [];
        e(function (i, n, o, s) {
            o.__dzAxisProxy || (o.__dzAxisProxy = new cI(i, n, s, a), t.push(o.__dzAxisProxy))
        });
        var r = Q();
        return T(t, function (i) {
            T(i.getTargetSeriesModels(), function (n) {
                r.set(n.uid, n)
            })
        }), r
    },
    overallReset: function (a, e) {
        a.eachComponent("dataZoom", function (t) {
            t.eachTargetAxis(function (r, i) {
                t.getAxisProxy(r, i).reset(t)
            }), t.eachTargetAxis(function (r, i) {
                t.getAxisProxy(r, i).filterData(t, e)
            })
        }), a.eachComponent("dataZoom", function (t) {
            var r = t.findRepresentativeAxisProxy();
            if (r) {
                var i = r.getDataPercentWindow(),
                    n = r.getDataValueWindow();
                t.setCalculatedRange({
                    start: i[0],
                    end: i[1],
                    startValue: n[0],
                    endValue: n[1]
                })
            }
        })
    }
};
const dI = pI;

function gI(a) {
    a.registerAction("dataZoom", function (e, t) {
        var r = oI(t, e);
        T(r, function (i) {
            i.setRawRange({
                start: e.start,
                end: e.end,
                startValue: e.startValue,
                endValue: e.endValue
            })
        })
    })
}
var mc = !1;

function Yl(a) {
    mc || (mc = !0, a.registerProcessor(a.PRIORITY.PROCESSOR.FILTER, dI), gI(a), a.registerSubTypeDefaulter("dataZoom", function () {
        return "slider"
    }))
}

function yI(a) {
    a.registerComponentModel(lI), a.registerComponentView(hI), Yl(a)
}
var ne = function () {
        function a() {}
        return a
    }(),
    Dg = {};

function Rr(a, e) {
    Dg[a] = e
}

function Ig(a) {
    return Dg[a]
}
var mI = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.optionUpdated = function () {
        a.prototype.optionUpdated.apply(this, arguments);
        var t = this.ecModel;
        T(this.option.feature, function (r, i) {
            var n = Ig(i);
            n && (n.getDefaultOption && (n.defaultOption = n.getDefaultOption(t)), ct(r, n.defaultOption))
        })
    }, e.type = "toolbox", e.layoutMode = {
        type: "box",
        ignoreSize: !0
    }, e.defaultOption = {
        show: !0,
        z: 6,
        orient: "horizontal",
        left: "right",
        top: "top",
        backgroundColor: "transparent",
        borderColor: "#ccc",
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemSize: 15,
        itemGap: 8,
        showTitle: !0,
        iconStyle: {
            borderColor: "#666",
            color: "none"
        },
        emphasis: {
            iconStyle: {
                borderColor: "#3E98C5"
            }
        },
        tooltip: {
            show: !1,
            position: "bottom"
        }
    }, e
}(Ct);
const xI = mI;

function SI(a, e, t) {
    var r = e.getBoxLayoutParams(),
        i = e.get("padding"),
        n = {
            width: t.getWidth(),
            height: t.getHeight()
        },
        o = kt(r, n, i);
    sr(e.get("orient"), a, e.get("itemGap"), o.width, o.height), hn(a, r, n, i)
}

function Lg(a, e) {
    var t = pn(e.get("padding")),
        r = e.getItemStyle(["color", "opacity"]);
    return r.fill = e.get("backgroundColor"), a = new pt({
        shape: {
            x: a.x - t[3],
            y: a.y - t[0],
            width: a.width + t[1] + t[3],
            height: a.height + t[0] + t[2],
            r: e.get("borderRadius")
        },
        style: r,
        silent: !0,
        z2: -1
    }), a
}
var _I = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.render = function (t, r, i, n) {
        var o = this.group;
        if (o.removeAll(), !t.get("show")) return;
        var s = +t.get("itemSize"),
            l = t.get("orient") === "vertical",
            u = t.get("feature") || {},
            v = this._features || (this._features = {}),
            h = [];
        T(u, function (p, d) {
            h.push(d)
        }), new Be(this._featureNames || [], h).add(c).update(c).remove(K(c, null)).execute(), this._featureNames = h;

        function c(p, d) {
            var g = h[p],
                y = h[d],
                x = u[g],
                m = new Rt(x, t, t.ecModel),
                S;
            if (n && n.newTitle != null && n.featureName === g && (x.title = n.newTitle), g && !y) {
                if (bI(g)) S = {
                    onclick: m.option.onclick,
                    featureName: g
                };
                else {
                    var _ = Ig(g);
                    if (!_) return;
                    S = new _
                }
                v[g] = S
            } else if (S = v[y], !S) return;
            S.uid = jf("toolbox-feature"), S.model = m, S.ecModel = r, S.api = i;
            var b = S instanceof ne;
            if (!g && y) {
                b && S.dispose && S.dispose(r, i);
                return
            }
            if (!m.get("show") || b && S.unusable) {
                b && S.remove && S.remove(r, i);
                return
            }
            f(m, S, g), m.setIconStatus = function (w, A) {
                var C = this.option,
                    D = this.iconPaths;
                C.iconStatus = C.iconStatus || {}, C.iconStatus[w] = A, D[w] && (A === "emphasis" ? Br : Hr)(D[w])
            }, S instanceof ne && S.render && S.render(m, r, i, n)
        }

        function f(p, d, g) {
            var y = p.getModel("iconStyle"),
                x = p.getModel(["emphasis", "iconStyle"]),
                m = d instanceof ne && d.getIcons ? d.getIcons() : p.get("icon"),
                S = p.get("title") || {},
                _, b;
            q(m) ? (_ = {}, _[g] = m) : _ = m, q(S) ? (b = {}, b[g] = S) : b = S;
            var w = p.iconPaths = {};
            T(_, function (A, C) {
                var D = fn(A, {}, {
                    x: -s / 2,
                    y: -s / 2,
                    width: s,
                    height: s
                });
                D.setStyle(y.getItemStyle());
                var I = D.ensureState("emphasis");
                I.style = x.getItemStyle();
                var L = new ut({
                    style: {
                        text: b[C],
                        align: x.get("textAlign"),
                        borderRadius: x.get("textBorderRadius"),
                        padding: x.get("textPadding"),
                        fill: null,
                        font: sp({
                            fontStyle: x.get("textFontStyle"),
                            fontFamily: x.get("textFontFamily"),
                            fontSize: x.get("textFontSize"),
                            fontWeight: x.get("textFontWeight")
                        }, r)
                    },
                    ignore: !0
                });
                D.setTextContent(L), sn({
                    el: D,
                    componentModel: t,
                    itemName: C,
                    formatterParamsExtra: {
                        title: b[C]
                    }
                }), D.__title = b[C], D.on("mouseover", function () {
                    var M = x.getItemStyle(),
                        P = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
                    L.setStyle({
                        fill: x.get("textFill") || M.fill || M.stroke || "#000",
                        backgroundColor: x.get("textBackgroundColor")
                    }), D.setTextConfig({
                        position: x.get("textPosition") || P
                    }), L.ignore = !t.get("showTitle"), i.enterEmphasis(this)
                }).on("mouseout", function () {
                    p.get(["iconStatus", C]) !== "emphasis" && i.leaveEmphasis(this), L.hide()
                }), (p.get(["iconStatus", C]) === "emphasis" ? Br : Hr)(D), o.add(D), D.on("click", F(d.onclick, d, r, i, C)), w[C] = D
            })
        }
        SI(o, t, i), o.add(Lg(o.getBoundingRect(), t)), l || o.eachChild(function (p) {
            var d = p.__title,
                g = p.ensureState("emphasis"),
                y = g.textConfig || (g.textConfig = {}),
                x = p.getTextContent(),
                m = x && x.ensureState("emphasis");
            if (m && !rt(m) && d) {
                var S = m.style || (m.style = {}),
                    _ = el(d, ut.makeFont(S)),
                    b = p.x + o.x,
                    w = p.y + o.y + s,
                    A = !1;
                w + _.height > i.getHeight() && (y.position = "top", A = !0);
                var C = A ? -5 - _.height : s + 10;
                b + _.width / 2 > i.getWidth() ? (y.position = ["100%", C], S.align = "right") : b - _.width / 2 < 0 && (y.position = [0, C], S.align = "left")
            }
        })
    }, e.prototype.updateView = function (t, r, i, n) {
        T(this._features, function (o) {
            o instanceof ne && o.updateView && o.updateView(o.model, r, i, n)
        })
    }, e.prototype.remove = function (t, r) {
        T(this._features, function (i) {
            i instanceof ne && i.remove && i.remove(t, r)
        }), this.group.removeAll()
    }, e.prototype.dispose = function (t, r) {
        T(this._features, function (i) {
            i instanceof ne && i.dispose && i.dispose(t, r)
        })
    }, e.type = "toolbox", e
}(It);

function bI(a) {
    return a.indexOf("my") === 0
}
const wI = _I;
var AI = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.onclick = function (t, r) {
        var i = this.model,
            n = i.get("name") || t.get("title.0.text") || "echarts",
            o = r.getZr().painter.getType() === "svg",
            s = o ? "svg" : i.get("type", !0) || "png",
            l = r.getConnectedDataURL({
                type: s,
                backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
                connectedBackgroundColor: i.get("connectedBackgroundColor"),
                excludeComponents: i.get("excludeComponents"),
                pixelRatio: i.get("pixelRatio")
            }),
            u = Nt.browser;
        if (rt(MouseEvent) && (u.newEdge || !u.ie && !u.edge)) {
            var v = document.createElement("a");
            v.download = n + "." + s, v.target = "_blank", v.href = l;
            var h = new MouseEvent("click", {
                view: document.defaultView,
                bubbles: !0,
                cancelable: !1
            });
            v.dispatchEvent(h)
        } else if (window.navigator.msSaveOrOpenBlob || o) {
            var c = l.split(","),
                f = c[0].indexOf("base64") > -1,
                p = o ? decodeURIComponent(c[1]) : c[1];
            f && (p = window.atob(p));
            var d = n + "." + s;
            if (window.navigator.msSaveOrOpenBlob) {
                for (var g = p.length, y = new Uint8Array(g); g--;) y[g] = p.charCodeAt(g);
                var x = new Blob([y]);
                window.navigator.msSaveOrOpenBlob(x, d)
            } else {
                var m = document.createElement("iframe");
                document.body.appendChild(m);
                var S = m.contentWindow,
                    _ = S.document;
                _.open("image/svg+xml", "replace"), _.write(p), _.close(), S.focus(), _.execCommand("SaveAs", !0, d), document.body.removeChild(m)
            }
        } else {
            var b = i.get("lang"),
                w = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (b && b[0] || "") + '" /></body>',
                A = window.open();
            A.document.write(w), A.document.title = n
        }
    }, e.getDefaultOption = function (t) {
        var r = {
            show: !0,
            icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
            title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
            type: "png",
            connectedBackgroundColor: "#fff",
            name: "",
            excludeComponents: ["toolbox"],
            lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
        };
        return r
    }, e
}(ne);
const TI = AI;
var xc = "__ec_magicType_stack__",
    CI = [
        ["line", "bar"],
        ["stack"]
    ],
    DI = function (a) {
        E(e, a);

        function e() {
            return a !== null && a.apply(this, arguments) || this
        }
        return e.prototype.getIcons = function () {
            var t = this.model,
                r = t.get("icon"),
                i = {};
            return T(t.get("type"), function (n) {
                r[n] && (i[n] = r[n])
            }), i
        }, e.getDefaultOption = function (t) {
            var r = {
                show: !0,
                type: [],
                icon: {
                    line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
                    bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
                    stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
                },
                title: t.getLocaleModel().get(["toolbox", "magicType", "title"]),
                option: {},
                seriesIndex: {}
            };
            return r
        }, e.prototype.onclick = function (t, r, i) {
            var n = this.model,
                o = n.get(["seriesIndex", i]);
            if (Sc[i]) {
                var s = {
                        series: []
                    },
                    l = function (h) {
                        var c = h.subType,
                            f = h.id,
                            p = Sc[i](c, f, h, n);
                        p && (at(p, h.option), s.series.push(p));
                        var d = h.coordinateSystem;
                        if (d && d.type === "cartesian2d" && (i === "line" || i === "bar")) {
                            var g = d.getAxesByScale("ordinal")[0];
                            if (g) {
                                var y = g.dim,
                                    x = y + "Axis",
                                    m = h.getReferringComponents(x, Kt).models[0],
                                    S = m.componentIndex;
                                s[x] = s[x] || [];
                                for (var _ = 0; _ <= S; _++) s[x][S] = s[x][S] || {};
                                s[x][S].boundaryGap = i === "bar"
                            }
                        }
                    };
                T(CI, function (h) {
                    ft(h, i) >= 0 && T(h, function (c) {
                        n.setIconStatus(c, "normal")
                    })
                }), n.setIconStatus(i, "emphasis"), t.eachComponent({
                    mainType: "series",
                    query: o == null ? null : {
                        seriesIndex: o
                    }
                }, l);
                var u, v = i;
                i === "stack" && (u = ct({
                    stack: n.option.title.tiled,
                    tiled: n.option.title.stack
                }, n.option.title), n.get(["iconStatus", i]) !== "emphasis" && (v = "tiled")), r.dispatchAction({
                    type: "changeMagicType",
                    currentType: v,
                    newOption: s,
                    newTitle: u,
                    featureName: "magicType"
                })
            }
        }, e
    }(ne),
    Sc = {
        line: function (a, e, t, r) {
            if (a === "bar") return ct({
                id: e,
                type: "line",
                data: t.get("data"),
                stack: t.get("stack"),
                markPoint: t.get("markPoint"),
                markLine: t.get("markLine")
            }, r.get(["option", "line"]) || {}, !0)
        },
        bar: function (a, e, t, r) {
            if (a === "line") return ct({
                id: e,
                type: "bar",
                data: t.get("data"),
                stack: t.get("stack"),
                markPoint: t.get("markPoint"),
                markLine: t.get("markLine")
            }, r.get(["option", "bar"]) || {}, !0)
        },
        stack: function (a, e, t, r) {
            var i = t.get("stack") === xc;
            if (a === "line" || a === "bar") return r.setIconStatus("stack", i ? "normal" : "emphasis"), ct({
                id: e,
                stack: i ? "" : xc
            }, r.get(["option", "stack"]) || {}, !0)
        }
    };
an({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
}, function (a, e) {
    e.mergeOption(a.newOption)
});
const II = DI;
var wn = new Array(60).join("-"),
    qr = "	";

function LI(a) {
    var e = {},
        t = [],
        r = [];
    return a.eachRawSeries(function (i) {
        var n = i.coordinateSystem;
        if (n && (n.type === "cartesian2d" || n.type === "polar")) {
            var o = n.getBaseAxis();
            if (o.type === "category") {
                var s = o.dim + "_" + o.index;
                e[s] || (e[s] = {
                    categoryAxis: o,
                    valueAxis: n.getOtherAxis(o),
                    series: []
                }, r.push({
                    axisDim: o.dim,
                    axisIndex: o.index
                })), e[s].series.push(i)
            } else t.push(i)
        } else t.push(i)
    }), {
        seriesGroupByCategoryAxis: e,
        other: t,
        meta: r
    }
}

function MI(a) {
    var e = [];
    return T(a, function (t, r) {
        var i = t.categoryAxis,
            n = t.valueAxis,
            o = n.dim,
            s = [" "].concat(G(t.series, function (f) {
                return f.name
            })),
            l = [i.model.getCategories()];
        T(t.series, function (f) {
            var p = f.getRawData();
            l.push(f.getRawData().mapArray(p.mapDimension(o), function (d) {
                return d
            }))
        });
        for (var u = [s.join(qr)], v = 0; v < l[0].length; v++) {
            for (var h = [], c = 0; c < l.length; c++) h.push(l[c][v]);
            u.push(h.join(qr))
        }
        e.push(u.join(`
`))
    }), e.join(`

` + wn + `

`)
}

function PI(a) {
    return G(a, function (e) {
        var t = e.getRawData(),
            r = [e.name],
            i = [];
        return t.each(t.dimensions, function () {
            for (var n = arguments.length, o = arguments[n - 1], s = t.getName(o), l = 0; l < n - 1; l++) i[l] = arguments[l];
            r.push((s ? s + qr : "") + i.join(qr))
        }), r.join(`
`)
    }).join(`

` + wn + `

`)
}

function RI(a) {
    var e = LI(a);
    return {
        value: Dt([MI(e.seriesGroupByCategoryAxis), PI(e.other)], function (t) {
            return !!t.replace(/[\n\t\s]/g, "")
        }).join(`

` + wn + `

`),
        meta: e.meta
    }
}

function Hi(a) {
    return a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
}

function EI(a) {
    var e = a.slice(0, a.indexOf(`
`));
    if (e.indexOf(qr) >= 0) return !0
}
var Ps = new RegExp("[" + qr + "]+", "g");

function kI(a) {
    for (var e = a.split(/\n+/g), t = Hi(e.shift()).split(Ps), r = [], i = G(t, function (l) {
            return {
                name: l,
                data: []
            }
        }), n = 0; n < e.length; n++) {
        var o = Hi(e[n]).split(Ps);
        r.push(o.shift());
        for (var s = 0; s < o.length; s++) i[s] && (i[s].data[n] = o[s])
    }
    return {
        series: i,
        categories: r
    }
}

function VI(a) {
    for (var e = a.split(/\n+/g), t = Hi(e.shift()), r = [], i = 0; i < e.length; i++) {
        var n = Hi(e[i]);
        if (n) {
            var o = n.split(Ps),
                s = "",
                l = void 0,
                u = !1;
            isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), r[i] = {
                name: s,
                value: []
            }, l = r[i].value) : l = r[i] = [];
            for (var v = 0; v < o.length; v++) l.push(+o[v]);
            l.length === 1 && (u ? r[i].value = l[0] : r[i] = l[0])
        }
    }
    return {
        name: t,
        data: r
    }
}

function OI(a, e) {
    var t = a.split(new RegExp(`
*` + wn + `
*`, "g")),
        r = {
            series: []
        };
    return T(t, function (i, n) {
        if (EI(i)) {
            var o = kI(i),
                s = e[n],
                l = s.axisDim + "Axis";
            s && (r[l] = r[l] || [], r[l][s.axisIndex] = {
                data: o.categories
            }, r.series = r.series.concat(o.series))
        } else {
            var o = VI(i);
            r.series.push(o)
        }
    }), r
}
var zI = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.onclick = function (t, r) {
        setTimeout(function () {
            r.dispatchAction({
                type: "hideTip"
            })
        });
        var i = r.getDom(),
            n = this.model;
        this._dom && i.removeChild(this._dom);
        var o = document.createElement("div");
        o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = n.get("backgroundColor") || "#fff";
        var s = document.createElement("h4"),
            l = n.get("lang") || [];
        s.innerHTML = l[0] || n.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = n.get("textColor");
        var u = document.createElement("div"),
            v = document.createElement("textarea");
        u.style.cssText = "overflow:auto";
        var h = n.get("optionToContent"),
            c = n.get("contentToOption"),
            f = RI(t);
        if (rt(h)) {
            var p = h(r.getOption());
            q(p) ? u.innerHTML = p : es(p) && u.appendChild(p)
        } else {
            v.readOnly = n.get("readOnly");
            var d = v.style;
            d.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", d.color = n.get("textColor"), d.borderColor = n.get("textareaBorderColor"), d.backgroundColor = n.get("textareaColor"), v.value = f.value, u.appendChild(v)
        }
        var g = f.meta,
            y = document.createElement("div");
        y.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
        var x = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
            m = document.createElement("div"),
            S = document.createElement("div");
        x += ";background-color:" + n.get("buttonColor"), x += ";color:" + n.get("buttonTextColor");
        var _ = this;

        function b() {
            i.removeChild(o), _._dom = null
        }
        wu(m, "click", b), wu(S, "click", function () {
            if (c == null && h != null || c != null && h == null) {
                b();
                return
            }
            var w;
            try {
                rt(c) ? w = c(u, r.getOption()) : w = OI(v.value, g)
            } catch (A) {
                throw b(), new Error("Data view format error " + A)
            }
            w && r.dispatchAction({
                type: "changeDataView",
                newOption: w
            }), b()
        }), m.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = m.style.cssText = x, !n.get("readOnly") && y.appendChild(S), y.appendChild(m), o.appendChild(s), o.appendChild(u), o.appendChild(y), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o
    }, e.prototype.remove = function (t, r) {
        this._dom && r.getDom().removeChild(this._dom)
    }, e.prototype.dispose = function (t, r) {
        this.remove(t, r)
    }, e.getDefaultOption = function (t) {
        var r = {
            show: !0,
            readOnly: !1,
            optionToContent: null,
            contentToOption: null,
            icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
            title: t.getLocaleModel().get(["toolbox", "dataView", "title"]),
            lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]),
            backgroundColor: "#fff",
            textColor: "#000",
            textareaColor: "#fff",
            textareaBorderColor: "#333",
            buttonColor: "#c23531",
            buttonTextColor: "#fff"
        };
        return r
    }, e
}(ne);

function NI(a, e) {
    return G(a, function (t, r) {
        var i = e && e[r];
        if (St(i) && !B(i)) {
            var n = St(t) && !B(t);
            n || (t = {
                value: t
            });
            var o = i.name != null && t.name == null;
            return t = at(t, i), o && delete t.name, t
        } else return t
    })
}
an({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
}, function (a, e) {
    var t = [];
    T(a.newOption.series, function (r) {
        var i = e.getSeriesByName(r.name)[0];
        if (!i) t.push(W({
            type: "scatter"
        }, r));
        else {
            var n = i.get("data");
            t.push({
                name: r.name,
                data: NI(r.data, n)
            })
        }
    }), e.mergeOption(at({
        series: t
    }, a.newOption))
});
const GI = zI;
var Mg = T,
    Pg = xt();

function BI(a, e) {
    var t = Xl(a);
    Mg(e, function (r, i) {
        for (var n = t.length - 1; n >= 0; n--) {
            var o = t[n];
            if (o[i]) break
        }
        if (n < 0) {
            var s = a.queryComponents({
                mainType: "dataZoom",
                subType: "select",
                id: i
            })[0];
            if (s) {
                var l = s.getPercentRange();
                t[0][i] = {
                    dataZoomId: i,
                    start: l[0],
                    end: l[1]
                }
            }
        }
    }), t.push(e)
}

function HI(a) {
    var e = Xl(a),
        t = e[e.length - 1];
    e.length > 1 && e.pop();
    var r = {};
    return Mg(t, function (i, n) {
        for (var o = e.length - 1; o >= 0; o--)
            if (i = e[o][n], i) {
                r[n] = i;
                break
            }
    }), r
}

function FI(a) {
    Pg(a).snapshots = null
}

function WI(a) {
    return Xl(a).length
}

function Xl(a) {
    var e = Pg(a);
    return e.snapshots || (e.snapshots = [{}]), e.snapshots
}
var $I = function (a) {
    E(e, a);

    function e() {
        return a !== null && a.apply(this, arguments) || this
    }
    return e.prototype.onclick = function (t, r) {
        FI(t), r.dispatchAction({
            type: "restore",
            from: this.uid
        })
    }, e.getDefaultOption = function (t) {
        var r = {
            show: !0,
            icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
            title: t.getLocaleModel().get(["toolbox", "restore", "title"])
        };
        return r
    }, e
}(ne);
an({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
}, function (a, e) {
    e.resetOption("recreate")
});
const ZI = $I;
var UI = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"],
    YI = function () {
        function a(e, t, r) {
            var i = this;
            this._targetInfoList = [];
            var n = _c(t, e);
            T(XI, function (o, s) {
                (!r || !r.include || ft(r.include, s) >= 0) && o(n, i._targetInfoList)
            })
        }
        return a.prototype.setOutputRanges = function (e, t) {
            return this.matchOutputRanges(e, t, function (r, i, n) {
                if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) {
                    r.coordRange = i;
                    var o = Io[r.brushType](0, n, i);
                    r.__rangeOffset = {
                        offset: Tc[r.brushType](o.values, r.range, [1, 1]),
                        xyMinMax: o.xyMinMax
                    }
                }
            }), e
        }, a.prototype.matchOutputRanges = function (e, t, r) {
            T(e, function (i) {
                var n = this.findTargetInfo(i, t);
                n && n !== !0 && T(n.coordSyses, function (o) {
                    var s = Io[i.brushType](1, o, i.range, !0);
                    r(i, s.values, o, t)
                })
            }, this)
        }, a.prototype.setInputRanges = function (e, t) {
            T(e, function (r) {
                var i = this.findTargetInfo(r, t);
                if (r.range = r.range || [], i && i !== !0) {
                    r.panelId = i.panelId;
                    var n = Io[r.brushType](0, i.coordSys, r.coordRange),
                        o = r.__rangeOffset;
                    r.range = o ? Tc[r.brushType](n.values, o.offset, KI(n.xyMinMax, o.xyMinMax)) : n.values
                }
            }, this)
        }, a.prototype.makePanelOpts = function (e, t) {
            return G(this._targetInfoList, function (r) {
                var i = r.getPanelRect();
                return {
                    panelId: r.panelId,
                    defaultBrushType: t ? t(r) : null,
                    clipPath: Nd(i),
                    isTargetByCursor: Bd(i, e, r.coordSysModel),
                    getLinearBrushOtherExtent: Gd(i)
                }
            })
        }, a.prototype.controlSeries = function (e, t, r) {
            var i = this.findTargetInfo(e, r);
            return i === !0 || i && ft(i.coordSyses, t.coordinateSystem) >= 0
        }, a.prototype.findTargetInfo = function (e, t) {
            for (var r = this._targetInfoList, i = _c(t, e), n = 0; n < r.length; n++) {
                var o = r[n],
                    s = e.panelId;
                if (s) {
                    if (o.panelId === s) return o
                } else
                    for (var l = 0; l < bc.length; l++)
                        if (bc[l](i, o)) return o
            }
            return !0
        }, a
    }();

function Rs(a) {
    return a[0] > a[1] && a.reverse(), a
}

function _c(a, e) {
    return vp(a, e, {
        includeMainTypes: UI
    })
}
var XI = {
        grid: function (a, e) {
            var t = a.xAxisModels,
                r = a.yAxisModels,
                i = a.gridModels,
                n = Q(),
                o = {},
                s = {};
            !t && !r && !i || (T(t, function (l) {
                var u = l.axis.grid.model;
                n.set(u.id, u), o[u.id] = !0
            }), T(r, function (l) {
                var u = l.axis.grid.model;
                n.set(u.id, u), s[u.id] = !0
            }), T(i, function (l) {
                n.set(l.id, l), o[l.id] = !0, s[l.id] = !0
            }), n.each(function (l) {
                var u = l.coordinateSystem,
                    v = [];
                T(u.getCartesians(), function (h, c) {
                    (ft(t, h.getAxis("x").model) >= 0 || ft(r, h.getAxis("y").model) >= 0) && v.push(h)
                }), e.push({
                    panelId: "grid--" + l.id,
                    gridModel: l,
                    coordSysModel: l,
                    coordSys: v[0],
                    coordSyses: v,
                    getPanelRect: wc.grid,
                    xAxisDeclared: o[l.id],
                    yAxisDeclared: s[l.id]
                })
            }))
        },
        geo: function (a, e) {
            T(a.geoModels, function (t) {
                var r = t.coordinateSystem;
                e.push({
                    panelId: "geo--" + t.id,
                    geoModel: t,
                    coordSysModel: t,
                    coordSys: r,
                    coordSyses: [r],
                    getPanelRect: wc.geo
                })
            })
        }
    },
    bc = [function (a, e) {
        var t = a.xAxisModel,
            r = a.yAxisModel,
            i = a.gridModel;
        return !i && t && (i = t.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === e.gridModel
    }, function (a, e) {
        var t = a.geoModel;
        return t && t === e.geoModel
    }],
    wc = {
        grid: function () {
            return this.coordSys.master.getRect().clone()
        },
        geo: function () {
            var a = this.coordSys,
                e = a.getBoundingRect().clone();
            return e.applyTransform(zr(a)), e
        }
    },
    Io = {
        lineX: K(Ac, 0),
        lineY: K(Ac, 1),
        rect: function (a, e, t, r) {
            var i = a ? e.pointToData([t[0][0], t[1][0]], r) : e.dataToPoint([t[0][0], t[1][0]], r),
                n = a ? e.pointToData([t[0][1], t[1][1]], r) : e.dataToPoint([t[0][1], t[1][1]], r),
                o = [Rs([i[0], n[0]]), Rs([i[1], n[1]])];
            return {
                values: o,
                xyMinMax: o
            }
        },
        polygon: function (a, e, t, r) {
            var i = [
                    [1 / 0, -1 / 0],
                    [1 / 0, -1 / 0]
                ],
                n = G(t, function (o) {
                    var s = a ? e.pointToData(o, r) : e.dataToPoint(o, r);
                    return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s
                });
            return {
                values: n,
                xyMinMax: i
            }
        }
    };

function Ac(a, e, t, r) {
    var i = t.getAxis(["x", "y"][a]),
        n = Rs(G([0, 1], function (s) {
            return e ? i.coordToData(i.toLocalCoord(r[s]), !0) : i.toGlobalCoord(i.dataToCoord(r[s]))
        })),
        o = [];
    return o[a] = n, o[1 - a] = [NaN, NaN], {
        values: n,
        xyMinMax: o
    }
}
var Tc = {
    lineX: K(Cc, 0),
    lineY: K(Cc, 1),
    rect: function (a, e, t) {
        return [
            [a[0][0] - t[0] * e[0][0], a[0][1] - t[0] * e[0][1]],
            [a[1][0] - t[1] * e[1][0], a[1][1] - t[1] * e[1][1]]
        ]
    },
    polygon: function (a, e, t) {
        return G(a, function (r, i) {
            return [r[0] - t[0] * e[i][0], r[1] - t[1] * e[i][1]]
        })
    }
};

function Cc(a, e, t, r) {
    return [e[0] - r[a] * t[0], e[1] - r[a] * t[1]]
}

function KI(a, e) {
    var t = Dc(a),
        r = Dc(e),
        i = [t[0] / r[0], t[1] / r[1]];
    return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i
}

function Dc(a) {
    return a ? [a[0][1] - a[0][0], a[1][1] - a[1][0]] : [NaN, NaN]
}
const Kl = YI;
var Es = T,
    qI = Um("toolbox-dataZoom_"),
    jI = function (a) {
        E(e, a);

        function e() {
            return a !== null && a.apply(this, arguments) || this
        }
        return e.prototype.render = function (t, r, i, n) {
            this._brushController || (this._brushController = new Ll(i.getZr()), this._brushController.on("brush", F(this._onBrush, this)).mount()), tL(t, r, this, n, i), QI(t, r)
        }, e.prototype.onclick = function (t, r, i) {
            JI[i].call(this)
        }, e.prototype.remove = function (t, r) {
            this._brushController && this._brushController.unmount()
        }, e.prototype.dispose = function (t, r) {
            this._brushController && this._brushController.dispose()
        }, e.prototype._onBrush = function (t) {
            var r = t.areas;
            if (!t.isEnd || !r.length) return;
            var i = {},
                n = this.ecModel;
            this._brushController.updateCovers([]);
            var o = new Kl(ql(this.model), n, {
                include: ["grid"]
            });
            o.matchOutputRanges(r, n, function (u, v, h) {
                if (h.type === "cartesian2d") {
                    var c = u.brushType;
                    c === "rect" ? (s("x", h, v[0]), s("y", h, v[1])) : s({
                        lineX: "x",
                        lineY: "y"
                    } [c], h, v)
                }
            }), BI(n, i), this._dispatchZoomAction(i);

            function s(u, v, h) {
                var c = v.getAxis(u),
                    f = c.model,
                    p = l(u, f, n),
                    d = p.findRepresentativeAxisProxy(f).getMinMaxSpan();
                (d.minValueSpan != null || d.maxValueSpan != null) && (h = Sr(0, h.slice(), c.scale.getExtent(), 0, d.minValueSpan, d.maxValueSpan)), p && (i[p.id] = {
                    dataZoomId: p.id,
                    startValue: h[0],
                    endValue: h[1]
                })
            }

            function l(u, v, h) {
                var c;
                return h.eachComponent({
                    mainType: "dataZoom",
                    subType: "select"
                }, function (f) {
                    var p = f.getAxisModel(u, v.componentIndex);
                    p && (c = f)
                }), c
            }
        }, e.prototype._dispatchZoomAction = function (t) {
            var r = [];
            Es(t, function (i, n) {
                r.push(ot(i))
            }), r.length && this.api.dispatchAction({
                type: "dataZoom",
                from: this.uid,
                batch: r
            })
        }, e.getDefaultOption = function (t) {
            var r = {
                show: !0,
                filterMode: "filter",
                icon: {
                    zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
                    back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
                },
                title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
                brushStyle: {
                    borderWidth: 0,
                    color: "rgba(210,219,238,0.2)"
                }
            };
            return r
        }, e
    }(ne),
    JI = {
        zoom: function () {
            var a = !this._isZoomActive;
            this.api.dispatchAction({
                type: "takeGlobalCursor",
                key: "dataZoomSelect",
                dataZoomSelectActive: a
            })
        },
        back: function () {
            this._dispatchZoomAction(HI(this.ecModel))
        }
    };

function ql(a) {
    var e = {
        xAxisIndex: a.get("xAxisIndex", !0),
        yAxisIndex: a.get("yAxisIndex", !0),
        xAxisId: a.get("xAxisId", !0),
        yAxisId: a.get("yAxisId", !0)
    };
    return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e
}

function QI(a, e) {
    a.setIconStatus("back", WI(e) > 1 ? "emphasis" : "normal")
}

function tL(a, e, t, r, i) {
    var n = t._isZoomActive;
    r && r.type === "takeGlobalCursor" && (n = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : !1), t._isZoomActive = n, a.setIconStatus("zoom", n ? "emphasis" : "normal");
    var o = new Kl(ql(a), e, {
            include: ["grid"]
        }),
        s = o.makePanelOpts(i, function (l) {
            return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect"
        });
    t._brushController.setPanels(s).enableBrush(n && s.length ? {
        brushType: "auto",
        brushStyle: a.getModel("brushStyle").getItemStyle()
    } : !1)
}
Zm("dataZoom", function (a) {
    var e = a.getComponent("toolbox", 0),
        t = ["feature", "dataZoom"];
    if (!e || e.get(t) == null) return;
    var r = e.getModel(t),
        i = [],
        n = ql(r),
        o = vp(a, n);
    Es(o.xAxisModels, function (l) {
        return s(l, "xAxis", "xAxisIndex")
    }), Es(o.yAxisModels, function (l) {
        return s(l, "yAxis", "yAxisIndex")
    });

    function s(l, u, v) {
        var h = l.componentIndex,
            c = {
                type: "select",
                $fromToolbox: !0,
                filterMode: r.get("filterMode", !0) || "filter",
                id: qI + u + h
            };
        c[v] = h, i.push(c)
    }
    return i
});
const eL = jI;

function rL(a) {
    a.registerComponentModel(xI), a.registerComponentView(wI), Rr("saveAsImage", TI), Rr("magicType", II), Rr("dataView", GI), Rr("dataZoom", eL), Rr("restore", ZI), j(yI)
}
var aL = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
        z: 60,
        show: !0,
        showContent: !0,
        trigger: "item",
        triggerOn: "mousemove|click",
        alwaysShowContent: !1,
        displayMode: "single",
        renderMode: "auto",
        confine: null,
        showDelay: 0,
        hideDelay: 100,
        transitionDuration: .4,
        enterable: !1,
        backgroundColor: "#fff",
        shadowBlur: 10,
        shadowColor: "rgba(0, 0, 0, .2)",
        shadowOffsetX: 1,
        shadowOffsetY: 2,
        borderRadius: 4,
        borderWidth: 1,
        padding: null,
        extraCssText: "",
        axisPointer: {
            type: "line",
            axis: "auto",
            animation: "auto",
            animationDurationUpdate: 200,
            animationEasingUpdate: "exponentialOut",
            crossStyle: {
                color: "#999",
                width: 1,
                type: "dashed",
                textStyle: {}
            }
        },
        textStyle: {
            color: "#666",
            fontSize: 14
        }
    }, e
}(Ct);
const iL = aL;

function Rg(a) {
    var e = a.get("confine");
    return e != null ? !!e : a.get("renderMode") === "richText"
}

function Eg(a) {
    if (Nt.domSupported) {
        for (var e = document.documentElement.style, t = 0, r = a.length; t < r; t++)
            if (a[t] in e) return a[t]
    }
}
var kg = Eg(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]),
    nL = Eg(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);

function Vg(a, e) {
    if (!a) return e;
    e = hp(e, !0);
    var t = a.indexOf(e);
    return a = t === -1 ? e : "-" + a.slice(0, t) + "-" + e, a.toLowerCase()
}

function oL(a, e) {
    var t = a.currentStyle || document.defaultView && document.defaultView.getComputedStyle(a);
    return t ? e ? t[e] : t : null
}
var sL = Vg(nL, "transition"),
    jl = Vg(kg, "transform"),
    lL = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (Nt.transform3dSupported ? "will-change:transform;" : "");

function uL(a) {
    return a = a === "left" ? "right" : a === "right" ? "left" : a === "top" ? "bottom" : "top", a
}

function vL(a, e, t) {
    if (!q(t) || t === "inside") return "";
    var r = a.get("backgroundColor"),
        i = a.get("borderWidth");
    e = $r(e);
    var n = uL(t),
        o = Math.max(Math.round(i) * 1.5, 6),
        s = "",
        l = jl + ":",
        u;
    ft(["left", "right"], n) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = n === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = n === "top" ? 225 : 45) + "deg)");
    var v = u * Math.PI / 180,
        h = o + i,
        c = h * Math.abs(Math.cos(v)) + h * Math.abs(Math.sin(v)),
        f = Math.round(((c - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (c - h) / 2) * 100) / 100;
    s += ";" + n + ":-" + f + "px";
    var p = e + " solid " + i + "px;",
        d = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + r + ";"];
    return '<div style="' + d.join("") + '"></div>'
}

function hL(a, e) {
    var t = "cubic-bezier(0.23,1,0.32,1)",
        r = " " + a / 2 + "s " + t,
        i = "opacity" + r + ",visibility" + r;
    return e || (r = " " + a + "s " + t, i += Nt.transformSupported ? "," + jl + r : ",left" + r + ",top" + r), sL + ":" + i
}

function Ic(a, e, t) {
    var r = a.toFixed(0) + "px",
        i = e.toFixed(0) + "px";
    if (!Nt.transformSupported) return t ? "top:" + i + ";left:" + r + ";" : [
        ["top", i],
        ["left", r]
    ];
    var n = Nt.transform3dSupported,
        o = "translate" + (n ? "3d" : "") + "(" + r + "," + i + (n ? ",0" : "") + ")";
    return t ? "top:0;left:0;" + jl + ":" + o + ";" : [
        ["top", 0],
        ["left", 0],
        [kg, o]
    ]
}

function cL(a) {
    var e = [],
        t = a.get("fontSize"),
        r = a.getTextColor();
    r && e.push("color:" + r), e.push("font:" + a.getFont()), t && e.push("line-height:" + Math.round(t * 3 / 2) + "px");
    var i = a.get("textShadowColor"),
        n = a.get("textShadowBlur") || 0,
        o = a.get("textShadowOffsetX") || 0,
        s = a.get("textShadowOffsetY") || 0;
    return i && n && e.push("text-shadow:" + o + "px " + s + "px " + n + "px " + i), T(["decoration", "align"], function (l) {
        var u = a.get(l);
        u && e.push("text-" + l + ":" + u)
    }), e.join(";")
}

function fL(a, e, t) {
    var r = [],
        i = a.get("transitionDuration"),
        n = a.get("backgroundColor"),
        o = a.get("shadowBlur"),
        s = a.get("shadowColor"),
        l = a.get("shadowOffsetX"),
        u = a.get("shadowOffsetY"),
        v = a.getModel("textStyle"),
        h = cp(a, "html"),
        c = l + "px " + u + "px " + o + "px " + s;
    return r.push("box-shadow:" + c), e && i && r.push(hL(i, t)), n && r.push("background-color:" + n), T(["width", "color", "radius"], function (f) {
        var p = "border-" + f,
            d = hp(p),
            g = a.get(d);
        g != null && r.push(p + ":" + g + (f === "color" ? "" : "px"))
    }), r.push(cL(v)), h != null && r.push("padding:" + pn(h).join("px ") + "px"), r.join(";") + ";"
}

function Lc(a, e, t, r, i) {
    var n = e && e.painter;
    if (t) {
        var o = n && n.getViewportRoot();
        o && Xm(a, o, t, r, i)
    } else {
        a[0] = r, a[1] = i;
        var s = n && n.getViewportRootOffset();
        s && (a[0] += s.offsetLeft, a[1] += s.offsetTop)
    }
    a[2] = a[0] / e.getWidth(), a[3] = a[1] / e.getHeight()
}
var pL = function () {
    function a(e, t) {
        if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, Nt.wxa) return null;
        var r = document.createElement("div");
        r.domBelongToZr = !0, this.el = r;
        var i = this._zr = e.getZr(),
            n = t.appendTo,
            o = n && (q(n) ? document.querySelector(n) : es(n) ? n : rt(n) && n(e.getDom()));
        Lc(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(r), this._api = e, this._container = o;
        var s = this;
        r.onmouseenter = function () {
            s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0
        }, r.onmousemove = function (l) {
            if (l = l || window.event, !s._enterable) {
                var u = i.handler,
                    v = i.painter.getViewportRoot();
                Ym(v, l, !0), u.dispatch("mousemove", l)
            }
        }, r.onmouseleave = function () {
            s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay)
        }
    }
    return a.prototype.update = function (e) {
        if (!this._container) {
            var t = this._api.getDom(),
                r = oL(t, "position"),
                i = t.style;
            i.position !== "absolute" && r !== "absolute" && (i.position = "relative")
        }
        var n = e.get("alwaysShowContent");
        n && this._moveIfResized(), this._alwaysShowContent = n, this.el.className = e.get("className") || ""
    }, a.prototype.show = function (e, t) {
        clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
        var r = this.el,
            i = r.style,
            n = this._styleCoord;
        r.innerHTML ? i.cssText = lL + fL(e, !this._firstShow, this._longHide) + Ic(n[0], n[1], !0) + ("border-color:" + $r(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1
    }, a.prototype.setContent = function (e, t, r, i, n) {
        var o = this.el;
        if (e == null) {
            o.innerHTML = "";
            return
        }
        var s = "";
        if (q(n) && r.get("trigger") === "item" && !Rg(r) && (s = vL(r, i, n)), q(e)) o.innerHTML = e + s;
        else if (e) {
            o.innerHTML = "", B(e) || (e = [e]);
            for (var l = 0; l < e.length; l++) es(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
            if (s && o.childNodes.length) {
                var u = document.createElement("div");
                u.innerHTML = s, o.appendChild(u)
            }
        }
    }, a.prototype.setEnterable = function (e) {
        this._enterable = e
    }, a.prototype.getSize = function () {
        var e = this.el;
        return [e.offsetWidth, e.offsetHeight]
    }, a.prototype.moveTo = function (e, t) {
        var r = this._styleCoord;
        if (Lc(r, this._zr, this._container, e, t), r[0] != null && r[1] != null) {
            var i = this.el.style,
                n = Ic(r[0], r[1]);
            T(n, function (o) {
                i[o[0]] = o[1]
            })
        }
    }, a.prototype._moveIfResized = function () {
        var e = this._styleCoord[2],
            t = this._styleCoord[3];
        this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight())
    }, a.prototype.hide = function () {
        var e = this,
            t = this.el.style;
        t.visibility = "hidden", t.opacity = "0", Nt.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function () {
            return e._longHide = !0
        }, 500)
    }, a.prototype.hideLater = function (e) {
        this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(F(this.hide, this), e)) : this.hide())
    }, a.prototype.isShow = function () {
        return this._show
    }, a.prototype.dispose = function () {
        clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
        var e = this.el.parentNode;
        e && e.removeChild(this.el), this.el = this._container = null
    }, a
}();
const dL = pL;
var gL = function () {
    function a(e) {
        this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), Pc(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2)
    }
    return a.prototype.update = function (e) {
        var t = e.get("alwaysShowContent");
        t && this._moveIfResized(), this._alwaysShowContent = t
    }, a.prototype.show = function () {
        this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0
    }, a.prototype.setContent = function (e, t, r, i, n) {
        var o = this;
        St(e) && bt(""), this.el && this._zr.remove(this.el);
        var s = r.getModel("textStyle");
        this.el = new ut({
            style: {
                rich: t.richTextStyles,
                text: e,
                lineHeight: 22,
                borderWidth: 1,
                borderColor: i,
                textShadowColor: s.get("textShadowColor"),
                fill: r.get(["textStyle", "color"]),
                padding: cp(r, "richText"),
                verticalAlign: "top",
                align: "left"
            },
            z: r.get("z")
        }), T(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function (u) {
            o.el.style[u] = r.get(u)
        }), T(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function (u) {
            o.el.style[u] = s.get(u) || 0
        }), this._zr.add(this.el);
        var l = this;
        this.el.on("mouseover", function () {
            l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0
        }), this.el.on("mouseout", function () {
            l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1
        })
    }, a.prototype.setEnterable = function (e) {
        this._enterable = e
    }, a.prototype.getSize = function () {
        var e = this.el,
            t = this.el.getBoundingRect(),
            r = Mc(e.style);
        return [t.width + r.left + r.right, t.height + r.top + r.bottom]
    }, a.prototype.moveTo = function (e, t) {
        var r = this.el;
        if (r) {
            var i = this._styleCoord;
            Pc(i, this._zr, e, t), e = i[0], t = i[1];
            var n = r.style,
                o = Me(n.borderWidth || 0),
                s = Mc(n);
            r.x = e + o + s.left, r.y = t + o + s.top, r.markRedraw()
        }
    }, a.prototype._moveIfResized = function () {
        var e = this._styleCoord[2],
            t = this._styleCoord[3];
        this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight())
    }, a.prototype.hide = function () {
        this.el && this.el.hide(), this._show = !1
    }, a.prototype.hideLater = function (e) {
        this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(F(this.hide, this), e)) : this.hide())
    }, a.prototype.isShow = function () {
        return this._show
    }, a.prototype.dispose = function () {
        this._zr.remove(this.el)
    }, a
}();

function Me(a) {
    return Math.max(0, a)
}

function Mc(a) {
    var e = Me(a.shadowBlur || 0),
        t = Me(a.shadowOffsetX || 0),
        r = Me(a.shadowOffsetY || 0);
    return {
        left: Me(e - t),
        right: Me(e + t),
        top: Me(e - r),
        bottom: Me(e + r)
    }
}

function Pc(a, e, t, r) {
    a[0] = t, a[1] = r, a[2] = a[0] / e.getWidth(), a[3] = a[1] / e.getHeight()
}
var yL = new pt({
        shape: {
            x: -1,
            y: -1,
            width: 2,
            height: 2
        }
    }),
    mL = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function (t, r) {
            if (!(Nt.node || !r.getDom())) {
                var i = t.getComponent("tooltip"),
                    n = this._renderMode = Km(i.get("renderMode"));
                this._tooltipContent = n === "richText" ? new gL(r) : new dL(r, {
                    appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
                })
            }
        }, e.prototype.render = function (t, r, i) {
            if (!(Nt.node || !i.getDom())) {
                this.group.removeAll(), this._tooltipModel = t, this._ecModel = r, this._api = i;
                var n = this._tooltipContent;
                n.update(t), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Jr(this, "_updatePosition", 50, "fixRate") : Ta(this, "_updatePosition")
            }
        }, e.prototype._initGlobalListener = function () {
            var t = this._tooltipModel,
                r = t.get("triggerOn");
            mg("itemTooltip", this._api, F(function (i, n, o) {
                r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(n, o) : i === "leave" && this._hide(o))
            }, this))
        }, e.prototype._keepShow = function () {
            var t = this._tooltipModel,
                r = this._ecModel,
                i = this._api,
                n = t.get("triggerOn");
            if (this._lastX != null && this._lastY != null && n !== "none" && n !== "click") {
                var o = this;
                clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
                    !i.isDisposed() && o.manuallyShowTip(t, r, i, {
                        x: o._lastX,
                        y: o._lastY,
                        dataByCoordSys: o._lastDataByCoordSys
                    })
                })
            }
        }, e.prototype.manuallyShowTip = function (t, r, i, n) {
            if (!(n.from === this.uid || Nt.node || !i.getDom())) {
                var o = Rc(n, i);
                this._ticket = "";
                var s = n.dataByCoordSys,
                    l = bL(n, r, i);
                if (l) {
                    var u = l.el.getBoundingRect().clone();
                    u.applyTransform(l.el.transform), this._tryShow({
                        offsetX: u.x + u.width / 2,
                        offsetY: u.y + u.height / 2,
                        target: l.el,
                        position: n.position,
                        positionDefault: "bottom"
                    }, o)
                } else if (n.tooltip && n.x != null && n.y != null) {
                    var v = yL;
                    v.x = n.x, v.y = n.y, v.update(), tt(v).tooltipConfig = {
                        name: null,
                        option: n.tooltip
                    }, this._tryShow({
                        offsetX: n.x,
                        offsetY: n.y,
                        target: v
                    }, o)
                } else if (s) this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    dataByCoordSys: s,
                    tooltipOption: n.tooltipOption
                }, o);
                else if (n.seriesIndex != null) {
                    if (this._manuallyAxisShowTip(t, r, i, n)) return;
                    var h = xg(n, r),
                        c = h.point[0],
                        f = h.point[1];
                    c != null && f != null && this._tryShow({
                        offsetX: c,
                        offsetY: f,
                        target: h.el,
                        position: n.position,
                        positionDefault: "bottom"
                    }, o)
                } else n.x != null && n.y != null && (i.dispatchAction({
                    type: "updateAxisPointer",
                    x: n.x,
                    y: n.y
                }), this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    target: i.getZr().findHover(n.x, n.y).target
                }, o))
            }
        }, e.prototype.manuallyHideTip = function (t, r, i, n) {
            var o = this._tooltipContent;
            this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, n.from !== this.uid && this._hide(Rc(n, i))
        }, e.prototype._manuallyAxisShowTip = function (t, r, i, n) {
            var o = n.seriesIndex,
                s = n.dataIndex,
                l = r.getComponent("axisPointer").coordSysAxesInfo;
            if (!(o == null || s == null || l == null)) {
                var u = r.getSeriesByIndex(o);
                if (u) {
                    var v = u.getData(),
                        h = ia([v.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
                    if (h.get("trigger") === "axis") return i.dispatchAction({
                        type: "updateAxisPointer",
                        seriesIndex: o,
                        dataIndex: s,
                        position: n.position
                    }), !0
                }
            }
        }, e.prototype._tryShow = function (t, r) {
            var i = t.target,
                n = this._tooltipModel;
            if (n) {
                this._lastX = t.offsetX, this._lastY = t.offsetY;
                var o = t.dataByCoordSys;
                if (o && o.length) this._showAxisTooltip(o, t);
                else if (i) {
                    var s = tt(i);
                    if (s.ssrType === "legend") return;
                    this._lastDataByCoordSys = null;
                    var l, u;
                    Ks(i, function (v) {
                        if (tt(v).dataIndex != null) return l = v, !0;
                        if (tt(v).tooltipConfig != null) return u = v, !0
                    }, !0), l ? this._showSeriesItemTooltip(t, l, r) : u ? this._showComponentItemTooltip(t, u, r) : this._hide(r)
                } else this._lastDataByCoordSys = null, this._hide(r)
            }
        }, e.prototype._showOrMove = function (t, r) {
            var i = t.get("showDelay");
            r = F(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r()
        }, e.prototype._showAxisTooltip = function (t, r) {
            var i = this._ecModel,
                n = this._tooltipModel,
                o = [r.offsetX, r.offsetY],
                s = ia([r.tooltipOption], n),
                l = this._renderMode,
                u = [],
                v = qt("section", {
                    blocks: [],
                    noHeader: !0
                }),
                h = [],
                c = new Dn;
            T(t, function (x) {
                T(x.dataByAxis, function (m) {
                    var S = i.getComponent(m.axisDim + "Axis", m.axisIndex),
                        _ = m.value;
                    if (!(!S || _ == null)) {
                        var b = dg(_, S.axis, i, m.seriesDataIndices, m.valueLabelOpt),
                            w = qt("section", {
                                header: b,
                                noHeader: !Kf(b),
                                sortBlocks: !0,
                                blocks: []
                            });
                        v.blocks.push(w), T(m.seriesDataIndices, function (A) {
                            var C = i.getSeriesByIndex(A.seriesIndex),
                                D = A.dataIndexInside,
                                I = C.getDataParams(D);
                            if (!(I.dataIndex < 0)) {
                                I.axisDim = m.axisDim, I.axisIndex = m.axisIndex, I.axisType = m.axisType, I.axisId = m.axisId, I.axisValue = up(S.axis, {
                                    value: _
                                }), I.axisValueLabel = b, I.marker = c.makeTooltipMarker("item", $r(I.color), l);
                                var L = Au(C.formatTooltip(D, !0, null)),
                                    M = L.frag;
                                if (M) {
                                    var P = ia([C], n).get("valueFormatter");
                                    w.blocks.push(P ? W({
                                        valueFormatter: P
                                    }, M) : M)
                                }
                                L.text && h.push(L.text), u.push(I)
                            }
                        })
                    }
                })
            }), v.blocks.reverse(), h.reverse();
            var f = r.position,
                p = s.get("order"),
                d = Tu(v, c, l, p, i.get("useUTC"), s.get("textStyle"));
            d && h.unshift(d);
            var g = l === "richText" ? `

` : "<br/>",
                y = h.join(g);
            this._showOrMove(s, function () {
                this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, f, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, y, u, Math.random() + "", o[0], o[1], f, null, c)
            })
        }, e.prototype._showSeriesItemTooltip = function (t, r, i) {
            var n = this._ecModel,
                o = tt(r),
                s = o.seriesIndex,
                l = n.getSeriesByIndex(s),
                u = o.dataModel || l,
                v = o.dataIndex,
                h = o.dataType,
                c = u.getData(h),
                f = this._renderMode,
                p = t.positionDefault,
                d = ia([c.getItemModel(v), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
                    position: p
                } : null),
                g = d.get("trigger");
            if (!(g != null && g !== "item")) {
                var y = u.getDataParams(v, h),
                    x = new Dn;
                y.marker = x.makeTooltipMarker("item", $r(y.color), f);
                var m = Au(u.formatTooltip(v, !1, h)),
                    S = d.get("order"),
                    _ = d.get("valueFormatter"),
                    b = m.frag,
                    w = b ? Tu(_ ? W({
                        valueFormatter: _
                    }, b) : b, x, f, S, n.get("useUTC"), d.get("textStyle")) : m.text,
                    A = "item_" + u.name + "_" + v;
                this._showOrMove(d, function () {
                    this._showTooltipContent(d, w, y, A, t.offsetX, t.offsetY, t.position, t.target, x)
                }), i({
                    type: "showTip",
                    dataIndexInside: v,
                    dataIndex: c.getRawIndex(v),
                    seriesIndex: s,
                    from: this.uid
                })
            }
        }, e.prototype._showComponentItemTooltip = function (t, r, i) {
            var n = tt(r),
                o = n.tooltipConfig,
                s = o.option || {};
            if (q(s)) {
                var l = s;
                s = {
                    content: l,
                    formatter: l
                }
            }
            var u = [s],
                v = this._ecModel.getComponent(n.componentMainType, n.componentIndex);
            v && u.push(v), u.push({
                formatter: s.content
            });
            var h = t.positionDefault,
                c = ia(u, this._tooltipModel, h ? {
                    position: h
                } : null),
                f = c.get("content"),
                p = Math.random() + "",
                d = new Dn;
            this._showOrMove(c, function () {
                var g = ot(c.get("formatterParams") || {});
                this._showTooltipContent(c, f, g, p, t.offsetX, t.offsetY, t.position, r, d)
            }), i({
                type: "showTip",
                from: this.uid
            })
        }, e.prototype._showTooltipContent = function (t, r, i, n, o, s, l, u, v) {
            if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
                var h = this._tooltipContent;
                h.setEnterable(t.get("enterable"));
                var c = t.get("formatter");
                l = l || t.get("position");
                var f = r,
                    p = this._getNearestPoint([o, s], i, t.get("trigger"), t.get("borderColor")),
                    d = p.color;
                if (c)
                    if (q(c)) {
                        var g = t.ecModel.get("useUTC"),
                            y = B(i) ? i[0] : i,
                            x = y && y.axisType && y.axisType.indexOf("time") >= 0;
                        f = c, x && (f = qm(y.axisValue, f, g)), f = jm(f, i, !0)
                    } else if (rt(c)) {
                    var m = F(function (S, _) {
                        S === this._ticket && (h.setContent(_, v, t, d, l), this._updatePosition(t, l, o, s, h, i, u))
                    }, this);
                    this._ticket = n, f = c(i, n, m)
                } else f = c;
                h.setContent(f, v, t, d, l), h.show(t, d), this._updatePosition(t, l, o, s, h, i, u)
            }
        }, e.prototype._getNearestPoint = function (t, r, i, n) {
            if (i === "axis" || B(r)) return {
                color: n || (this._renderMode === "html" ? "#fff" : "none")
            };
            if (!B(r)) return {
                color: n || r.color || r.borderColor
            }
        }, e.prototype._updatePosition = function (t, r, i, n, o, s, l) {
            var u = this._api.getWidth(),
                v = this._api.getHeight();
            r = r || t.get("position");
            var h = o.getSize(),
                c = t.get("align"),
                f = t.get("verticalAlign"),
                p = l && l.getBoundingRect().clone();
            if (l && p.applyTransform(l.transform), rt(r) && (r = r([i, n], s, o.el, p, {
                    viewSize: [u, v],
                    contentSize: h.slice()
                })), B(r)) i = H(r[0], u), n = H(r[1], v);
            else if (St(r)) {
                var d = r;
                d.width = h[0], d.height = h[1];
                var g = kt(d, {
                    width: u,
                    height: v
                });
                i = g.x, n = g.y, c = null, f = null
            } else if (q(r) && l) {
                var y = _L(r, p, h, t.get("borderWidth"));
                i = y[0], n = y[1]
            } else {
                var y = xL(i, n, o, u, v, c ? null : 20, f ? null : 20);
                i = y[0], n = y[1]
            }
            if (c && (i -= Ec(c) ? h[0] / 2 : c === "right" ? h[0] : 0), f && (n -= Ec(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), Rg(t)) {
                var y = SL(i, n, o, u, v);
                i = y[0], n = y[1]
            }
            o.moveTo(i, n)
        }, e.prototype._updateContentNotChangedOnAxis = function (t, r) {
            var i = this._lastDataByCoordSys,
                n = this._cbParamsList,
                o = !!i && i.length === t.length;
            return o && T(i, function (s, l) {
                var u = s.dataByAxis || [],
                    v = t[l] || {},
                    h = v.dataByAxis || [];
                o = o && u.length === h.length, o && T(u, function (c, f) {
                    var p = h[f] || {},
                        d = c.seriesDataIndices || [],
                        g = p.seriesDataIndices || [];
                    o = o && c.value === p.value && c.axisType === p.axisType && c.axisId === p.axisId && d.length === g.length, o && T(d, function (y, x) {
                        var m = g[x];
                        o = o && y.seriesIndex === m.seriesIndex && y.dataIndex === m.dataIndex
                    }), n && T(c.seriesDataIndices, function (y) {
                        var x = y.seriesIndex,
                            m = r[x],
                            S = n[x];
                        m && S && S.data !== m.data && (o = !1)
                    })
                })
            }), this._lastDataByCoordSys = t, this._cbParamsList = r, !!o
        }, e.prototype._hide = function (t) {
            this._lastDataByCoordSys = null, t({
                type: "hideTip",
                from: this.uid
            })
        }, e.prototype.dispose = function (t, r) {
            Nt.node || !r.getDom() || (Ta(this, "_updatePosition"), this._tooltipContent.dispose(), Is("itemTooltip", r))
        }, e.type = "tooltip", e
    }(It);

function ia(a, e, t) {
    var r = e.ecModel,
        i;
    t ? (i = new Rt(t, r, r), i = new Rt(e.option, i, r)) : i = e;
    for (var n = a.length - 1; n >= 0; n--) {
        var o = a[n];
        o && (o instanceof Rt && (o = o.get("tooltip", !0)), q(o) && (o = {
            formatter: o
        }), o && (i = new Rt(o, i, r)))
    }
    return i
}

function Rc(a, e) {
    return a.dispatchAction || F(e.dispatchAction, e)
}

function xL(a, e, t, r, i, n, o) {
    var s = t.getSize(),
        l = s[0],
        u = s[1];
    return n != null && (a + l + n + 2 > r ? a -= l + n : a += n), o != null && (e + u + o > i ? e -= u + o : e += o), [a, e]
}

function SL(a, e, t, r, i) {
    var n = t.getSize(),
        o = n[0],
        s = n[1];
    return a = Math.min(a + o, r) - o, e = Math.min(e + s, i) - s, a = Math.max(a, 0), e = Math.max(e, 0), [a, e]
}

function _L(a, e, t, r) {
    var i = t[0],
        n = t[1],
        o = Math.ceil(Math.SQRT2 * r) + 8,
        s = 0,
        l = 0,
        u = e.width,
        v = e.height;
    switch (a) {
        case "inside":
            s = e.x + u / 2 - i / 2, l = e.y + v / 2 - n / 2;
            break;
        case "top":
            s = e.x + u / 2 - i / 2, l = e.y - n - o;
            break;
        case "bottom":
            s = e.x + u / 2 - i / 2, l = e.y + v + o;
            break;
        case "left":
            s = e.x - i - o, l = e.y + v / 2 - n / 2;
            break;
        case "right":
            s = e.x + u + o, l = e.y + v / 2 - n / 2
    }
    return [s, l]
}

function Ec(a) {
    return a === "center" || a === "middle"
}

function bL(a, e, t) {
    var r = Jm(a).queryOptionMap,
        i = r.keys()[0];
    if (!(!i || i === "series")) {
        var n = Qm(e, i, r.get(i), {
                useDefault: !1,
                enableAll: !1,
                enableNone: !1
            }),
            o = n.models[0];
        if (o) {
            var s = t.getViewOfComponentModel(o),
                l;
            if (s.group.traverse(function (u) {
                    var v = tt(u).tooltipConfig;
                    if (v && v.name === a.name) return l = u, !0
                }), l) return {
                componentMainType: i,
                componentIndex: o.componentIndex,
                el: l
            }
        }
    }
}
const wL = mL;

function AL(a) {
    j(ja), a.registerComponentModel(iL), a.registerComponentView(wL), a.registerAction({
        type: "showTip",
        event: "showTip",
        update: "tooltip:manuallyShowTip"
    }, pe), a.registerAction({
        type: "hideTip",
        event: "hideTip",
        update: "tooltip:manuallyHideTip"
    }, pe)
}
var TL = ["rect", "polygon", "keep", "clear"];

function CL(a, e) {
    var t = Wt(a ? a.brush : []);
    if (t.length) {
        var r = [];
        T(t, function (l) {
            var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
            u instanceof Array && (r = r.concat(u))
        });
        var i = a && a.toolbox;
        B(i) && (i = i[0]), i || (i = {
            feature: {}
        }, a.toolbox = [i]);
        var n = i.feature || (i.feature = {}),
            o = n.brush || (n.brush = {}),
            s = o.type || (o.type = []);
        s.push.apply(s, r), DL(s), e && !s.length && s.push.apply(s, TL)
    }
}

function DL(a) {
    var e = {};
    T(a, function (t) {
        e[t] = 1
    }), a.length = 0, T(e, function (t, r) {
        a.push(r)
    })
}
var kc = T;

function Vc(a) {
    if (a) {
        for (var e in a)
            if (a.hasOwnProperty(e)) return !0
    }
}

function ks(a, e, t) {
    var r = {};
    return kc(e, function (n) {
        var o = r[n] = i();
        kc(a[n], function (s, l) {
            if (Ot.isValidType(l)) {
                var u = {
                    type: l,
                    visual: s
                };
                t && t(u, n), o[l] = new Ot(u), l === "opacity" && (u = ot(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Ot(u))
            }
        })
    }), r;

    function i() {
        var n = function () {};
        n.prototype.__hidden = n.prototype;
        var o = new n;
        return o
    }
}

function Og(a, e, t) {
    var r;
    T(t, function (i) {
        e.hasOwnProperty(i) && Vc(e[i]) && (r = !0)
    }), r && T(t, function (i) {
        e.hasOwnProperty(i) && Vc(e[i]) ? a[i] = ot(e[i]) : delete a[i]
    })
}

function IL(a, e, t, r, i, n) {
    var o = {};
    T(a, function (h) {
        var c = Ot.prepareVisualTypes(e[h]);
        o[h] = c
    });
    var s;

    function l(h) {
        return fp(t, s, h)
    }

    function u(h, c) {
        pp(t, s, h, c)
    }
    n == null ? t.each(v) : t.each([n], v);

    function v(h, c) {
        s = n == null ? h : c;
        var f = t.getRawDataItem(s);
        if (!(f && f.visualMap === !1))
            for (var p = r.call(i, h), d = e[p], g = o[p], y = 0, x = g.length; y < x; y++) {
                var m = g[y];
                d[m] && d[m].applyVisual(h, l, u)
            }
    }
}

function LL(a, e, t, r) {
    var i = {};
    return T(a, function (n) {
        var o = Ot.prepareVisualTypes(e[n]);
        i[n] = o
    }), {
        progress: function (o, s) {
            var l;
            r != null && (l = s.getDimensionIndex(r));

            function u(_) {
                return fp(s, h, _)
            }

            function v(_, b) {
                pp(s, h, _, b)
            }
            for (var h, c = s.getStore();
                (h = o.next()) != null;) {
                var f = s.getRawDataItem(h);
                if (!(f && f.visualMap === !1))
                    for (var p = r != null ? c.get(l, h) : h, d = t(p), g = e[d], y = i[d], x = 0, m = y.length; x < m; x++) {
                        var S = y[x];
                        g[S] && g[S].applyVisual(p, u, v)
                    }
            }
        }
    }
}

function ML(a) {
    var e = a.brushType,
        t = {
            point: function (r) {
                return Oc[e].point(r, t, a)
            },
            rect: function (r) {
                return Oc[e].rect(r, t, a)
            }
        };
    return t
}
var Oc = {
    lineX: zc(0),
    lineY: zc(1),
    rect: {
        point: function (a, e, t) {
            return a && t.boundingRect.contain(a[0], a[1])
        },
        rect: function (a, e, t) {
            return a && t.boundingRect.intersect(a)
        }
    },
    polygon: {
        point: function (a, e, t) {
            return a && t.boundingRect.contain(a[0], a[1]) && rr(t.range, a[0], a[1])
        },
        rect: function (a, e, t) {
            var r = t.range;
            if (!a || r.length <= 1) return !1;
            var i = a.x,
                n = a.y,
                o = a.width,
                s = a.height,
                l = r[0];
            if (rr(r, i, n) || rr(r, i + o, n) || rr(r, i, n + s) || rr(r, i + o, n + s) || gt.create(a).contain(l[0], l[1]) || Qa(i, n, i + o, n, r) || Qa(i, n, i, n + s, r) || Qa(i + o, n, i + o, n + s, r) || Qa(i, n + s, i + o, n + s, r)) return !0
        }
    }
};

function zc(a) {
    var e = ["x", "y"],
        t = ["width", "height"];
    return {
        point: function (r, i, n) {
            if (r) {
                var o = n.range,
                    s = r[a];
                return na(s, o)
            }
        },
        rect: function (r, i, n) {
            if (r) {
                var o = n.range,
                    s = [r[e[a]], r[e[a]] + r[t[a]]];
                return s[1] < s[0] && s.reverse(), na(s[0], o) || na(s[1], o) || na(o[0], s) || na(o[1], s)
            }
        }
    }
}

function na(a, e) {
    return e[0] <= a && a <= e[1]
}
var Nc = ["inBrush", "outOfBrush"],
    Lo = "__ecBrushSelect",
    Vs = "__ecInBrushSelectEvent";

function zg(a) {
    a.eachComponent({
        mainType: "brush"
    }, function (e) {
        var t = e.brushTargetManager = new Kl(e.option, a);
        t.setInputRanges(e.areas, a)
    })
}

function PL(a, e, t) {
    var r = [],
        i, n;
    a.eachComponent({
        mainType: "brush"
    }, function (o) {
        t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : {
            brushType: !1
        })
    }), zg(a), a.eachComponent({
        mainType: "brush"
    }, function (o, s) {
        var l = {
            brushId: o.id,
            brushIndex: s,
            brushName: o.name,
            areas: ot(o.areas),
            selected: []
        };
        r.push(l);
        var u = o.option,
            v = u.brushLink,
            h = [],
            c = [],
            f = [],
            p = !1;
        s || (i = u.throttleType, n = u.throttleDelay);
        var d = G(o.areas, function (_) {
                var b = VL[_.brushType],
                    w = at({
                        boundingRect: b ? b(_) : void 0
                    }, _);
                return w.selectors = ML(w), w
            }),
            g = ks(o.option, Nc, function (_) {
                _.mappingMethod = "fixed"
            });
        B(v) && T(v, function (_) {
            h[_] = 1
        });

        function y(_) {
            return v === "all" || !!h[_]
        }

        function x(_) {
            return !!_.length
        }
        a.eachSeries(function (_, b) {
            var w = f[b] = [];
            _.subType === "parallel" ? m(_, b) : S(_, b, w)
        });

        function m(_, b) {
            var w = _.coordinateSystem;
            p = p || w.hasAxisBrushed(), y(b) && w.eachActiveState(_.getData(), function (A, C) {
                A === "active" && (c[C] = 1)
            })
        }

        function S(_, b, w) {
            if (!(!_.brushSelector || kL(o, b)) && (T(d, function (C) {
                    o.brushTargetManager.controlSeries(C, _, a) && w.push(C), p = p || x(w)
                }), y(b) && x(w))) {
                var A = _.getData();
                A.each(function (C) {
                    Gc(_, w, A, C) && (c[C] = 1)
                })
            }
        }
        a.eachSeries(function (_, b) {
            var w = {
                seriesId: _.id,
                seriesIndex: b,
                seriesName: _.name,
                dataIndex: []
            };
            l.selected.push(w);
            var A = f[b],
                C = _.getData(),
                D = y(b) ? function (I) {
                    return c[I] ? (w.dataIndex.push(C.getRawIndex(I)), "inBrush") : "outOfBrush"
                } : function (I) {
                    return Gc(_, A, C, I) ? (w.dataIndex.push(C.getRawIndex(I)), "inBrush") : "outOfBrush"
                };
            (y(b) ? p : x(A)) && IL(Nc, g, C, D)
        })
    }), RL(e, i, n, r, t)
}

function RL(a, e, t, r, i) {
    if (i) {
        var n = a.getZr();
        if (!n[Vs]) {
            n[Lo] || (n[Lo] = EL);
            var o = Jr(n, Lo, t, e);
            o(a, r)
        }
    }
}

function EL(a, e) {
    if (!a.isDisposed()) {
        var t = a.getZr();
        t[Vs] = !0, a.dispatchAction({
            type: "brushSelect",
            batch: e
        }), t[Vs] = !1
    }
}

function Gc(a, e, t, r) {
    for (var i = 0, n = e.length; i < n; i++) {
        var o = e[i];
        if (a.brushSelector(r, t, o.selectors, o)) return !0
    }
}

function kL(a, e) {
    var t = a.option.seriesIndex;
    return t != null && t !== "all" && (B(t) ? ft(t, e) < 0 : e !== t)
}
var VL = {
    rect: function (a) {
        return Bc(a.range)
    },
    polygon: function (a) {
        for (var e, t = a.range, r = 0, i = t.length; r < i; r++) {
            e = e || [
                [1 / 0, -1 / 0],
                [1 / 0, -1 / 0]
            ];
            var n = t[r];
            n[0] < e[0][0] && (e[0][0] = n[0]), n[0] > e[0][1] && (e[0][1] = n[0]), n[1] < e[1][0] && (e[1][0] = n[1]), n[1] > e[1][1] && (e[1][1] = n[1])
        }
        return e && Bc(e)
    }
};

function Bc(a) {
    return new gt(a[0][0], a[1][0], a[0][1] - a[0][0], a[1][1] - a[1][0])
}
var OL = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.init = function (t, r) {
        this.ecModel = t, this.api = r, this.model, (this._brushController = new Ll(r.getZr())).on("brush", F(this._onBrush, this)).mount()
    }, e.prototype.render = function (t, r, i, n) {
        this.model = t, this._updateController(t, r, i, n)
    }, e.prototype.updateTransform = function (t, r, i, n) {
        zg(r), this._updateController(t, r, i, n)
    }, e.prototype.updateVisual = function (t, r, i, n) {
        this.updateTransform(t, r, i, n)
    }, e.prototype.updateView = function (t, r, i, n) {
        this._updateController(t, r, i, n)
    }, e.prototype._updateController = function (t, r, i, n) {
        (!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice())
    }, e.prototype.dispose = function () {
        this._brushController.dispose()
    }, e.prototype._onBrush = function (t) {
        var r = this.model.id,
            i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
        (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
            type: "brush",
            brushId: r,
            areas: ot(i),
            $from: r
        }), t.isEnd && this.api.dispatchAction({
            type: "brushEnd",
            brushId: r,
            areas: ot(i),
            $from: r
        })
    }, e.type = "brush", e
}(It);
const zL = OL;
var NL = "#ddd",
    GL = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.areas = [], t.brushOption = {}, t
        }
        return e.prototype.optionUpdated = function (t, r) {
            var i = this.option;
            !r && Og(i, t, ["inBrush", "outOfBrush"]);
            var n = i.inBrush = i.inBrush || {};
            i.outOfBrush = i.outOfBrush || {
                color: NL
            }, n.hasOwnProperty("liftZ") || (n.liftZ = 5)
        }, e.prototype.setAreas = function (t) {
            t && (this.areas = G(t, function (r) {
                return Hc(this.option, r)
            }, this))
        }, e.prototype.setBrushOption = function (t) {
            this.brushOption = Hc(this.option, t), this.brushType = this.brushOption.brushType
        }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = {
            seriesIndex: "all",
            brushType: "rect",
            brushMode: "single",
            transformable: !0,
            brushStyle: {
                borderWidth: 1,
                color: "rgba(210,219,238,0.3)",
                borderColor: "#D2DBEE"
            },
            throttleType: "fixRate",
            throttleDelay: 0,
            removeOnClick: !0,
            z: 1e4
        }, e
    }(Ct);

function Hc(a, e) {
    return ct({
        brushType: a.brushType,
        brushMode: a.brushMode,
        transformable: a.transformable,
        brushStyle: new Rt(a.brushStyle).getItemStyle(),
        removeOnClick: a.removeOnClick,
        z: a.z
    }, e, !0)
}
const BL = GL;
var HL = ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
    FL = function (a) {
        E(e, a);

        function e() {
            return a !== null && a.apply(this, arguments) || this
        }
        return e.prototype.render = function (t, r, i) {
            var n, o, s;
            r.eachComponent({
                mainType: "brush"
            }, function (l) {
                n = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length
            }), this._brushType = n, this._brushMode = o, T(t.get("type", !0), function (l) {
                t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === n) ? "emphasis" : "normal")
            })
        }, e.prototype.updateView = function (t, r, i) {
            this.render(t, r, i)
        }, e.prototype.getIcons = function () {
            var t = this.model,
                r = t.get("icon", !0),
                i = {};
            return T(t.get("type", !0), function (n) {
                r[n] && (i[n] = r[n])
            }), i
        }, e.prototype.onclick = function (t, r, i) {
            var n = this._brushType,
                o = this._brushMode;
            i === "clear" ? (r.dispatchAction({
                type: "axisAreaSelect",
                intervals: []
            }), r.dispatchAction({
                type: "brush",
                command: "clear",
                areas: []
            })) : r.dispatchAction({
                type: "takeGlobalCursor",
                key: "brush",
                brushOption: {
                    brushType: i === "keep" ? n : n === i ? !1 : i,
                    brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
                }
            })
        }, e.getDefaultOption = function (t) {
            var r = {
                show: !0,
                type: HL.slice(),
                icon: {
                    rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
                    polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
                    lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
                    lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
                    keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
                    clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
                },
                title: t.getLocaleModel().get(["toolbox", "brush", "title"])
            };
            return r
        }, e
    }(ne);
const WL = FL;

function $L(a) {
    a.registerComponentView(zL), a.registerComponentModel(BL), a.registerPreprocessor(CL), a.registerVisual(a.PRIORITY.VISUAL.BRUSH, PL), a.registerAction({
        type: "brush",
        event: "brush",
        update: "updateVisual"
    }, function (e, t) {
        t.eachComponent({
            mainType: "brush",
            query: e
        }, function (r) {
            r.setAreas(e.areas)
        })
    }), a.registerAction({
        type: "brushSelect",
        event: "brushSelected",
        update: "none"
    }, pe), a.registerAction({
        type: "brushEnd",
        event: "brushEnd",
        update: "none"
    }, pe), Rr("brush", WL)
}
var ZL = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.layoutMode = {
                type: "box",
                ignoreSize: !0
            }, t
        }
        return e.type = "title", e.defaultOption = {
            z: 6,
            show: !0,
            text: "",
            target: "blank",
            subtext: "",
            subtarget: "blank",
            left: 0,
            top: 0,
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            textStyle: {
                fontSize: 18,
                fontWeight: "bold",
                color: "#464646"
            },
            subtextStyle: {
                fontSize: 12,
                color: "#6E7079"
            }
        }, e
    }(Ct),
    UL = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.render = function (t, r, i) {
            if (this.group.removeAll(), !!t.get("show")) {
                var n = this.group,
                    o = t.getModel("textStyle"),
                    s = t.getModel("subtextStyle"),
                    l = t.get("textAlign"),
                    u = Lt(t.get("textBaseline"), t.get("textVerticalAlign")),
                    v = new ut({
                        style: mt(o, {
                            text: t.get("text"),
                            fill: o.getTextColor()
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    }),
                    h = v.getBoundingRect(),
                    c = t.get("subtext"),
                    f = new ut({
                        style: mt(s, {
                            text: c,
                            fill: s.getTextColor(),
                            y: h.height + t.get("itemGap"),
                            verticalAlign: "top"
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    }),
                    p = t.get("link"),
                    d = t.get("sublink"),
                    g = t.get("triggerEvent", !0);
                v.silent = !p && !g, f.silent = !d && !g, p && v.on("click", function () {
                    Ci(p, "_" + t.get("target"))
                }), d && f.on("click", function () {
                    Ci(d, "_" + t.get("subtarget"))
                }), tt(v).eventData = tt(f).eventData = g ? {
                    componentType: "title",
                    componentIndex: t.componentIndex
                } : null, n.add(v), c && n.add(f);
                var y = n.getBoundingRect(),
                    x = t.getBoxLayoutParams();
                x.width = y.width, x.height = y.height;
                var m = kt(x, {
                    width: i.getWidth(),
                    height: i.getHeight()
                }, t.get("padding"));
                l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? m.x += m.width : l === "center" && (m.x += m.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? m.y += m.height : u === "middle" && (m.y += m.height / 2), u = u || "top"), n.x = m.x, n.y = m.y, n.markRedraw();
                var S = {
                    align: l,
                    verticalAlign: u
                };
                v.setStyle(S), f.setStyle(S), y = n.getBoundingRect();
                var _ = m.margin,
                    b = t.getItemStyle(["color", "opacity"]);
                b.fill = t.get("backgroundColor");
                var w = new pt({
                    shape: {
                        x: y.x - _[3],
                        y: y.y - _[0],
                        width: y.width + _[1] + _[3],
                        height: y.height + _[0] + _[2],
                        r: t.get("borderRadius")
                    },
                    style: b,
                    subPixelOptimize: !0,
                    silent: !0
                });
                n.add(w)
            }
        }, e.type = "title", e
    }(It);

function YL(a) {
    a.registerComponentModel(ZL), a.registerComponentView(UL)
}
var Fc = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.layoutMode = "box", t
        }
        return e.prototype.init = function (t, r, i) {
            this.mergeDefaultAndTheme(t, i), this._initData()
        }, e.prototype.mergeOption = function (t) {
            a.prototype.mergeOption.apply(this, arguments), this._initData()
        }, e.prototype.setCurrentIndex = function (t) {
            t == null && (t = this.option.currentIndex);
            var r = this._data.count();
            this.option.loop ? t = (t % r + r) % r : (t >= r && (t = r - 1), t < 0 && (t = 0)), this.option.currentIndex = t
        }, e.prototype.getCurrentIndex = function () {
            return this.option.currentIndex
        }, e.prototype.isIndexMax = function () {
            return this.getCurrentIndex() >= this._data.count() - 1
        }, e.prototype.setPlayState = function (t) {
            this.option.autoPlay = !!t
        }, e.prototype.getPlayState = function () {
            return !!this.option.autoPlay
        }, e.prototype._initData = function () {
            var t = this.option,
                r = t.data || [],
                i = t.axisType,
                n = this._names = [],
                o;
            i === "category" ? (o = [], T(r, function (u, v) {
                var h = Se(t0(u), ""),
                    c;
                St(u) ? (c = ot(u), c.value = v) : c = v, o.push(c), n.push(h)
            })) : o = r;
            var s = {
                    category: "ordinal",
                    time: "time",
                    value: "number"
                } [i] || "number",
                l = this._data = new Qt([{
                    name: "value",
                    type: s
                }], this);
            l.initData(o, n)
        }, e.prototype.getData = function () {
            return this._data
        }, e.prototype.getCategories = function () {
            if (this.get("axisType") === "category") return this._names.slice()
        }, e.type = "timeline", e.defaultOption = {
            z: 4,
            show: !0,
            axisType: "time",
            realtime: !0,
            left: "20%",
            top: null,
            right: "20%",
            bottom: 0,
            width: null,
            height: 40,
            padding: 5,
            controlPosition: "left",
            autoPlay: !1,
            rewind: !1,
            loop: !0,
            playInterval: 2e3,
            currentIndex: 0,
            itemStyle: {},
            label: {
                color: "#000"
            },
            data: []
        }, e
    }(Ct),
    Ng = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.type = "timeline.slider", e.defaultOption = mr(Fc.defaultOption, {
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            orient: "horizontal",
            inverse: !1,
            tooltip: {
                trigger: "item"
            },
            symbol: "circle",
            symbolSize: 12,
            lineStyle: {
                show: !0,
                width: 2,
                color: "#DAE1F5"
            },
            label: {
                position: "auto",
                show: !0,
                interval: "auto",
                rotate: 0,
                color: "#A4B1D7"
            },
            itemStyle: {
                color: "#A4B1D7",
                borderWidth: 1
            },
            checkpointStyle: {
                symbol: "circle",
                symbolSize: 15,
                color: "#316bf3",
                borderColor: "#fff",
                borderWidth: 2,
                shadowBlur: 2,
                shadowOffsetX: 1,
                shadowOffsetY: 1,
                shadowColor: "rgba(0, 0, 0, 0.3)",
                animation: !0,
                animationDuration: 300,
                animationEasing: "quinticInOut"
            },
            controlStyle: {
                show: !0,
                showPlayBtn: !0,
                showPrevBtn: !0,
                showNextBtn: !0,
                itemSize: 24,
                itemGap: 12,
                position: "left",
                playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
                prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
                prevBtnSize: 18,
                nextBtnSize: 18,
                color: "#A4B1D7",
                borderColor: "#A4B1D7",
                borderWidth: 1
            },
            emphasis: {
                label: {
                    show: !0,
                    color: "#6f778d"
                },
                itemStyle: {
                    color: "#316BF3"
                },
                controlStyle: {
                    color: "#316BF3",
                    borderColor: "#316BF3",
                    borderWidth: 2
                }
            },
            progress: {
                lineStyle: {
                    color: "#316BF3"
                },
                itemStyle: {
                    color: "#316BF3"
                },
                label: {
                    color: "#6f778d"
                }
            },
            data: []
        }), e
    }(Fc);
le(Ng, dp.prototype);
const XL = Ng;
var KL = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "timeline", e
}(It);
const qL = KL;
var jL = function (a) {
    E(e, a);

    function e(t, r, i, n) {
        var o = a.call(this, t, r, i) || this;
        return o.type = n || "value", o
    }
    return e.prototype.getLabelModel = function () {
        return this.model.getModel("label")
    }, e.prototype.isHorizontal = function () {
        return this.model.get("orient") === "horizontal"
    }, e
}(ye);
const JL = jL;
var Mo = Math.PI,
    Wc = xt(),
    QL = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function (t, r) {
            this.api = r
        }, e.prototype.render = function (t, r, i) {
            if (this.model = t, this.api = i, this.ecModel = r, this.group.removeAll(), t.get("show", !0)) {
                var n = this._layout(t, i),
                    o = this._createGroup("_mainGroup"),
                    s = this._createGroup("_labelGroup"),
                    l = this._axis = this._createAxis(n, t);
                t.formatTooltip = function (u) {
                    var v = l.scale.getLabel({
                        value: u
                    });
                    return qt("nameValue", {
                        noName: !0,
                        value: v
                    })
                }, T(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (u) {
                    this["_render" + u](n, o, l, t)
                }, this), this._renderAxisLabel(n, s, l, t), this._position(n, t)
            }
            this._doPlayStop(), this._updateTicksStatus()
        }, e.prototype.remove = function () {
            this._clearTimer(), this.group.removeAll()
        }, e.prototype.dispose = function () {
            this._clearTimer()
        }, e.prototype._layout = function (t, r) {
            var i = t.get(["label", "position"]),
                n = t.get("orient"),
                o = eM(t, r),
                s;
            i == null || i === "auto" ? s = n === "horizontal" ? o.y + o.height / 2 < r.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < r.getWidth() / 2 ? "+" : "-" : q(i) ? s = {
                horizontal: {
                    top: "-",
                    bottom: "+"
                },
                vertical: {
                    left: "-",
                    right: "+"
                }
            } [n][i] : s = i;
            var l = {
                    horizontal: "center",
                    vertical: s >= 0 || s === "+" ? "left" : "right"
                },
                u = {
                    horizontal: s >= 0 || s === "+" ? "top" : "bottom",
                    vertical: "middle"
                },
                v = {
                    horizontal: 0,
                    vertical: Mo / 2
                },
                h = n === "vertical" ? o.height : o.width,
                c = t.getModel("controlStyle"),
                f = c.get("show", !0),
                p = f ? c.get("itemSize") : 0,
                d = f ? c.get("itemGap") : 0,
                g = p + d,
                y = t.get(["label", "rotate"]) || 0;
            y = y * Mo / 180;
            var x, m, S, _ = c.get("position", !0),
                b = f && c.get("showPlayBtn", !0),
                w = f && c.get("showPrevBtn", !0),
                A = f && c.get("showNextBtn", !0),
                C = 0,
                D = h;
            _ === "left" || _ === "bottom" ? (b && (x = [0, 0], C += g), w && (m = [C, 0], C += g), A && (S = [D - p, 0], D -= g)) : (b && (x = [D - p, 0], D -= g), w && (m = [0, 0], C += g), A && (S = [D - p, 0], D -= g));
            var I = [C, D];
            return t.get("inverse") && I.reverse(), {
                viewRect: o,
                mainLength: h,
                orient: n,
                rotation: v[n],
                labelRotation: y,
                labelPosOpt: s,
                labelAlign: t.get(["label", "align"]) || l[n],
                labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || u[n],
                playPosition: x,
                prevBtnPosition: m,
                nextBtnPosition: S,
                axisExtent: I,
                controlSize: p,
                controlGap: d
            }
        }, e.prototype._position = function (t, r) {
            var i = this._mainGroup,
                n = this._labelGroup,
                o = t.viewRect;
            if (t.orient === "vertical") {
                var s = yr(),
                    l = o.x,
                    u = o.y + o.height;
                Ge(s, s, [-l, -u]), Ha(s, s, -Mo / 2), Ge(s, s, [l, u]), o = o.clone(), o.applyTransform(s)
            }
            var v = x(o),
                h = x(i.getBoundingRect()),
                c = x(n.getBoundingRect()),
                f = [i.x, i.y],
                p = [n.x, n.y];
            p[0] = f[0] = v[0][0];
            var d = t.labelPosOpt;
            if (d == null || q(d)) {
                var g = d === "+" ? 0 : 1;
                m(f, h, v, 1, g), m(p, c, v, 1, 1 - g)
            } else {
                var g = d >= 0 ? 0 : 1;
                m(f, h, v, 1, g), p[1] = f[1] + d
            }
            i.setPosition(f), n.setPosition(p), i.rotation = n.rotation = t.rotation, y(i), y(n);

            function y(S) {
                S.originX = v[0][0] - S.x, S.originY = v[1][0] - S.y
            }

            function x(S) {
                return [
                    [S.x, S.x + S.width],
                    [S.y, S.y + S.height]
                ]
            }

            function m(S, _, b, w, A) {
                S[w] += b[w][A] - _[w][A]
            }
        }, e.prototype._createAxis = function (t, r) {
            var i = r.getData(),
                n = r.get("axisType"),
                o = tM(r, n);
            o.getTicks = function () {
                return i.mapArray(["value"], function (u) {
                    return {
                        value: u
                    }
                })
            };
            var s = i.getDataExtent("value");
            o.setExtent(s[0], s[1]), o.calcNiceTicks();
            var l = new JL("value", o, t.axisExtent, n);
            return l.model = r, l
        }, e.prototype._createGroup = function (t) {
            var r = this[t] = new U;
            return this.group.add(r), r
        }, e.prototype._renderAxisLine = function (t, r, i, n) {
            var o = i.getExtent();
            if (n.get(["lineStyle", "show"])) {
                var s = new Jt({
                    shape: {
                        x1: o[0],
                        y1: 0,
                        x2: o[1],
                        y2: 0
                    },
                    style: W({
                        lineCap: "round"
                    }, n.getModel("lineStyle").getLineStyle()),
                    silent: !0,
                    z2: 1
                });
                r.add(s);
                var l = this._progressLine = new Jt({
                    shape: {
                        x1: o[0],
                        x2: this._currentPointer ? this._currentPointer.x : o[0],
                        y1: 0,
                        y2: 0
                    },
                    style: at({
                        lineCap: "round",
                        lineWidth: s.style.lineWidth
                    }, n.getModel(["progress", "lineStyle"]).getLineStyle()),
                    silent: !0,
                    z2: 1
                });
                r.add(l)
            }
        }, e.prototype._renderAxisTick = function (t, r, i, n) {
            var o = this,
                s = n.getData(),
                l = i.scale.getTicks();
            this._tickSymbols = [], T(l, function (u) {
                var v = i.dataToCoord(u.value),
                    h = s.getItemModel(u.value),
                    c = h.getModel("itemStyle"),
                    f = h.getModel(["emphasis", "itemStyle"]),
                    p = h.getModel(["progress", "itemStyle"]),
                    d = {
                        x: v,
                        y: 0,
                        onclick: F(o._changeTimeline, o, u.value)
                    },
                    g = $c(h, c, r, d);
                g.ensureState("emphasis").style = f.getItemStyle(), g.ensureState("progress").style = p.getItemStyle(), Nr(g);
                var y = tt(g);
                h.get("tooltip") ? (y.dataIndex = u.value, y.dataModel = n) : y.dataIndex = y.dataModel = null, o._tickSymbols.push(g)
            })
        }, e.prototype._renderAxisLabel = function (t, r, i, n) {
            var o = this,
                s = i.getLabelModel();
            if (s.get("show")) {
                var l = n.getData(),
                    u = i.getViewLabels();
                this._tickLabels = [], T(u, function (v) {
                    var h = v.tickValue,
                        c = l.getItemModel(h),
                        f = c.getModel("label"),
                        p = c.getModel(["emphasis", "label"]),
                        d = c.getModel(["progress", "label"]),
                        g = i.dataToCoord(v.tickValue),
                        y = new ut({
                            x: g,
                            y: 0,
                            rotation: t.labelRotation - t.rotation,
                            onclick: F(o._changeTimeline, o, h),
                            silent: !1,
                            style: mt(f, {
                                text: v.formattedLabel,
                                align: t.labelAlign,
                                verticalAlign: t.labelBaseline
                            })
                        });
                    y.ensureState("emphasis").style = mt(p), y.ensureState("progress").style = mt(d), r.add(y), Nr(y), Wc(y).dataIndex = h, o._tickLabels.push(y)
                })
            }
        }, e.prototype._renderControl = function (t, r, i, n) {
            var o = t.controlSize,
                s = t.rotation,
                l = n.getModel("controlStyle").getItemStyle(),
                u = n.getModel(["emphasis", "controlStyle"]).getItemStyle(),
                v = n.getPlayState(),
                h = n.get("inverse", !0);
            c(t.nextBtnPosition, "next", F(this._changeTimeline, this, h ? "-" : "+")), c(t.prevBtnPosition, "prev", F(this._changeTimeline, this, h ? "+" : "-")), c(t.playPosition, v ? "stop" : "play", F(this._handlePlayClick, this, !v), !0);

            function c(f, p, d, g) {
                if (f) {
                    var y = rs(Lt(n.get(["controlStyle", p + "BtnSize"]), o), o),
                        x = [0, -y / 2, y, y],
                        m = rM(n, p + "Icon", x, {
                            x: f[0],
                            y: f[1],
                            originX: o / 2,
                            originY: 0,
                            rotation: g ? -s : 0,
                            rectHover: !0,
                            style: l,
                            onclick: d
                        });
                    m.ensureState("emphasis").style = u, r.add(m), Nr(m)
                }
            }
        }, e.prototype._renderCurrentPointer = function (t, r, i, n) {
            var o = n.getData(),
                s = n.getCurrentIndex(),
                l = o.getItemModel(s).getModel("checkpointStyle"),
                u = this,
                v = {
                    onCreate: function (h) {
                        h.draggable = !0, h.drift = F(u._handlePointerDrag, u), h.ondragend = F(u._handlePointerDragend, u), Zc(h, u._progressLine, s, i, n, !0)
                    },
                    onUpdate: function (h) {
                        Zc(h, u._progressLine, s, i, n)
                    }
                };
            this._currentPointer = $c(l, l, this._mainGroup, {}, this._currentPointer, v)
        }, e.prototype._handlePlayClick = function (t) {
            this._clearTimer(), this.api.dispatchAction({
                type: "timelinePlayChange",
                playState: t,
                from: this.uid
            })
        }, e.prototype._handlePointerDrag = function (t, r, i) {
            this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
        }, e.prototype._handlePointerDragend = function (t) {
            this._pointerChangeTimeline([t.offsetX, t.offsetY], !0)
        }, e.prototype._pointerChangeTimeline = function (t, r) {
            var i = this._toAxisCoord(t)[0],
                n = this._axis,
                o = oe(n.getExtent().slice());
            i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
            var s = this._progressLine;
            s && (s.shape.x2 = i, s.dirty());
            var l = this._findNearestTick(i),
                u = this.model;
            (r || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l)
        }, e.prototype._doPlayStop = function () {
            var t = this;
            this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function () {
                var r = t.model;
                t._changeTimeline(r.getCurrentIndex() + (r.get("rewind", !0) ? -1 : 1))
            }, this.model.get("playInterval")))
        }, e.prototype._toAxisCoord = function (t) {
            var r = this._mainGroup.getLocalTransform();
            return we(t, r, !0)
        }, e.prototype._findNearestTick = function (t) {
            var r = this.model.getData(),
                i = 1 / 0,
                n, o = this._axis;
            return r.each(["value"], function (s, l) {
                var u = o.dataToCoord(s),
                    v = Math.abs(u - t);
                v < i && (i = v, n = l)
            }), n
        }, e.prototype._clearTimer = function () {
            this._timer && (clearTimeout(this._timer), this._timer = null)
        }, e.prototype._changeTimeline = function (t) {
            var r = this.model.getCurrentIndex();
            t === "+" ? t = r + 1 : t === "-" && (t = r - 1), this.api.dispatchAction({
                type: "timelineChange",
                currentIndex: t,
                from: this.uid
            })
        }, e.prototype._updateTicksStatus = function () {
            var t = this.model.getCurrentIndex(),
                r = this._tickSymbols,
                i = this._tickLabels;
            if (r)
                for (var n = 0; n < r.length; n++) r && r[n] && r[n].toggleState("progress", n < t);
            if (i)
                for (var n = 0; n < i.length; n++) i && i[n] && i[n].toggleState("progress", Wc(i[n]).dataIndex <= t)
        }, e.type = "timeline.slider", e
    }(qL);

function tM(a, e) {
    if (e = e || a.get("type"), e) switch (e) {
        case "category":
            return new a0({
                ordinalMeta: a.getCategories(),
                extent: [1 / 0, -1 / 0]
            });
        case "time":
            return new r0({
                locale: a.ecModel.getLocaleModel(),
                useUTC: a.ecModel.get("useUTC")
            });
        default:
            return new e0
    }
}

function eM(a, e) {
    return kt(a.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
    }, a.get("padding"))
}

function rM(a, e, t, r) {
    var i = r.style,
        n = fn(a.get(["controlStyle", e]), r || {}, new gt(t[0], t[1], t[2], t[3]));
    return i && n.setStyle(i), n
}

function $c(a, e, t, r, i, n) {
    var o = e.get("color");
    if (i) i.setColor(o), t.add(i), n && n.onUpdate(i);
    else {
        var s = a.get("symbol");
        i = Et(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", !0), t.add(i), n && n.onCreate(i)
    }
    var l = e.getItemStyle(["color"]);
    i.setStyle(l), r = ct({
        rectHover: !0,
        z2: 100
    }, r, !0);
    var u = Na(a.get("symbolSize"));
    r.scaleX = u[0] / 2, r.scaleY = u[1] / 2;
    var v = jr(a.get("symbolOffset"), u);
    v && (r.x = (r.x || 0) + v[0], r.y = (r.y || 0) + v[1]);
    var h = a.get("symbolRotate");
    return r.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i
}

function Zc(a, e, t, r, i, n) {
    if (!a.dragging) {
        var o = i.getModel("checkpointStyle"),
            s = r.dataToCoord(i.getData().get("value", t));
        if (n || !o.get("animation", !0)) a.attr({
            x: s,
            y: 0
        }), e && e.attr({
            shape: {
                x2: s
            }
        });
        else {
            var l = {
                duration: o.get("animationDuration", !0),
                easing: o.get("animationEasing", !0)
            };
            a.stopAnimation(null, !0), a.animateTo({
                x: s,
                y: 0
            }, l), e && e.animateTo({
                shape: {
                    x2: s
                }
            }, l)
        }
    }
}
const aM = QL;

function iM(a) {
    a.registerAction({
        type: "timelineChange",
        event: "timelineChanged",
        update: "prepareAndUpdate"
    }, function (e, t, r) {
        var i = t.getComponent("timeline");
        return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), r.dispatchAction({
            type: "timelinePlayChange",
            playState: !1,
            from: e.from
        }))), t.resetOption("timeline", {
            replaceMerge: i.get("replaceMerge", !0)
        }), at({
            currentIndex: i.option.currentIndex
        }, e)
    }), a.registerAction({
        type: "timelinePlayChange",
        event: "timelinePlayChanged",
        update: "update"
    }, function (e, t) {
        var r = t.getComponent("timeline");
        r && e.playState != null && r.setPlayState(e.playState)
    })
}

function nM(a) {
    var e = a && a.timeline;
    B(e) || (e = e ? [e] : []), T(e, function (t) {
        t && oM(t)
    })
}

function oM(a) {
    var e = a.type,
        t = {
            number: "value",
            time: "time"
        };
    if (t[e] && (a.axisType = t[e], delete a.type), Uc(a), nr(a, "controlPosition")) {
        var r = a.controlStyle || (a.controlStyle = {});
        nr(r, "position") || (r.position = a.controlPosition), r.position === "none" && !nr(r, "show") && (r.show = !1, delete r.position), delete a.controlPosition
    }
    T(a.data || [], function (i) {
        St(i) && !B(i) && (!nr(i, "value") && nr(i, "name") && (i.value = i.name), Uc(i))
    })
}

function Uc(a) {
    var e = a.itemStyle || (a.itemStyle = {}),
        t = e.emphasis || (e.emphasis = {}),
        r = a.label || a.label || {},
        i = r.normal || (r.normal = {}),
        n = {
            normal: 1,
            emphasis: 1
        };
    T(r, function (o, s) {
        !n[s] && !nr(i, s) && (i[s] = o)
    }), t.label && !nr(r, "emphasis") && (r.emphasis = t.label, delete t.label)
}

function nr(a, e) {
    return a.hasOwnProperty(e)
}

function sM(a) {
    a.registerComponentModel(XL), a.registerComponentView(aM), a.registerSubTypeDefaulter("timeline", function () {
        return "slider"
    }), iM(a), a.registerPreprocessor(nM)
}

function Jl(a, e) {
    if (!a) return !1;
    for (var t = B(a) ? a : [a], r = 0; r < t.length; r++)
        if (t[r] && t[r][e]) return !0;
    return !1
}

function fi(a) {
    un(a, "label", ["show"])
}
var pi = xt(),
    Gg = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.createdBySelf = !1, t
        }
        return e.prototype.init = function (t, r, i) {
            this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0)
        }, e.prototype.isAnimationEnabled = function () {
            if (Nt.node) return !1;
            var t = this.__hostSeries;
            return this.getShallow("animation") && t && t.isAnimationEnabled()
        }, e.prototype.mergeOption = function (t, r) {
            this._mergeOption(t, r, !1, !1)
        }, e.prototype._mergeOption = function (t, r, i, n) {
            var o = this.mainType;
            i || r.eachSeries(function (s) {
                var l = s.get(this.mainType, !0),
                    u = pi(s)[o];
                if (!l || !l.data) {
                    pi(s)[o] = null;
                    return
                }
                u ? u._mergeOption(l, r, !0) : (n && fi(l), T(l.data, function (v) {
                    v instanceof Array ? (fi(v[0]), fi(v[1])) : fi(v)
                }), u = this.createMarkerModelFromSeries(l, this, r), W(u, {
                    mainType: this.mainType,
                    seriesIndex: s.seriesIndex,
                    name: s.name,
                    createdBySelf: !0
                }), u.__hostSeries = s), pi(s)[o] = u
            }, this)
        }, e.prototype.formatTooltip = function (t, r, i) {
            var n = this.getData(),
                o = this.getRawValue(t),
                s = n.getName(t);
            return qt("section", {
                header: this.name,
                blocks: [qt("nameValue", {
                    name: s,
                    value: o,
                    noName: !s,
                    noValue: o == null
                })]
            })
        }, e.prototype.getData = function () {
            return this._data
        }, e.prototype.setData = function (t) {
            this._data = t
        }, e.getMarkerModelFromSeries = function (t, r) {
            return pi(t)[r]
        }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e
    }(Ct);
le(Gg, dp.prototype);
const We = Gg;
var lM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.createMarkerModelFromSeries = function (t, r, i) {
        return new e(t, r, i)
    }, e.type = "markPoint", e.defaultOption = {
        z: 5,
        symbol: "pin",
        symbolSize: 50,
        tooltip: {
            trigger: "item"
        },
        label: {
            show: !0,
            position: "inside"
        },
        itemStyle: {
            borderWidth: 2
        },
        emphasis: {
            label: {
                show: !0
            }
        }
    }, e
}(We);
const uM = lM;

function Os(a) {
    return !(isNaN(parseFloat(a.x)) && isNaN(parseFloat(a.y)))
}

function vM(a) {
    return !isNaN(parseFloat(a.x)) && !isNaN(parseFloat(a.y))
}

function di(a, e, t, r, i, n) {
    var o = [],
        s = Wr(e, r),
        l = s ? e.getCalculationInfo("stackResultDimension") : r,
        u = Ql(e, l, a),
        v = e.indicesOfNearest(l, u)[0];
    o[i] = e.get(t, v), o[n] = e.get(l, v);
    var h = e.get(r, v),
        c = i0(e.get(r, v));
    return c = Math.min(c, 20), c >= 0 && (o[n] = +o[n].toFixed(c)), [o, h]
}
var Po = {
    min: K(di, "min"),
    max: K(di, "max"),
    average: K(di, "average"),
    median: K(di, "median")
};

function Oa(a, e) {
    if (e) {
        var t = a.getData(),
            r = a.coordinateSystem,
            i = r && r.dimensions;
        if (!vM(e) && !B(e.coord) && B(i)) {
            var n = Bg(e, t, r, a);
            if (e = ot(e), e.type && Po[e.type] && n.baseAxis && n.valueAxis) {
                var o = ft(i, n.baseAxis.dim),
                    s = ft(i, n.valueAxis.dim),
                    l = Po[e.type](t, n.baseDataDim, n.valueDataDim, o, s);
                e.coord = l[0], e.value = l[1]
            } else e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis]
        }
        if (e.coord == null || !B(i)) e.coord = [];
        else
            for (var u = e.coord, v = 0; v < 2; v++) Po[u[v]] && (u[v] = Ql(t, t.mapDimension(i[v]), u[v]));
        return e
    }
}

function Bg(a, e, t, r) {
    var i = {};
    return a.valueIndex != null || a.valueDim != null ? (i.valueDataDim = a.valueIndex != null ? e.getDimension(a.valueIndex) : a.valueDim, i.valueAxis = t.getAxis(hM(r, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i
}

function hM(a, e) {
    var t = a.getData().getDimensionInfo(e);
    return t && t.coordDim
}

function za(a, e) {
    return a && a.containData && e.coord && !Os(e) ? a.containData(e.coord) : !0
}

function cM(a, e, t) {
    return a && a.containZone && e.coord && t.coord && !Os(e) && !Os(t) ? a.containZone(e.coord, t.coord) : !0
}

function Hg(a, e) {
    return a ? function (t, r, i, n) {
        var o = n < 2 ? t.coord && t.coord[n] : t.value;
        return Ii(o, e[n])
    } : function (t, r, i, n) {
        return Ii(t.value, e[n])
    }
}

function Ql(a, e, t) {
    if (t === "average") {
        var r = 0,
            i = 0;
        return a.each(e, function (n, o) {
            isNaN(n) || (r += n, i++)
        }), r / i
    } else return t === "median" ? a.getMedian(e) : a.getDataExtent(e)[t === "max" ? 1 : 0]
}
var Ro = xt(),
    fM = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.init = function () {
            this.markerGroupMap = Q()
        }, e.prototype.render = function (t, r, i) {
            var n = this,
                o = this.markerGroupMap;
            o.each(function (s) {
                Ro(s).keep = !1
            }), r.eachSeries(function (s) {
                var l = We.getMarkerModelFromSeries(s, n.type);
                l && n.renderSeries(s, l, r, i)
            }), o.each(function (s) {
                !Ro(s).keep && n.group.remove(s.group)
            })
        }, e.prototype.markKeep = function (t) {
            Ro(t).keep = !0
        }, e.prototype.toggleBlurSeries = function (t, r) {
            var i = this;
            T(t, function (n) {
                var o = We.getMarkerModelFromSeries(n, i.type);
                if (o) {
                    var s = o.getData();
                    s.eachItemGraphicEl(function (l) {
                        l && (r ? n0(l) : o0(l))
                    })
                }
            })
        }, e.type = "marker", e
    }(It);
const tu = fM;

function Yc(a, e, t) {
    var r = e.coordinateSystem;
    a.each(function (i) {
        var n = a.getItemModel(i),
            o, s = H(n.get("x"), t.getWidth()),
            l = H(n.get("y"), t.getHeight());
        if (!isNaN(s) && !isNaN(l)) o = [s, l];
        else if (e.getMarkerPosition) o = e.getMarkerPosition(a.getValues(a.dimensions, i));
        else if (r) {
            var u = a.get(r.dimensions[0], i),
                v = a.get(r.dimensions[1], i);
            o = r.dataToPoint([u, v])
        }
        isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), a.setItemLayout(i, o)
    })
}
var pM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.updateTransform = function (t, r, i) {
        r.eachSeries(function (n) {
            var o = We.getMarkerModelFromSeries(n, "markPoint");
            o && (Yc(o.getData(), n, i), this.markerGroupMap.get(n.id).updateLayout())
        }, this)
    }, e.prototype.renderSeries = function (t, r, i, n) {
        var o = t.coordinateSystem,
            s = t.id,
            l = t.getData(),
            u = this.markerGroupMap,
            v = u.get(s) || u.set(s, new Ya),
            h = dM(o, t, r);
        r.setData(h), Yc(r.getData(), t, n), h.each(function (c) {
            var f = h.getItemModel(c),
                p = f.getShallow("symbol"),
                d = f.getShallow("symbolSize"),
                g = f.getShallow("symbolRotate"),
                y = f.getShallow("symbolOffset"),
                x = f.getShallow("symbolKeepAspect");
            if (rt(p) || rt(d) || rt(g) || rt(y)) {
                var m = r.getRawValue(c),
                    S = r.getDataParams(c);
                rt(p) && (p = p(m, S)), rt(d) && (d = d(m, S)), rt(g) && (g = g(m, S)), rt(y) && (y = y(m, S))
            }
            var _ = f.getModel("itemStyle").getItemStyle(),
                b = dn(l, "color");
            _.fill || (_.fill = b), h.setItemVisual(c, {
                symbol: p,
                symbolSize: d,
                symbolRotate: g,
                symbolOffset: y,
                symbolKeepAspect: x,
                style: _
            })
        }), v.updateData(h), this.group.add(v.group), h.eachItemGraphicEl(function (c) {
            c.traverse(function (f) {
                tt(f).dataModel = r
            })
        }), this.markKeep(v), v.group.silent = r.get("silent") || t.get("silent")
    }, e.type = "markPoint", e
}(tu);

function dM(a, e, t) {
    var r;
    a ? r = G(a && a.dimensions, function (s) {
        var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
        return W(W({}, l), {
            name: s,
            ordinalMeta: null
        })
    }) : r = [{
        name: "value",
        type: "float"
    }];
    var i = new Qt(r, t),
        n = G(t.get("data"), K(Oa, e));
    a && (n = Dt(n, K(za, a)));
    var o = Hg(!!a, r);
    return i.initData(n, null, o), i
}
const gM = pM;

function yM(a) {
    a.registerComponentModel(uM), a.registerComponentView(gM), a.registerPreprocessor(function (e) {
        Jl(e.series, "markPoint") && (e.markPoint = e.markPoint || {})
    })
}
var mM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.createMarkerModelFromSeries = function (t, r, i) {
        return new e(t, r, i)
    }, e.type = "markLine", e.defaultOption = {
        z: 5,
        symbol: ["circle", "arrow"],
        symbolSize: [8, 16],
        symbolOffset: 0,
        precision: 2,
        tooltip: {
            trigger: "item"
        },
        label: {
            show: !0,
            position: "end",
            distance: 5
        },
        lineStyle: {
            type: "dashed"
        },
        emphasis: {
            label: {
                show: !0
            },
            lineStyle: {
                width: 3
            }
        },
        animationEasing: "linear"
    }, e
}(We);
const xM = mM;
var gi = xt(),
    SM = function (a, e, t, r) {
        var i = a.getData(),
            n;
        if (B(r)) n = r;
        else {
            var o = r.type;
            if (o === "min" || o === "max" || o === "average" || o === "median" || r.xAxis != null || r.yAxis != null) {
                var s = void 0,
                    l = void 0;
                if (r.yAxis != null || r.xAxis != null) s = e.getAxis(r.yAxis != null ? "y" : "x"), l = Ut(r.yAxis, r.xAxis);
                else {
                    var u = Bg(r, i, e, a);
                    s = u.valueAxis;
                    var v = s0(i, u.valueDataDim);
                    l = Ql(i, v, o)
                }
                var h = s.dim === "x" ? 0 : 1,
                    c = 1 - h,
                    f = ot(r),
                    p = {
                        coord: []
                    };
                f.type = null, f.coord = [], f.coord[c] = -1 / 0, p.coord[c] = 1 / 0;
                var d = t.get("precision");
                d >= 0 && te(l) && (l = +l.toFixed(Math.min(d, 20))), f.coord[h] = p.coord[h] = l, n = [f, p, {
                    type: o,
                    valueIndex: r.valueIndex,
                    value: l
                }]
            } else n = []
        }
        var g = [Oa(a, n[0]), Oa(a, n[1]), W({}, n[2])];
        return g[2].type = g[2].type || null, ct(g[2], g[0]), ct(g[2], g[1]), g
    };

function Fi(a) {
    return !isNaN(a) && !isFinite(a)
}

function Xc(a, e, t, r) {
    var i = 1 - a,
        n = r.dimensions[a];
    return Fi(e[i]) && Fi(t[i]) && e[a] === t[a] && r.getAxis(n).containData(e[a])
}

function _M(a, e) {
    if (a.type === "cartesian2d") {
        var t = e[0].coord,
            r = e[1].coord;
        if (t && r && (Xc(1, t, r, a) || Xc(0, t, r, a))) return !0
    }
    return za(a, e[0]) && za(a, e[1])
}

function Eo(a, e, t, r, i) {
    var n = r.coordinateSystem,
        o = a.getItemModel(e),
        s, l = H(o.get("x"), i.getWidth()),
        u = H(o.get("y"), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [l, u];
    else {
        if (r.getMarkerPosition) s = r.getMarkerPosition(a.getValues(a.dimensions, e));
        else {
            var v = n.dimensions,
                h = a.get(v[0], e),
                c = a.get(v[1], e);
            s = n.dataToPoint([h, c])
        }
        if (Ba(n, "cartesian2d")) {
            var f = n.getAxis("x"),
                p = n.getAxis("y"),
                v = n.dimensions;
            Fi(a.get(v[0], e)) ? s[0] = f.toGlobalCoord(f.getExtent()[t ? 0 : 1]) : Fi(a.get(v[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]))
        }
        isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
    }
    a.setItemLayout(e, s)
}
var bM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.updateTransform = function (t, r, i) {
        r.eachSeries(function (n) {
            var o = We.getMarkerModelFromSeries(n, "markLine");
            if (o) {
                var s = o.getData(),
                    l = gi(o).from,
                    u = gi(o).to;
                l.each(function (v) {
                    Eo(l, v, !0, n, i), Eo(u, v, !1, n, i)
                }), s.each(function (v) {
                    s.setItemLayout(v, [l.getItemLayout(v), u.getItemLayout(v)])
                }), this.markerGroupMap.get(n.id).updateLayout()
            }
        }, this)
    }, e.prototype.renderSeries = function (t, r, i, n) {
        var o = t.coordinateSystem,
            s = t.id,
            l = t.getData(),
            u = this.markerGroupMap,
            v = u.get(s) || u.set(s, new wl);
        this.group.add(v.group);
        var h = wM(o, t, r),
            c = h.from,
            f = h.to,
            p = h.line;
        gi(r).from = c, gi(r).to = f, r.setData(p);
        var d = r.get("symbol"),
            g = r.get("symbolSize"),
            y = r.get("symbolRotate"),
            x = r.get("symbolOffset");
        B(d) || (d = [d, d]), B(g) || (g = [g, g]), B(y) || (y = [y, y]), B(x) || (x = [x, x]), h.from.each(function (S) {
            m(c, S, !0), m(f, S, !1)
        }), p.each(function (S) {
            var _ = p.getItemModel(S).getModel("lineStyle").getLineStyle();
            p.setItemLayout(S, [c.getItemLayout(S), f.getItemLayout(S)]), _.stroke == null && (_.stroke = c.getItemVisual(S, "style").fill), p.setItemVisual(S, {
                fromSymbolKeepAspect: c.getItemVisual(S, "symbolKeepAspect"),
                fromSymbolOffset: c.getItemVisual(S, "symbolOffset"),
                fromSymbolRotate: c.getItemVisual(S, "symbolRotate"),
                fromSymbolSize: c.getItemVisual(S, "symbolSize"),
                fromSymbol: c.getItemVisual(S, "symbol"),
                toSymbolKeepAspect: f.getItemVisual(S, "symbolKeepAspect"),
                toSymbolOffset: f.getItemVisual(S, "symbolOffset"),
                toSymbolRotate: f.getItemVisual(S, "symbolRotate"),
                toSymbolSize: f.getItemVisual(S, "symbolSize"),
                toSymbol: f.getItemVisual(S, "symbol"),
                style: _
            })
        }), v.updateData(p), h.line.eachItemGraphicEl(function (S) {
            tt(S).dataModel = r, S.traverse(function (_) {
                tt(_).dataModel = r
            })
        });

        function m(S, _, b) {
            var w = S.getItemModel(_);
            Eo(S, _, b, t, n);
            var A = w.getModel("itemStyle").getItemStyle();
            A.fill == null && (A.fill = dn(l, "color")), S.setItemVisual(_, {
                symbolKeepAspect: w.get("symbolKeepAspect"),
                symbolOffset: Lt(w.get("symbolOffset", !0), x[b ? 0 : 1]),
                symbolRotate: Lt(w.get("symbolRotate", !0), y[b ? 0 : 1]),
                symbolSize: Lt(w.get("symbolSize"), g[b ? 0 : 1]),
                symbol: Lt(w.get("symbol", !0), d[b ? 0 : 1]),
                style: A
            })
        }
        this.markKeep(v), v.group.silent = r.get("silent") || t.get("silent")
    }, e.type = "markLine", e
}(tu);

function wM(a, e, t) {
    var r;
    a ? r = G(a && a.dimensions, function (u) {
        var v = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
        return W(W({}, v), {
            name: u,
            ordinalMeta: null
        })
    }) : r = [{
        name: "value",
        type: "float"
    }];
    var i = new Qt(r, t),
        n = new Qt(r, t),
        o = new Qt([], t),
        s = G(t.get("data"), K(SM, e, a, t));
    a && (s = Dt(s, K(_M, a)));
    var l = Hg(!!a, r);
    return i.initData(G(s, function (u) {
        return u[0]
    }), null, l), n.initData(G(s, function (u) {
        return u[1]
    }), null, l), o.initData(G(s, function (u) {
        return u[2]
    })), o.hasItemOption = !0, {
        from: i,
        to: n,
        line: o
    }
}
const AM = bM;

function TM(a) {
    a.registerComponentModel(xM), a.registerComponentView(AM), a.registerPreprocessor(function (e) {
        Jl(e.series, "markLine") && (e.markLine = e.markLine || {})
    })
}
var CM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.createMarkerModelFromSeries = function (t, r, i) {
        return new e(t, r, i)
    }, e.type = "markArea", e.defaultOption = {
        z: 1,
        tooltip: {
            trigger: "item"
        },
        animation: !1,
        label: {
            show: !0,
            position: "top"
        },
        itemStyle: {
            borderWidth: 0
        },
        emphasis: {
            label: {
                show: !0,
                position: "top"
            }
        }
    }, e
}(We);
const DM = CM;
var yi = xt(),
    IM = function (a, e, t, r) {
        var i = r[0],
            n = r[1];
        if (!(!i || !n)) {
            var o = Oa(a, i),
                s = Oa(a, n),
                l = o.coord,
                u = s.coord;
            l[0] = Ut(l[0], -1 / 0), l[1] = Ut(l[1], -1 / 0), u[0] = Ut(u[0], 1 / 0), u[1] = Ut(u[1], 1 / 0);
            var v = Xs([{}, o, s]);
            return v.coord = [o.coord, s.coord], v.x0 = o.x, v.y0 = o.y, v.x1 = s.x, v.y1 = s.y, v
        }
    };

function Wi(a) {
    return !isNaN(a) && !isFinite(a)
}

function Kc(a, e, t, r) {
    var i = 1 - a;
    return Wi(e[i]) && Wi(t[i])
}

function LM(a, e) {
    var t = e.coord[0],
        r = e.coord[1],
        i = {
            coord: t,
            x: e.x0,
            y: e.y0
        },
        n = {
            coord: r,
            x: e.x1,
            y: e.y1
        };
    return Ba(a, "cartesian2d") ? t && r && (Kc(1, t, r) || Kc(0, t, r)) ? !0 : cM(a, i, n) : za(a, i) || za(a, n)
}

function qc(a, e, t, r, i) {
    var n = r.coordinateSystem,
        o = a.getItemModel(e),
        s, l = H(o.get(t[0]), i.getWidth()),
        u = H(o.get(t[1]), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [l, u];
    else {
        if (r.getMarkerPosition) {
            var v = a.getValues(["x0", "y0"], e),
                h = a.getValues(["x1", "y1"], e),
                c = n.clampData(v),
                f = n.clampData(h),
                p = [];
            t[0] === "x0" ? p[0] = c[0] > f[0] ? h[0] : v[0] : p[0] = c[0] > f[0] ? v[0] : h[0], t[1] === "y0" ? p[1] = c[1] > f[1] ? h[1] : v[1] : p[1] = c[1] > f[1] ? v[1] : h[1], s = r.getMarkerPosition(p, t, !0)
        } else {
            var d = a.get(t[0], e),
                g = a.get(t[1], e),
                y = [d, g];
            n.clampData && n.clampData(y, y), s = n.dataToPoint(y, !0)
        }
        if (Ba(n, "cartesian2d")) {
            var x = n.getAxis("x"),
                m = n.getAxis("y"),
                d = a.get(t[0], e),
                g = a.get(t[1], e);
            Wi(d) ? s[0] = x.toGlobalCoord(x.getExtent()[t[0] === "x0" ? 0 : 1]) : Wi(g) && (s[1] = m.toGlobalCoord(m.getExtent()[t[1] === "y0" ? 0 : 1]))
        }
        isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
    }
    return s
}
var jc = [
        ["x0", "y0"],
        ["x1", "y0"],
        ["x1", "y1"],
        ["x0", "y1"]
    ],
    MM = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.updateTransform = function (t, r, i) {
            r.eachSeries(function (n) {
                var o = We.getMarkerModelFromSeries(n, "markArea");
                if (o) {
                    var s = o.getData();
                    s.each(function (l) {
                        var u = G(jc, function (h) {
                            return qc(s, l, h, n, i)
                        });
                        s.setItemLayout(l, u);
                        var v = s.getItemGraphicEl(l);
                        v.setShape("points", u)
                    })
                }
            }, this)
        }, e.prototype.renderSeries = function (t, r, i, n) {
            var o = t.coordinateSystem,
                s = t.id,
                l = t.getData(),
                u = this.markerGroupMap,
                v = u.get(s) || u.set(s, {
                    group: new U
                });
            this.group.add(v.group), this.markKeep(v);
            var h = PM(o, t, r);
            r.setData(h), h.each(function (c) {
                var f = G(jc, function (A) {
                        return qc(h, c, A, t, n)
                    }),
                    p = o.getAxis("x").scale,
                    d = o.getAxis("y").scale,
                    g = p.getExtent(),
                    y = d.getExtent(),
                    x = [p.parse(h.get("x0", c)), p.parse(h.get("x1", c))],
                    m = [d.parse(h.get("y0", c)), d.parse(h.get("y1", c))];
                oe(x), oe(m);
                var S = !(g[0] > x[1] || g[1] < x[0] || y[0] > m[1] || y[1] < m[0]),
                    _ = !S;
                h.setItemLayout(c, {
                    points: f,
                    allClipped: _
                });
                var b = h.getItemModel(c).getModel("itemStyle").getItemStyle(),
                    w = dn(l, "color");
                b.fill || (b.fill = w, q(b.fill) && (b.fill = Di(b.fill, .4))), b.stroke || (b.stroke = w), h.setItemVisual(c, "style", b)
            }), h.diff(yi(v).data).add(function (c) {
                var f = h.getItemLayout(c);
                if (!f.allClipped) {
                    var p = new de({
                        shape: {
                            points: f.points
                        }
                    });
                    h.setItemGraphicEl(c, p), v.group.add(p)
                }
            }).update(function (c, f) {
                var p = yi(v).data.getItemGraphicEl(f),
                    d = h.getItemLayout(c);
                d.allClipped ? p && v.group.remove(p) : (p ? yt(p, {
                    shape: {
                        points: d.points
                    }
                }, r, c) : p = new de({
                    shape: {
                        points: d.points
                    }
                }), h.setItemGraphicEl(c, p), v.group.add(p))
            }).remove(function (c) {
                var f = yi(v).data.getItemGraphicEl(c);
                v.group.remove(f)
            }).execute(), h.eachItemGraphicEl(function (c, f) {
                var p = h.getItemModel(f),
                    d = h.getItemVisual(f, "style");
                c.useStyle(h.getItemVisual(f, "style")), Xt(c, Gt(p), {
                    labelFetcher: r,
                    labelDataIndex: f,
                    defaultText: h.getName(f) || "",
                    inheritColor: q(d.fill) ? Di(d.fill, 1) : "#000"
                }), ee(c, p), Tt(c, null, null, p.get(["emphasis", "disabled"])), tt(c).dataModel = r
            }), yi(v).data = h, v.group.silent = r.get("silent") || t.get("silent")
        }, e.type = "markArea", e
    }(tu);

function PM(a, e, t) {
    var r, i, n = ["x0", "y0", "x1", "y1"];
    if (a) {
        var o = G(a && a.dimensions, function (u) {
            var v = e.getData(),
                h = v.getDimensionInfo(v.mapDimension(u)) || {};
            return W(W({}, h), {
                name: u,
                ordinalMeta: null
            })
        });
        i = G(n, function (u, v) {
            return {
                name: u,
                type: o[v % 2].type
            }
        }), r = new Qt(i, t)
    } else i = [{
        name: "value",
        type: "float"
    }], r = new Qt(i, t);
    var s = G(t.get("data"), K(IM, e, a, t));
    a && (s = Dt(s, K(LM, a)));
    var l = a ? function (u, v, h, c) {
        var f = u.coord[Math.floor(c / 2)][c % 2];
        return Ii(f, i[c])
    } : function (u, v, h, c) {
        return Ii(u.value, i[c])
    };
    return r.initData(s, null, l), r.hasItemOption = !0, r
}
const RM = MM;

function EM(a) {
    a.registerComponentModel(DM), a.registerComponentView(RM), a.registerPreprocessor(function (e) {
        Jl(e.series, "markArea") && (e.markArea = e.markArea || {})
    })
}
var kM = function (a, e) {
        if (e === "all") return {
            type: "all",
            title: a.getLocaleModel().get(["legend", "selector", "all"])
        };
        if (e === "inverse") return {
            type: "inverse",
            title: a.getLocaleModel().get(["legend", "selector", "inverse"])
        }
    },
    VM = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.layoutMode = {
                type: "box",
                ignoreSize: !0
            }, t
        }
        return e.prototype.init = function (t, r, i) {
            this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t)
        }, e.prototype.mergeOption = function (t, r) {
            a.prototype.mergeOption.call(this, t, r), this._updateSelector(t)
        }, e.prototype._updateSelector = function (t) {
            var r = t.selector,
                i = this.ecModel;
            r === !0 && (r = t.selector = ["all", "inverse"]), B(r) && T(r, function (n, o) {
                q(n) && (n = {
                    type: n
                }), r[o] = ct(n, kM(i, n.type))
            })
        }, e.prototype.optionUpdated = function () {
            this._updateData(this.ecModel);
            var t = this._data;
            if (t[0] && this.get("selectedMode") === "single") {
                for (var r = !1, i = 0; i < t.length; i++) {
                    var n = t[i].get("name");
                    if (this.isSelected(n)) {
                        this.select(n), r = !0;
                        break
                    }
                }!r && this.select(t[0].get("name"))
            }
        }, e.prototype._updateData = function (t) {
            var r = [],
                i = [];
            t.eachRawSeries(function (l) {
                var u = l.name;
                i.push(u);
                var v;
                if (l.legendVisualProvider) {
                    var h = l.legendVisualProvider,
                        c = h.getAllNames();
                    t.isSeriesFiltered(l) || (i = i.concat(c)), c.length ? r = r.concat(c) : v = !0
                } else v = !0;
                v && l0(l) && r.push(l.name)
            }), this._availableNames = i;
            var n = this.get("data") || r,
                o = Q(),
                s = G(n, function (l) {
                    return (q(l) || te(l)) && (l = {
                        name: l
                    }), o.get(l.name) ? null : (o.set(l.name, !0), new Rt(l, this, this.ecModel))
                }, this);
            this._data = Dt(s, function (l) {
                return !!l
            })
        }, e.prototype.getData = function () {
            return this._data
        }, e.prototype.select = function (t) {
            var r = this.option.selected,
                i = this.get("selectedMode");
            if (i === "single") {
                var n = this._data;
                T(n, function (o) {
                    r[o.get("name")] = !1
                })
            }
            r[t] = !0
        }, e.prototype.unSelect = function (t) {
            this.get("selectedMode") !== "single" && (this.option.selected[t] = !1)
        }, e.prototype.toggleSelected = function (t) {
            var r = this.option.selected;
            r.hasOwnProperty(t) || (r[t] = !0), this[r[t] ? "unSelect" : "select"](t)
        }, e.prototype.allSelect = function () {
            var t = this._data,
                r = this.option.selected;
            T(t, function (i) {
                r[i.get("name", !0)] = !0
            })
        }, e.prototype.inverseSelect = function () {
            var t = this._data,
                r = this.option.selected;
            T(t, function (i) {
                var n = i.get("name", !0);
                r.hasOwnProperty(n) || (r[n] = !0), r[n] = !r[n]
            })
        }, e.prototype.isSelected = function (t) {
            var r = this.option.selected;
            return !(r.hasOwnProperty(t) && !r[t]) && ft(this._availableNames, t) >= 0
        }, e.prototype.getOrient = function () {
            return this.get("orient") === "vertical" ? {
                index: 1,
                name: "vertical"
            } : {
                index: 0,
                name: "horizontal"
            }
        }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
            z: 4,
            show: !0,
            orient: "horizontal",
            left: "center",
            top: 0,
            align: "auto",
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderRadius: 0,
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            itemWidth: 25,
            itemHeight: 14,
            symbolRotate: "inherit",
            symbolKeepAspect: !0,
            inactiveColor: "#ccc",
            inactiveBorderColor: "#ccc",
            inactiveBorderWidth: "auto",
            itemStyle: {
                color: "inherit",
                opacity: "inherit",
                borderColor: "inherit",
                borderWidth: "auto",
                borderCap: "inherit",
                borderJoin: "inherit",
                borderDashOffset: "inherit",
                borderMiterLimit: "inherit"
            },
            lineStyle: {
                width: "auto",
                color: "inherit",
                inactiveColor: "#ccc",
                inactiveWidth: 2,
                opacity: "inherit",
                type: "inherit",
                cap: "inherit",
                join: "inherit",
                dashOffset: "inherit",
                miterLimit: "inherit"
            },
            textStyle: {
                color: "#333"
            },
            selectedMode: !0,
            selector: !1,
            selectorLabel: {
                show: !0,
                borderRadius: 10,
                padding: [3, 5, 3, 5],
                fontSize: 12,
                fontFamily: "sans-serif",
                color: "#666",
                borderWidth: 1,
                borderColor: "#666"
            },
            emphasis: {
                selectorLabel: {
                    show: !0,
                    color: "#eee",
                    backgroundColor: "#666"
                }
            },
            selectorPosition: "auto",
            selectorItemGap: 7,
            selectorButtonGap: 10,
            tooltip: {
                show: !1
            }
        }, e
    }(Ct);
const zs = VM;
var Cr = K,
    Ns = T,
    mi = U,
    OM = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.newlineDisabled = !1, t
        }
        return e.prototype.init = function () {
            this.group.add(this._contentGroup = new mi), this.group.add(this._selectorGroup = new mi), this._isFirstRender = !0
        }, e.prototype.getContentGroup = function () {
            return this._contentGroup
        }, e.prototype.getSelectorGroup = function () {
            return this._selectorGroup
        }, e.prototype.render = function (t, r, i) {
            var n = this._isFirstRender;
            if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
                var o = t.get("align"),
                    s = t.get("orient");
                (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
                var l = t.get("selector", !0),
                    u = t.get("selectorPosition", !0);
                l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, r, i, l, s, u);
                var v = t.getBoxLayoutParams(),
                    h = {
                        width: i.getWidth(),
                        height: i.getHeight()
                    },
                    c = t.get("padding"),
                    f = kt(v, h, c),
                    p = this.layoutInner(t, o, f, n, l, u),
                    d = kt(at({
                        width: p.width,
                        height: p.height
                    }, v), h, c);
                this.group.x = d.x - p.x, this.group.y = d.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = Lg(p, t))
            }
        }, e.prototype.resetInner = function () {
            this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll()
        }, e.prototype.renderInner = function (t, r, i, n, o, s, l) {
            var u = this.getContentGroup(),
                v = Q(),
                h = r.get("selectedMode"),
                c = [];
            i.eachRawSeries(function (f) {
                !f.get("legendHoverLink") && c.push(f.id)
            }), Ns(r.getData(), function (f, p) {
                var d = f.get("name");
                if (!this.newlineDisabled && (d === "" || d === `
`)) {
                    var g = new mi;
                    g.newline = !0, u.add(g);
                    return
                }
                var y = i.getSeriesByName(d)[0];
                if (!v.get(d))
                    if (y) {
                        var x = y.getData(),
                            m = x.getVisual("legendLineStyle") || {},
                            S = x.getVisual("legendIcon"),
                            _ = x.getVisual("style"),
                            b = this._createItem(y, d, p, f, r, t, m, _, S, h, n);
                        b.on("click", Cr(Jc, d, null, n, c)).on("mouseover", Cr(Gs, y.name, null, n, c)).on("mouseout", Cr(Bs, y.name, null, n, c)), i.ssr && b.eachChild(function (w) {
                            var A = tt(w);
                            A.seriesIndex = y.seriesIndex, A.dataIndex = p, A.ssrType = "legend"
                        }), v.set(d, !0)
                    } else i.eachRawSeries(function (w) {
                        if (!v.get(d) && w.legendVisualProvider) {
                            var A = w.legendVisualProvider;
                            if (!A.containName(d)) return;
                            var C = A.indexOfName(d),
                                D = A.getItemVisual(C, "style"),
                                I = A.getItemVisual(C, "legendIcon"),
                                L = rp(D.fill);
                            L && L[3] === 0 && (L[3] = .2, D = W(W({}, D), {
                                fill: xi(L, "rgba")
                            }));
                            var M = this._createItem(w, d, p, f, r, t, {}, D, I, h, n);
                            M.on("click", Cr(Jc, null, d, n, c)).on("mouseover", Cr(Gs, null, d, n, c)).on("mouseout", Cr(Bs, null, d, n, c)), i.ssr && M.eachChild(function (P) {
                                var R = tt(P);
                                R.seriesIndex = w.seriesIndex, R.dataIndex = p, R.ssrType = "legend"
                            }), v.set(d, !0)
                        }
                    }, this)
            }, this), o && this._createSelector(o, r, n, s, l)
        }, e.prototype._createSelector = function (t, r, i, n, o) {
            var s = this.getSelectorGroup();
            Ns(t, function (u) {
                var v = u.type,
                    h = new ut({
                        style: {
                            x: 0,
                            y: 0,
                            align: "center",
                            verticalAlign: "middle"
                        },
                        onclick: function () {
                            i.dispatchAction({
                                type: v === "all" ? "legendAllSelect" : "legendInverseSelect"
                            })
                        }
                    });
                s.add(h);
                var c = r.getModel("selectorLabel"),
                    f = r.getModel(["emphasis", "selectorLabel"]);
                Xt(h, {
                    normal: c,
                    emphasis: f
                }, {
                    defaultText: u.title
                }), Nr(h)
            })
        }, e.prototype._createItem = function (t, r, i, n, o, s, l, u, v, h, c) {
            var f = t.visualDrawType,
                p = o.get("itemWidth"),
                d = o.get("itemHeight"),
                g = o.isSelected(r),
                y = n.get("symbolRotate"),
                x = n.get("symbolKeepAspect"),
                m = n.get("icon");
            v = m || v || "roundRect";
            var S = zM(v, n, l, u, f, g, c),
                _ = new mi,
                b = n.getModel("textStyle");
            if (rt(t.getLegendIcon) && (!m || m === "inherit")) _.add(t.getLegendIcon({
                itemWidth: p,
                itemHeight: d,
                icon: v,
                iconRotate: y,
                itemStyle: S.itemStyle,
                lineStyle: S.lineStyle,
                symbolKeepAspect: x
            }));
            else {
                var w = m === "inherit" && t.getData().getVisual("symbol") ? y === "inherit" ? t.getData().getVisual("symbolRotate") : y : 0;
                _.add(NM({
                    itemWidth: p,
                    itemHeight: d,
                    icon: v,
                    iconRotate: w,
                    itemStyle: S.itemStyle,
                    lineStyle: S.lineStyle,
                    symbolKeepAspect: x
                }))
            }
            var A = s === "left" ? p + 5 : -5,
                C = s,
                D = o.get("formatter"),
                I = r;
            q(D) && D ? I = D.replace("{name}", r ? ? "") : rt(D) && (I = D(r));
            var L = g ? b.getTextColor() : n.get("inactiveColor");
            _.add(new ut({
                style: mt(b, {
                    text: I,
                    x: A,
                    y: d / 2,
                    fill: L,
                    align: C,
                    verticalAlign: "middle"
                }, {
                    inheritColor: L
                })
            }));
            var M = new pt({
                    shape: _.getBoundingRect(),
                    style: {
                        fill: "transparent"
                    }
                }),
                P = n.getModel("tooltip");
            return P.get("show") && sn({
                el: M,
                componentModel: o,
                itemName: r,
                itemTooltipOption: P.option
            }), _.add(M), _.eachChild(function (R) {
                R.silent = !0
            }), M.silent = !h, this.getContentGroup().add(_), Nr(_), _.__legendDataIndex = i, _
        }, e.prototype.layoutInner = function (t, r, i, n, o, s) {
            var l = this.getContentGroup(),
                u = this.getSelectorGroup();
            sr(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
            var v = l.getBoundingRect(),
                h = [-v.x, -v.y];
            if (u.markRedraw(), l.markRedraw(), o) {
                sr("horizontal", u, t.get("selectorItemGap", !0));
                var c = u.getBoundingRect(),
                    f = [-c.x, -c.y],
                    p = t.get("selectorButtonGap", !0),
                    d = t.getOrient().index,
                    g = d === 0 ? "width" : "height",
                    y = d === 0 ? "height" : "width",
                    x = d === 0 ? "y" : "x";
                s === "end" ? f[d] += v[g] + p : h[d] += c[g] + p, f[1 - d] += v[y] / 2 - c[y] / 2, u.x = f[0], u.y = f[1], l.x = h[0], l.y = h[1];
                var m = {
                    x: 0,
                    y: 0
                };
                return m[g] = v[g] + p + c[g], m[y] = Math.max(v[y], c[y]), m[x] = Math.min(0, c[x] + f[1 - d]), m
            } else return l.x = h[0], l.y = h[1], this.group.getBoundingRect()
        }, e.prototype.remove = function () {
            this.getContentGroup().removeAll(), this._isFirstRender = !0
        }, e.type = "legend.plain", e
    }(It);

function zM(a, e, t, r, i, n, o) {
    function s(g, y) {
        g.lineWidth === "auto" && (g.lineWidth = y.lineWidth > 0 ? 2 : 0), Ns(g, function (x, m) {
            g[m] === "inherit" && (g[m] = y[m])
        })
    }
    var l = e.getModel("itemStyle"),
        u = l.getItemStyle(),
        v = a.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke",
        h = l.getShallow("decal");
    u.decal = !h || h === "inherit" ? r.decal : on(h, o), u.fill === "inherit" && (u.fill = r[i]), u.stroke === "inherit" && (u.stroke = r[v]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? r : t).opacity), s(u, r);
    var c = e.getModel("lineStyle"),
        f = c.getLineStyle();
    if (s(f, t), u.fill === "auto" && (u.fill = r.fill), u.stroke === "auto" && (u.stroke = r.fill), f.stroke === "auto" && (f.stroke = r.fill), !n) {
        var p = e.get("inactiveBorderWidth"),
            d = u[v];
        u.lineWidth = p === "auto" ? r.lineWidth > 0 && d ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), f.stroke = c.get("inactiveColor"), f.lineWidth = c.get("inactiveWidth")
    }
    return {
        itemStyle: u,
        lineStyle: f
    }
}

function NM(a) {
    var e = a.icon || "roundRect",
        t = Et(e, 0, 0, a.itemWidth, a.itemHeight, a.itemStyle.fill, a.symbolKeepAspect);
    return t.setStyle(a.itemStyle), t.rotation = (a.iconRotate || 0) * Math.PI / 180, t.setOrigin([a.itemWidth / 2, a.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t
}

function Jc(a, e, t, r) {
    Bs(a, e, t, r), t.dispatchAction({
        type: "legendToggleSelect",
        name: a ? ? e
    }), Gs(a, e, t, r)
}

function Fg(a) {
    for (var e = a.getZr().storage.getDisplayList(), t, r = 0, i = e.length; r < i && !(t = e[r].states.emphasis);) r++;
    return t && t.hoverLayer
}

function Gs(a, e, t, r) {
    Fg(t) || t.dispatchAction({
        type: "highlight",
        seriesName: a,
        name: e,
        excludeSeriesId: r
    })
}

function Bs(a, e, t, r) {
    Fg(t) || t.dispatchAction({
        type: "downplay",
        seriesName: a,
        name: e,
        excludeSeriesId: r
    })
}
const Wg = OM;

function GM(a) {
    var e = a.findComponents({
        mainType: "legend"
    });
    e && e.length && a.filterSeries(function (t) {
        for (var r = 0; r < e.length; r++)
            if (!e[r].isSelected(t.name)) return !1;
        return !0
    })
}

function oa(a, e, t) {
    var r = {},
        i = a === "toggleSelected",
        n;
    return t.eachComponent("legend", function (o) {
        i && n != null ? o[n ? "select" : "unSelect"](e.name) : a === "allSelect" || a === "inverseSelect" ? o[a]() : (o[a](e.name), n = o.isSelected(e.name));
        var s = o.getData();
        T(s, function (l) {
            var u = l.get("name");
            if (!(u === `
` || u === "")) {
                var v = o.isSelected(u);
                r.hasOwnProperty(u) ? r[u] = r[u] && v : r[u] = v
            }
        })
    }), a === "allSelect" || a === "inverseSelect" ? {
        selected: r
    } : {
        name: e.name,
        selected: r
    }
}

function BM(a) {
    a.registerAction("legendToggleSelect", "legendselectchanged", K(oa, "toggleSelected")), a.registerAction("legendAllSelect", "legendselectall", K(oa, "allSelect")), a.registerAction("legendInverseSelect", "legendinverseselect", K(oa, "inverseSelect")), a.registerAction("legendSelect", "legendselected", K(oa, "select")), a.registerAction("legendUnSelect", "legendunselected", K(oa, "unSelect"))
}

function $g(a) {
    a.registerComponentModel(zs), a.registerComponentView(Wg), a.registerProcessor(a.PRIORITY.PROCESSOR.SERIES_FILTER, GM), a.registerSubTypeDefaulter("legend", function () {
        return "plain"
    }), BM(a)
}
var HM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.setScrollDataIndex = function (t) {
        this.option.scrollDataIndex = t
    }, e.prototype.init = function (t, r, i) {
        var n = Qi(t);
        a.prototype.init.call(this, t, r, i), Qc(this, t, n)
    }, e.prototype.mergeOption = function (t, r) {
        a.prototype.mergeOption.call(this, t, r), Qc(this, this.option, t)
    }, e.type = "legend.scroll", e.defaultOption = mr(zs.defaultOption, {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: "end",
        pageFormatter: "{current}/{total}",
        pageIcons: {
            horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
            vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
        },
        pageIconColor: "#2f4554",
        pageIconInactiveColor: "#aaa",
        pageIconSize: 15,
        pageTextStyle: {
            color: "#333"
        },
        animationDurationUpdate: 800
    }), e
}(zs);

function Qc(a, e, t) {
    var r = a.getOrient(),
        i = [1, 1];
    i[r.index] = 0, tn(e, t, {
        type: "box",
        ignoreSize: !!i
    })
}
const FM = HM;
var tf = U,
    ko = ["width", "height"],
    Vo = ["x", "y"],
    WM = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t
        }
        return e.prototype.init = function () {
            a.prototype.init.call(this), this.group.add(this._containerGroup = new tf), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new tf)
        }, e.prototype.resetInner = function () {
            a.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null
        }, e.prototype.renderInner = function (t, r, i, n, o, s, l) {
            var u = this;
            a.prototype.renderInner.call(this, t, r, i, n, o, s, l);
            var v = this._controllerGroup,
                h = r.get("pageIconSize", !0),
                c = B(h) ? h : [h, h];
            p("pagePrev", 0);
            var f = r.getModel("pageTextStyle");
            v.add(new ut({
                name: "pageText",
                style: {
                    text: "xx/xx",
                    fill: f.getTextColor(),
                    font: f.getFont(),
                    verticalAlign: "middle",
                    align: "center"
                },
                silent: !0
            })), p("pageNext", 1);

            function p(d, g) {
                var y = d + "DataIndex",
                    x = fn(r.get("pageIcons", !0)[r.getOrient().name][g], {
                        onclick: F(u._pageGo, u, y, r, n)
                    }, {
                        x: -c[0] / 2,
                        y: -c[1] / 2,
                        width: c[0],
                        height: c[1]
                    });
                x.name = d, v.add(x)
            }
        }, e.prototype.layoutInner = function (t, r, i, n, o, s) {
            var l = this.getSelectorGroup(),
                u = t.getOrient().index,
                v = ko[u],
                h = Vo[u],
                c = ko[1 - u],
                f = Vo[1 - u];
            o && sr("horizontal", l, t.get("selectorItemGap", !0));
            var p = t.get("selectorButtonGap", !0),
                d = l.getBoundingRect(),
                g = [-d.x, -d.y],
                y = ot(i);
            o && (y[v] = i[v] - d[v] - p);
            var x = this._layoutContentAndController(t, n, y, u, v, c, f, h);
            if (o) {
                if (s === "end") g[u] += x[v] + p;
                else {
                    var m = d[v] + p;
                    g[u] -= m, x[h] -= m
                }
                x[v] += d[v] + p, g[1 - u] += x[f] + x[c] / 2 - d[c] / 2, x[c] = Math.max(x[c], d[c]), x[f] = Math.min(x[f], d[f] + g[1 - u]), l.x = g[0], l.y = g[1], l.markRedraw()
            }
            return x
        }, e.prototype._layoutContentAndController = function (t, r, i, n, o, s, l, u) {
            var v = this.getContentGroup(),
                h = this._containerGroup,
                c = this._controllerGroup;
            sr(t.get("orient"), v, t.get("itemGap"), n ? i.width : null, n ? null : i.height), sr("horizontal", c, t.get("pageButtonItemGap", !0));
            var f = v.getBoundingRect(),
                p = c.getBoundingRect(),
                d = this._showController = f[o] > i[o],
                g = [-f.x, -f.y];
            r || (g[n] = v[u]);
            var y = [0, 0],
                x = [-p.x, -p.y],
                m = Lt(t.get("pageButtonGap", !0), t.get("itemGap", !0));
            if (d) {
                var S = t.get("pageButtonPosition", !0);
                S === "end" ? x[n] += i[o] - p[o] : y[n] += p[o] + m
            }
            x[1 - n] += f[s] / 2 - p[s] / 2, v.setPosition(g), h.setPosition(y), c.setPosition(x);
            var _ = {
                x: 0,
                y: 0
            };
            if (_[o] = d ? i[o] : f[o], _[s] = Math.max(f[s], p[s]), _[l] = Math.min(0, p[l] + x[1 - n]), h.__rectSize = i[o], d) {
                var b = {
                    x: 0,
                    y: 0
                };
                b[o] = Math.max(i[o] - p[o] - m, 0), b[s] = _[s], h.setClipPath(new pt({
                    shape: b
                })), h.__rectSize = b[o]
            } else c.eachChild(function (A) {
                A.attr({
                    invisible: !0,
                    silent: !0
                })
            });
            var w = this._getPageInfo(t);
            return w.pageIndex != null && yt(v, {
                x: w.contentPosition[0],
                y: w.contentPosition[1]
            }, d ? t : null), this._updatePageInfoView(t, w), _
        }, e.prototype._pageGo = function (t, r, i) {
            var n = this._getPageInfo(r)[t];
            n != null && i.dispatchAction({
                type: "legendScroll",
                scrollDataIndex: n,
                legendId: r.id
            })
        }, e.prototype._updatePageInfoView = function (t, r) {
            var i = this._controllerGroup;
            T(["pagePrev", "pageNext"], function (v) {
                var h = v + "DataIndex",
                    c = r[h] != null,
                    f = i.childOfName(v);
                f && (f.setStyle("fill", c ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), f.cursor = c ? "pointer" : "default")
            });
            var n = i.childOfName("pageText"),
                o = t.get("pageFormatter"),
                s = r.pageIndex,
                l = s != null ? s + 1 : 0,
                u = r.pageCount;
            n && o && n.setStyle("text", q(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
                current: l,
                total: u
            }))
        }, e.prototype._getPageInfo = function (t) {
            var r = t.get("scrollDataIndex", !0),
                i = this.getContentGroup(),
                n = this._containerGroup.__rectSize,
                o = t.getOrient().index,
                s = ko[o],
                l = Vo[o],
                u = this._findTargetItemIndex(r),
                v = i.children(),
                h = v[u],
                c = v.length,
                f = c ? 1 : 0,
                p = {
                    contentPosition: [i.x, i.y],
                    pageCount: f,
                    pageIndex: f - 1,
                    pagePrevDataIndex: null,
                    pageNextDataIndex: null
                };
            if (!h) return p;
            var d = S(h);
            p.contentPosition[o] = -d.s;
            for (var g = u + 1, y = d, x = d, m = null; g <= c; ++g) m = S(v[g]), (!m && x.e > y.s + n || m && !_(m, y.s)) && (x.i > y.i ? y = x : y = m, y && (p.pageNextDataIndex == null && (p.pageNextDataIndex = y.i), ++p.pageCount)), x = m;
            for (var g = u - 1, y = d, x = d, m = null; g >= -1; --g) m = S(v[g]), (!m || !_(x, m.s)) && y.i < x.i && (x = y, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = y.i), ++p.pageCount, ++p.pageIndex), y = m;
            return p;

            function S(b) {
                if (b) {
                    var w = b.getBoundingRect(),
                        A = w[l] + b[l];
                    return {
                        s: A,
                        e: A + w[s],
                        i: b.__legendDataIndex
                    }
                }
            }

            function _(b, w) {
                return b.e >= w && b.s <= w + n
            }
        }, e.prototype._findTargetItemIndex = function (t) {
            if (!this._showController) return 0;
            var r, i = this.getContentGroup(),
                n;
            return i.eachChild(function (o, s) {
                var l = o.__legendDataIndex;
                n == null && l != null && (n = s), l === t && (r = s)
            }), r ? ? n
        }, e.type = "legend.scroll", e
    }(Wg);
const $M = WM;

function ZM(a) {
    a.registerAction("legendScroll", "legendscroll", function (e, t) {
        var r = e.scrollDataIndex;
        r != null && t.eachComponent({
            mainType: "legend",
            subType: "scroll",
            query: e
        }, function (i) {
            i.setScrollDataIndex(r)
        })
    })
}

function UM(a) {
    j($g), a.registerComponentModel(FM), a.registerComponentView($M), ZM(a)
}

function YM(a) {
    j($g), j(UM)
}
var XM = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "dataZoom.inside", e.defaultOption = mr(Va.defaultOption, {
        disabled: !1,
        zoomLock: !1,
        zoomOnMouseWheel: !0,
        moveOnMouseMove: !0,
        moveOnMouseWheel: !1,
        preventDefaultMouseMove: !0
    }), e
}(Va);
const KM = XM;
var eu = xt();

function qM(a, e, t) {
    eu(a).coordSysRecordMap.each(function (r) {
        var i = r.dataZoomInfoMap.get(e.uid);
        i && (i.getRange = t)
    })
}

function jM(a, e) {
    for (var t = eu(a).coordSysRecordMap, r = t.keys(), i = 0; i < r.length; i++) {
        var n = r[i],
            o = t.get(n),
            s = o.dataZoomInfoMap;
        if (s) {
            var l = e.uid,
                u = s.get(l);
            u && (s.removeKey(l), s.keys().length || Zg(t, o))
        }
    }
}

function Zg(a, e) {
    if (e) {
        a.removeKey(e.model.uid);
        var t = e.controller;
        t && t.dispose()
    }
}

function JM(a, e) {
    var t = {
            model: e,
            containsPoint: K(t2, e),
            dispatchAction: K(QM, a),
            dataZoomInfoMap: null,
            controller: null
        },
        r = t.controller = new Ka(a.getZr());
    return T(["pan", "zoom", "scrollMove"], function (i) {
        r.on(i, function (n) {
            var o = [];
            t.dataZoomInfoMap.each(function (s) {
                if (n.isAvailableBehavior(s.model.option)) {
                    var l = (s.getRange || {})[i],
                        u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, n);
                    !s.model.get("disabled", !0) && u && o.push({
                        dataZoomId: s.model.id,
                        start: u[0],
                        end: u[1]
                    })
                }
            }), o.length && t.dispatchAction(o)
        })
    }), t
}

function QM(a, e) {
    a.isDisposed() || a.dispatchAction({
        type: "dataZoom",
        animation: {
            easing: "cubicOut",
            duration: 100
        },
        batch: e
    })
}

function t2(a, e, t, r) {
    return a.coordinateSystem.containPoint([t, r])
}

function e2(a) {
    var e, t = "type_",
        r = {
            type_true: 2,
            type_move: 1,
            type_false: 0,
            type_undefined: -1
        },
        i = !0;
    return a.each(function (n) {
        var o = n.model,
            s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0;
        r[t + s] > r[t + e] && (e = s), i = i && o.get("preventDefaultMouseMove", !0)
    }), {
        controlType: e,
        opt: {
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            moveOnMouseWheel: !0,
            preventDefaultMouseMove: !!i
        }
    }
}

function r2(a) {
    a.registerProcessor(a.PRIORITY.PROCESSOR.FILTER, function (e, t) {
        var r = eu(t),
            i = r.coordSysRecordMap || (r.coordSysRecordMap = Q());
        i.each(function (n) {
            n.dataZoomInfoMap = null
        }), e.eachComponent({
            mainType: "dataZoom",
            subType: "inside"
        }, function (n) {
            var o = Cg(n);
            T(o.infoList, function (s) {
                var l = s.model.uid,
                    u = i.get(l) || i.set(l, JM(t, s.model)),
                    v = u.dataZoomInfoMap || (u.dataZoomInfoMap = Q());
                v.set(n.uid, {
                    dzReferCoordSysInfo: s,
                    model: n,
                    getRange: null
                })
            })
        }), i.each(function (n) {
            var o = n.controller,
                s, l = n.dataZoomInfoMap;
            if (l) {
                var u = l.keys()[0];
                u != null && (s = l.get(u))
            }
            if (!s) {
                Zg(i, n);
                return
            }
            var v = e2(l);
            o.enable(v.controlType, v.opt), o.setPointerChecker(n.containsPoint), Jr(n, "dispatchAction", s.model.get("throttle", !0), "fixRate")
        })
    })
}
var a2 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = "dataZoom.inside", t
        }
        return e.prototype.render = function (t, r, i) {
            if (a.prototype.render.apply(this, arguments), t.noTarget()) {
                this._clear();
                return
            }
            this.range = t.getPercentRange(), qM(i, t, {
                pan: F(Oo.pan, this),
                zoom: F(Oo.zoom, this),
                scrollMove: F(Oo.scrollMove, this)
            })
        }, e.prototype.dispose = function () {
            this._clear(), a.prototype.dispose.apply(this, arguments)
        }, e.prototype._clear = function () {
            jM(this.api, this.dataZoomModel), this.range = null
        }, e.type = "dataZoom.inside", e
    }(Ul),
    Oo = {
        zoom: function (a, e, t, r) {
            var i = this.range,
                n = i.slice(),
                o = a.axisModels[0];
            if (o) {
                var s = zo[e](null, [r.originX, r.originY], o, t, a),
                    l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (n[1] - n[0]) + n[0],
                    u = Math.max(1 / r.scale, 0);
                n[0] = (n[0] - l) * u + l, n[1] = (n[1] - l) * u + l;
                var v = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                if (Sr(0, n, [0, 100], 0, v.minSpan, v.maxSpan), this.range = n, i[0] !== n[0] || i[1] !== n[1]) return n
            }
        },
        pan: ef(function (a, e, t, r, i, n) {
            var o = zo[r]([n.oldX, n.oldY], [n.newX, n.newY], e, i, t);
            return o.signal * (a[1] - a[0]) * o.pixel / o.pixelLength
        }),
        scrollMove: ef(function (a, e, t, r, i, n) {
            var o = zo[r]([0, 0], [n.scrollDelta, n.scrollDelta], e, i, t);
            return o.signal * (a[1] - a[0]) * n.scrollDelta
        })
    };

function ef(a) {
    return function (e, t, r, i) {
        var n = this.range,
            o = n.slice(),
            s = e.axisModels[0];
        if (s) {
            var l = a(o, s, e, t, r, i);
            if (Sr(l, o, [0, 100], "all"), this.range = o, n[0] !== o[0] || n[1] !== o[1]) return o
        }
    }
}
var zo = {
    grid: function (a, e, t, r, i) {
        var n = t.axis,
            o = {},
            s = i.model.coordinateSystem.getRect();
        return a = a || [0, 0], n.dim === "x" ? (o.pixel = e[0] - a[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = n.inverse ? 1 : -1) : (o.pixel = e[1] - a[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = n.inverse ? -1 : 1), o
    },
    polar: function (a, e, t, r, i) {
        var n = t.axis,
            o = {},
            s = i.model.coordinateSystem,
            l = s.getRadiusAxis().getExtent(),
            u = s.getAngleAxis().getExtent();
        return a = a ? s.pointToCoord(a) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - a[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = n.inverse ? 1 : -1) : (o.pixel = e[1] - a[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = n.inverse ? -1 : 1), o
    },
    singleAxis: function (a, e, t, r, i) {
        var n = t.axis,
            o = i.model.coordinateSystem.getRect(),
            s = {};
        return a = a || [0, 0], n.orient === "horizontal" ? (s.pixel = e[0] - a[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = n.inverse ? 1 : -1) : (s.pixel = e[1] - a[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = n.inverse ? -1 : 1), s
    }
};
const i2 = a2;

function Ug(a) {
    Yl(a), a.registerComponentModel(KM), a.registerComponentView(i2), r2(a)
}
var n2 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = mr(Va.defaultOption, {
        show: !0,
        right: "ph",
        top: "ph",
        width: "ph",
        height: "ph",
        left: null,
        bottom: null,
        borderColor: "#d2dbee",
        borderRadius: 3,
        backgroundColor: "rgba(47,69,84,0)",
        dataBackground: {
            lineStyle: {
                color: "#d2dbee",
                width: .5
            },
            areaStyle: {
                color: "#d2dbee",
                opacity: .2
            }
        },
        selectedDataBackground: {
            lineStyle: {
                color: "#8fb0f7",
                width: .5
            },
            areaStyle: {
                color: "#8fb0f7",
                opacity: .2
            }
        },
        fillerColor: "rgba(135,175,274,0.2)",
        handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
        handleSize: "100%",
        handleStyle: {
            color: "#fff",
            borderColor: "#ACB8D1"
        },
        moveHandleSize: 7,
        moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
        moveHandleStyle: {
            color: "#D2DBEE",
            opacity: .7
        },
        showDetail: !0,
        showDataShadow: "auto",
        realtime: !0,
        zoomLock: !1,
        textStyle: {
            color: "#6E7079"
        },
        brushSelect: !0,
        brushStyle: {
            color: "rgba(135,175,274,0.15)"
        },
        emphasis: {
            handleStyle: {
                borderColor: "#8FB0F7"
            },
            moveHandleStyle: {
                color: "#8FB0F7"
            }
        }
    }), e
}(Va);
const o2 = n2;
var sa = pt,
    rf = 7,
    s2 = 1,
    No = 30,
    l2 = 7,
    la = "horizontal",
    af = "vertical",
    u2 = 5,
    v2 = ["line", "bar", "candlestick", "scatter"],
    h2 = {
        easing: "cubicOut",
        duration: 100,
        delay: 0
    },
    c2 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._displayables = {}, t
        }
        return e.prototype.init = function (t, r) {
            this.api = r, this._onBrush = F(this._onBrush, this), this._onBrushEnd = F(this._onBrushEnd, this)
        }, e.prototype.render = function (t, r, i, n) {
            if (a.prototype.render.apply(this, arguments), Jr(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
                this.group.removeAll();
                return
            }
            if (t.noTarget()) {
                this._clear(), this.group.removeAll();
                return
            }(!n || n.type !== "dataZoom" || n.from !== this.uid) && this._buildView(), this._updateView()
        }, e.prototype.dispose = function () {
            this._clear(), a.prototype.dispose.apply(this, arguments)
        }, e.prototype._clear = function () {
            Ta(this, "_dispatchZoomAction");
            var t = this.api.getZr();
            t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd)
        }, e.prototype._buildView = function () {
            var t = this.group;
            t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
            var r = this._displayables.sliderGroup = new U;
            this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(r), this._positionGroup()
        }, e.prototype._resetLocation = function () {
            var t = this.dataZoomModel,
                r = this.api,
                i = t.get("brushSelect"),
                n = i ? l2 : 0,
                o = this._findCoordRect(),
                s = {
                    width: r.getWidth(),
                    height: r.getHeight()
                },
                l = this._orient === la ? {
                    right: s.width - o.x - o.width,
                    top: s.height - No - rf - n,
                    width: o.width,
                    height: No
                } : {
                    right: rf,
                    top: o.y,
                    width: No,
                    height: o.height
                },
                u = Qi(t.option);
            T(["right", "top", "width", "height"], function (h) {
                u[h] === "ph" && (u[h] = l[h])
            });
            var v = kt(u, s);
            this._location = {
                x: v.x,
                y: v.y
            }, this._size = [v.width, v.height], this._orient === af && this._size.reverse()
        }, e.prototype._positionGroup = function () {
            var t = this.group,
                r = this._location,
                i = this._orient,
                n = this.dataZoomModel.getFirstTargetAxisModel(),
                o = n && n.get("inverse"),
                s = this._displayables.sliderGroup,
                l = (this._dataShadowInfo || {}).otherAxisInverse;
            s.attr(i === la && !o ? {
                scaleY: l ? 1 : -1,
                scaleX: 1
            } : i === la && o ? {
                scaleY: l ? 1 : -1,
                scaleX: -1
            } : i === af && !o ? {
                scaleY: l ? -1 : 1,
                scaleX: 1,
                rotation: Math.PI / 2
            } : {
                scaleY: l ? -1 : 1,
                scaleX: -1,
                rotation: Math.PI / 2
            });
            var u = t.getBoundingRect([s]);
            t.x = r.x - u.x, t.y = r.y - u.y, t.markRedraw()
        }, e.prototype._getViewExtent = function () {
            return [0, this._size[0]]
        }, e.prototype._renderBackground = function () {
            var t = this.dataZoomModel,
                r = this._size,
                i = this._displayables.sliderGroup,
                n = t.get("brushSelect");
            i.add(new sa({
                silent: !0,
                shape: {
                    x: 0,
                    y: 0,
                    width: r[0],
                    height: r[1]
                },
                style: {
                    fill: t.get("backgroundColor")
                },
                z2: -40
            }));
            var o = new sa({
                    shape: {
                        x: 0,
                        y: 0,
                        width: r[0],
                        height: r[1]
                    },
                    style: {
                        fill: "transparent"
                    },
                    z2: 0,
                    onclick: F(this._onClickPanel, this)
                }),
                s = this.api.getZr();
            n ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o)
        }, e.prototype._renderDataShadow = function () {
            var t = this._dataShadowInfo = this._prepareDataShadowInfo();
            if (this._displayables.dataShadowSegs = [], !t) return;
            var r = this._size,
                i = this._shadowSize || [],
                n = t.series,
                o = n.getRawData(),
                s = n.getShadowDim && n.getShadowDim(),
                l = s && o.getDimensionInfo(s) ? n.getShadowDim() : t.otherDim;
            if (l == null) return;
            var u = this._shadowPolygonPts,
                v = this._shadowPolylinePts;
            if (o !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) {
                var h = o.getDataExtent(l),
                    c = (h[1] - h[0]) * .3;
                h = [h[0] - c, h[1] + c];
                var f = [0, r[1]],
                    p = [0, r[0]],
                    d = [
                        [r[0], 0],
                        [0, 0]
                    ],
                    g = [],
                    y = p[1] / (o.count() - 1),
                    x = 0,
                    m = Math.round(o.count() / r[0]),
                    S;
                o.each([l], function (C, D) {
                    if (m > 0 && D % m) {
                        x += y;
                        return
                    }
                    var I = C == null || isNaN(C) || C === "",
                        L = I ? 0 : ht(C, h, f, !0);
                    I && !S && D ? (d.push([d[d.length - 1][0], 0]), g.push([g[g.length - 1][0], 0])) : !I && S && (d.push([x, 0]), g.push([x, 0])), d.push([x, L]), g.push([x, L]), x += y, S = I
                }), u = this._shadowPolygonPts = d, v = this._shadowPolylinePts = g
            }
            this._shadowData = o, this._shadowDim = l, this._shadowSize = [r[0], r[1]];
            var _ = this.dataZoomModel;

            function b(C) {
                var D = _.getModel(C ? "selectedDataBackground" : "dataBackground"),
                    I = new U,
                    L = new de({
                        shape: {
                            points: u
                        },
                        segmentIgnoreThreshold: 1,
                        style: D.getModel("areaStyle").getAreaStyle(),
                        silent: !0,
                        z2: -20
                    }),
                    M = new $e({
                        shape: {
                            points: v
                        },
                        segmentIgnoreThreshold: 1,
                        style: D.getModel("lineStyle").getLineStyle(),
                        silent: !0,
                        z2: -19
                    });
                return I.add(L), I.add(M), I
            }
            for (var w = 0; w < 3; w++) {
                var A = b(w === 1);
                this._displayables.sliderGroup.add(A), this._displayables.dataShadowSegs.push(A)
            }
        }, e.prototype._prepareDataShadowInfo = function () {
            var t = this.dataZoomModel,
                r = t.get("showDataShadow");
            if (r !== !1) {
                var i, n = this.ecModel;
                return t.eachTargetAxis(function (o, s) {
                    var l = t.getAxisProxy(o, s).getTargetSeriesModels();
                    T(l, function (u) {
                        if (!i && !(r !== !0 && ft(v2, u.get("type")) < 0)) {
                            var v = n.getComponent(ke(o), s).axis,
                                h = f2(o),
                                c, f = u.coordinateSystem;
                            h != null && f.getOtherAxis && (c = f.getOtherAxis(v).inverse), h = u.getData().mapDimension(h), i = {
                                thisAxis: v,
                                series: u,
                                thisDim: o,
                                otherDim: h,
                                otherAxisInverse: c
                            }
                        }
                    }, this)
                }, this), i
            }
        }, e.prototype._renderHandle = function () {
            var t = this.group,
                r = this._displayables,
                i = r.handles = [null, null],
                n = r.handleLabels = [null, null],
                o = this._displayables.sliderGroup,
                s = this._size,
                l = this.dataZoomModel,
                u = this.api,
                v = l.get("borderRadius") || 0,
                h = l.get("brushSelect"),
                c = r.filler = new sa({
                    silent: h,
                    style: {
                        fill: l.get("fillerColor")
                    },
                    textConfig: {
                        position: "inside"
                    }
                });
            o.add(c), o.add(new sa({
                silent: !0,
                subPixelOptimize: !0,
                shape: {
                    x: 0,
                    y: 0,
                    width: s[0],
                    height: s[1],
                    r: v
                },
                style: {
                    stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
                    lineWidth: s2,
                    fill: "rgba(0,0,0,0)"
                }
            })), T([0, 1], function (m) {
                var S = l.get("handleIcon");
                !u0[S] && S.indexOf("path://") < 0 && S.indexOf("image://") < 0 && (S = "path://" + S);
                var _ = Et(S, -1, 0, 2, 2, null, !0);
                _.attr({
                    cursor: nf(this._orient),
                    draggable: !0,
                    drift: F(this._onDragMove, this, m),
                    ondragend: F(this._onDragEnd, this),
                    onmouseover: F(this._showDataInfo, this, !0),
                    onmouseout: F(this._showDataInfo, this, !1),
                    z2: 5
                });
                var b = _.getBoundingRect(),
                    w = l.get("handleSize");
                this._handleHeight = H(w, this._size[1]), this._handleWidth = b.width / b.height * this._handleHeight, _.setStyle(l.getModel("handleStyle").getItemStyle()), _.style.strokeNoScale = !0, _.rectHover = !0, _.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Nr(_);
                var A = l.get("handleColor");
                A != null && (_.style.fill = A), o.add(i[m] = _);
                var C = l.getModel("textStyle");
                t.add(n[m] = new ut({
                    silent: !0,
                    invisible: !0,
                    style: mt(C, {
                        x: 0,
                        y: 0,
                        text: "",
                        verticalAlign: "middle",
                        align: "center",
                        fill: C.getTextColor(),
                        font: C.getFont()
                    }),
                    z2: 10
                }))
            }, this);
            var f = c;
            if (h) {
                var p = H(l.get("moveHandleSize"), s[1]),
                    d = r.moveHandle = new pt({
                        style: l.getModel("moveHandleStyle").getItemStyle(),
                        silent: !0,
                        shape: {
                            r: [0, 0, 2, 2],
                            y: s[1] - .5,
                            height: p
                        }
                    }),
                    g = p * .8,
                    y = r.moveHandleIcon = Et(l.get("moveHandleIcon"), -g / 2, -g / 2, g, g, "#fff", !0);
                y.silent = !0, y.y = s[1] + p / 2 - .5, d.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
                var x = Math.min(s[1] / 2, Math.max(p, 10));
                f = r.moveZone = new pt({
                    invisible: !0,
                    shape: {
                        y: s[1] - x,
                        height: p + x
                    }
                }), f.on("mouseover", function () {
                    u.enterEmphasis(d)
                }).on("mouseout", function () {
                    u.leaveEmphasis(d)
                }), o.add(d), o.add(y), o.add(f)
            }
            f.attr({
                draggable: !0,
                cursor: nf(this._orient),
                drift: F(this._onDragMove, this, "all"),
                ondragstart: F(this._showDataInfo, this, !0),
                ondragend: F(this._onDragEnd, this),
                onmouseover: F(this._showDataInfo, this, !0),
                onmouseout: F(this._showDataInfo, this, !1)
            })
        }, e.prototype._resetInterval = function () {
            var t = this._range = this.dataZoomModel.getPercentRange(),
                r = this._getViewExtent();
            this._handleEnds = [ht(t[0], [0, 100], r, !0), ht(t[1], [0, 100], r, !0)]
        }, e.prototype._updateInterval = function (t, r) {
            var i = this.dataZoomModel,
                n = this._handleEnds,
                o = this._getViewExtent(),
                s = i.findRepresentativeAxisProxy().getMinMaxSpan(),
                l = [0, 100];
            Sr(r, n, o, i.get("zoomLock") ? "all" : t, s.minSpan != null ? ht(s.minSpan, l, o, !0) : null, s.maxSpan != null ? ht(s.maxSpan, l, o, !0) : null);
            var u = this._range,
                v = this._range = oe([ht(n[0], o, l, !0), ht(n[1], o, l, !0)]);
            return !u || u[0] !== v[0] || u[1] !== v[1]
        }, e.prototype._updateView = function (t) {
            var r = this._displayables,
                i = this._handleEnds,
                n = oe(i.slice()),
                o = this._size;
            T([0, 1], function (f) {
                var p = r.handles[f],
                    d = this._handleHeight;
                p.attr({
                    scaleX: d / 2,
                    scaleY: d / 2,
                    x: i[f] + (f ? -1 : 1),
                    y: o[1] / 2 - d / 2
                })
            }, this), r.filler.setShape({
                x: n[0],
                y: 0,
                width: n[1] - n[0],
                height: o[1]
            });
            var s = {
                x: n[0],
                width: n[1] - n[0]
            };
            r.moveHandle && (r.moveHandle.setShape(s), r.moveZone.setShape(s), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", s.x + s.width / 2));
            for (var l = r.dataShadowSegs, u = [0, n[0], n[1], o[0]], v = 0; v < l.length; v++) {
                var h = l[v],
                    c = h.getClipPath();
                c || (c = new pt, h.setClipPath(c)), c.setShape({
                    x: u[v],
                    y: 0,
                    width: u[v + 1] - u[v],
                    height: o[1]
                })
            }
            this._updateDataInfo(t)
        }, e.prototype._updateDataInfo = function (t) {
            var r = this.dataZoomModel,
                i = this._displayables,
                n = i.handleLabels,
                o = this._orient,
                s = ["", ""];
            if (r.get("showDetail")) {
                var l = r.findRepresentativeAxisProxy();
                if (l) {
                    var u = l.getAxisModel().axis,
                        v = this._range,
                        h = t ? l.calculateDataWindow({
                            start: v[0],
                            end: v[1]
                        }).valueWindow : l.getDataValueWindow();
                    s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)]
                }
            }
            var c = oe(this._handleEnds.slice());
            f.call(this, 0), f.call(this, 1);

            function f(p) {
                var d = zr(i.handles[p].parent, this.group),
                    g = tl(p === 0 ? "right" : "left", d),
                    y = this._handleWidth / 2 + u2,
                    x = we([c[p] + (p === 0 ? -y : y), this._size[1] / 2], d);
                n[p].setStyle({
                    x: x[0],
                    y: x[1],
                    verticalAlign: o === la ? "middle" : g,
                    align: o === la ? g : "center",
                    text: s[p]
                })
            }
        }, e.prototype._formatLabel = function (t, r) {
            var i = this.dataZoomModel,
                n = i.get("labelFormatter"),
                o = i.get("labelPrecision");
            (o == null || o === "auto") && (o = r.getPixelPrecision());
            var s = t == null || isNaN(t) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({
                value: Math.round(t)
            }) : t.toFixed(Math.min(o, 20));
            return rt(n) ? n(t, s) : q(n) ? n.replace("{value}", s) : s
        }, e.prototype._showDataInfo = function (t) {
            t = this._dragging || t;
            var r = this._displayables,
                i = r.handleLabels;
            i[0].attr("invisible", !t), i[1].attr("invisible", !t), r.moveHandle && this.api[t ? "enterEmphasis" : "leaveEmphasis"](r.moveHandle, 1)
        }, e.prototype._onDragMove = function (t, r, i, n) {
            this._dragging = !0, Ne(n.event);
            var o = this._displayables.sliderGroup.getLocalTransform(),
                s = we([r, i], o, !0),
                l = this._updateInterval(t, s[0]),
                u = this.dataZoomModel.get("realtime");
            this._updateView(!u), l && u && this._dispatchZoomAction(!0)
        }, e.prototype._onDragEnd = function () {
            this._dragging = !1, this._showDataInfo(!1);
            var t = this.dataZoomModel.get("realtime");
            !t && this._dispatchZoomAction(!1)
        }, e.prototype._onClickPanel = function (t) {
            var r = this._size,
                i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
            if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) {
                var n = this._handleEnds,
                    o = (n[0] + n[1]) / 2,
                    s = this._updateInterval("all", i[0] - o);
                this._updateView(), s && this._dispatchZoomAction(!1)
            }
        }, e.prototype._onBrushStart = function (t) {
            var r = t.offsetX,
                i = t.offsetY;
            this._brushStart = new _e(r, i), this._brushing = !0, this._brushStartTime = +new Date
        }, e.prototype._onBrushEnd = function (t) {
            if (this._brushing) {
                var r = this._displayables.brushRect;
                if (this._brushing = !1, !!r) {
                    r.attr("ignore", !0);
                    var i = r.shape,
                        n = +new Date;
                    if (!(n - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
                        var o = this._getViewExtent(),
                            s = [0, 100];
                        this._range = oe([ht(i.x, o, s, !0), ht(i.x + i.width, o, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1)
                    }
                }
            }
        }, e.prototype._onBrush = function (t) {
            this._brushing && (Ne(t.event), this._updateBrushRect(t.offsetX, t.offsetY))
        }, e.prototype._updateBrushRect = function (t, r) {
            var i = this._displayables,
                n = this.dataZoomModel,
                o = i.brushRect;
            o || (o = i.brushRect = new sa({
                silent: !0,
                style: n.getModel("brushStyle").getItemStyle()
            }), i.sliderGroup.add(o)), o.attr("ignore", !1);
            var s = this._brushStart,
                l = this._displayables.sliderGroup,
                u = l.transformCoordToLocal(t, r),
                v = l.transformCoordToLocal(s.x, s.y),
                h = this._size;
            u[0] = Math.max(Math.min(h[0], u[0]), 0), o.setShape({
                x: v[0],
                y: 0,
                width: u[0] - v[0],
                height: h[1]
            })
        }, e.prototype._dispatchZoomAction = function (t) {
            var r = this._range;
            this.api.dispatchAction({
                type: "dataZoom",
                from: this.uid,
                dataZoomId: this.dataZoomModel.id,
                animation: t ? h2 : null,
                start: r[0],
                end: r[1]
            })
        }, e.prototype._findCoordRect = function () {
            var t, r = Cg(this.dataZoomModel).infoList;
            if (!t && r.length) {
                var i = r[0].model.coordinateSystem;
                t = i.getRect && i.getRect()
            }
            if (!t) {
                var n = this.api.getWidth(),
                    o = this.api.getHeight();
                t = {
                    x: n * .2,
                    y: o * .2,
                    width: n * .6,
                    height: o * .6
                }
            }
            return t
        }, e.type = "dataZoom.slider", e
    }(Ul);

function f2(a) {
    var e = {
        x: "y",
        y: "x",
        radius: "angle",
        angle: "radius"
    };
    return e[a]
}

function nf(a) {
    return a === "vertical" ? "ns-resize" : "ew-resize"
}
const p2 = c2;

function Yg(a) {
    a.registerComponentModel(o2), a.registerComponentView(p2), Yl(a)
}

function d2(a) {
    j(Ug), j(Yg)
}
var Xg = {
        get: function (a, e, t) {
            var r = ot((g2[a] || {})[e]);
            return t && B(r) ? r[r.length - 1] : r
        }
    },
    g2 = {
        color: {
            active: ["#006edd", "#e0ffff"],
            inactive: ["rgba(0,0,0,0)"]
        },
        colorHue: {
            active: [0, 360],
            inactive: [0, 0]
        },
        colorSaturation: {
            active: [.3, 1],
            inactive: [0, 0]
        },
        colorLightness: {
            active: [.9, .5],
            inactive: [0, 0]
        },
        colorAlpha: {
            active: [.3, 1],
            inactive: [0, 0]
        },
        opacity: {
            active: [.3, 1],
            inactive: [0, 0]
        },
        symbol: {
            active: ["circle", "roundRect", "diamond"],
            inactive: ["none"]
        },
        symbolSize: {
            active: [10, 50],
            inactive: [0, 0]
        }
    },
    of = Ot.mapVisual,
    y2 = Ot.eachVisual,
    m2 = B,
    sf = T,
    x2 = oe,
    S2 = ht,
    $i = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
                type: "box",
                ignoreSize: !0
            }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t
        }
        return e.prototype.init = function (t, r, i) {
            this.mergeDefaultAndTheme(t, i)
        }, e.prototype.optionUpdated = function (t, r) {
            var i = this.option;
            !r && Og(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption()
        }, e.prototype.resetVisual = function (t) {
            var r = this.stateList;
            t = F(t, this), this.controllerVisuals = ks(this.option.controller, r, t), this.targetVisuals = ks(this.option.target, r, t)
        }, e.prototype.getItemSymbol = function () {
            return null
        }, e.prototype.getTargetSeriesIndices = function () {
            var t = this.option.seriesIndex,
                r = [];
            return t == null || t === "all" ? this.ecModel.eachSeries(function (i, n) {
                r.push(n)
            }) : r = Wt(t), r
        }, e.prototype.eachTargetSeries = function (t, r) {
            T(this.getTargetSeriesIndices(), function (i) {
                var n = this.ecModel.getSeriesByIndex(i);
                n && t.call(r, n)
            }, this)
        }, e.prototype.isTargetSeries = function (t) {
            var r = !1;
            return this.eachTargetSeries(function (i) {
                i === t && (r = !0)
            }), r
        }, e.prototype.formatValueText = function (t, r, i) {
            var n = this.option,
                o = n.precision,
                s = this.dataBound,
                l = n.formatter,
                u;
            i = i || ["<", ">"], B(t) && (t = t.slice(), u = !0);
            var v = r ? t : u ? [h(t[0]), h(t[1])] : h(t);
            if (q(l)) return l.replace("{value}", u ? v[0] : v).replace("{value2}", u ? v[1] : v);
            if (rt(l)) return u ? l(t[0], t[1]) : l(t);
            if (u) return t[0] === s[0] ? i[0] + " " + v[1] : t[1] === s[1] ? i[1] + " " + v[0] : v[0] + " - " + v[1];
            return v;

            function h(c) {
                return c === s[0] ? "min" : c === s[1] ? "max" : (+c).toFixed(Math.min(o, 20))
            }
        }, e.prototype.resetExtent = function () {
            var t = this.option,
                r = x2([t.min, t.max]);
            this._dataExtent = r
        }, e.prototype.getDataDimensionIndex = function (t) {
            var r = this.option.dimension;
            if (r != null) return t.getDimensionIndex(r);
            for (var i = t.dimensions, n = i.length - 1; n >= 0; n--) {
                var o = i[n],
                    s = t.getDimensionInfo(o);
                if (!s.isCalculationCoord) return s.storeDimIndex
            }
        }, e.prototype.getExtent = function () {
            return this._dataExtent.slice()
        }, e.prototype.completeVisualOption = function () {
            var t = this.ecModel,
                r = this.option,
                i = {
                    inRange: r.inRange,
                    outOfRange: r.outOfRange
                },
                n = r.target || (r.target = {}),
                o = r.controller || (r.controller = {});
            ct(n, i), ct(o, i);
            var s = this.isCategory();
            l.call(this, n), l.call(this, o), u.call(this, n, "inRange", "outOfRange"), v.call(this, o);

            function l(h) {
                m2(r.color) && !h.inRange && (h.inRange = {
                    color: r.color.slice().reverse()
                }), h.inRange = h.inRange || {
                    color: t.get("gradientColor")
                }
            }

            function u(h, c, f) {
                var p = h[c],
                    d = h[f];
                p && !d && (d = h[f] = {}, sf(p, function (g, y) {
                    if (Ot.isValidType(y)) {
                        var x = Xg.get(y, "inactive", s);
                        x != null && (d[y] = x, y === "color" && !d.hasOwnProperty("opacity") && !d.hasOwnProperty("colorAlpha") && (d.opacity = [0, 0]))
                    }
                }))
            }

            function v(h) {
                var c = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol,
                    f = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize,
                    p = this.get("inactiveColor"),
                    d = this.getItemSymbol(),
                    g = d || "roundRect";
                sf(this.stateList, function (y) {
                    var x = this.itemSize,
                        m = h[y];
                    m || (m = h[y] = {
                        color: s ? p : [p]
                    }), m.symbol == null && (m.symbol = c && ot(c) || (s ? g : [g])), m.symbolSize == null && (m.symbolSize = f && ot(f) || (s ? x[0] : [x[0], x[0]])), m.symbol = of (m.symbol, function (b) {
                        return b === "none" ? g : b
                    });
                    var S = m.symbolSize;
                    if (S != null) {
                        var _ = -1 / 0;
                        y2(S, function (b) {
                            b > _ && (_ = b)
                        }), m.symbolSize = of (S, function (b) {
                            return S2(b, [0, _], [0, x[0]], !0)
                        })
                    }
                }, this)
            }
        }, e.prototype.resetItemSize = function () {
            this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
        }, e.prototype.isCategory = function () {
            return !!this.option.categories
        }, e.prototype.setSelected = function (t) {}, e.prototype.getSelected = function () {
            return null
        }, e.prototype.getValueState = function (t) {
            return null
        }, e.prototype.getVisualMeta = function (t) {
            return null
        }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
            show: !0,
            z: 4,
            seriesIndex: "all",
            min: 0,
            max: 200,
            left: 0,
            right: null,
            top: null,
            bottom: 0,
            itemWidth: null,
            itemHeight: null,
            inverse: !1,
            orient: "vertical",
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            contentColor: "#5793f3",
            inactiveColor: "#aaa",
            borderWidth: 0,
            padding: 5,
            textGap: 10,
            precision: 0,
            textStyle: {
                color: "#333"
            }
        }, e
    }(Ct),
    lf = [20, 140],
    _2 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t
        }
        return e.prototype.optionUpdated = function (t, r) {
            a.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function (i) {
                i.mappingMethod = "linear", i.dataExtent = this.getExtent()
            }), this._resetRange()
        }, e.prototype.resetItemSize = function () {
            a.prototype.resetItemSize.apply(this, arguments);
            var t = this.itemSize;
            (t[0] == null || isNaN(t[0])) && (t[0] = lf[0]), (t[1] == null || isNaN(t[1])) && (t[1] = lf[1])
        }, e.prototype._resetRange = function () {
            var t = this.getExtent(),
                r = this.option.range;
            !r || r.auto ? (t.auto = 1, this.option.range = t) : B(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], t[0]), r[1] = Math.min(r[1], t[1]))
        }, e.prototype.completeVisualOption = function () {
            a.prototype.completeVisualOption.apply(this, arguments), T(this.stateList, function (t) {
                var r = this.option.controller[t].symbolSize;
                r && r[0] !== r[1] && (r[0] = r[1] / 3)
            }, this)
        }, e.prototype.setSelected = function (t) {
            this.option.range = t.slice(), this._resetRange()
        }, e.prototype.getSelected = function () {
            var t = this.getExtent(),
                r = oe((this.get("range") || []).slice());
            return r[0] > t[1] && (r[0] = t[1]), r[1] > t[1] && (r[1] = t[1]), r[0] < t[0] && (r[0] = t[0]), r[1] < t[0] && (r[1] = t[0]), r
        }, e.prototype.getValueState = function (t) {
            var r = this.option.range,
                i = this.getExtent();
            return (r[0] <= i[0] || r[0] <= t) && (r[1] >= i[1] || t <= r[1]) ? "inRange" : "outOfRange"
        }, e.prototype.findTargetDataIndices = function (t) {
            var r = [];
            return this.eachTargetSeries(function (i) {
                var n = [],
                    o = i.getData();
                o.each(this.getDataDimensionIndex(o), function (s, l) {
                    t[0] <= s && s <= t[1] && n.push(l)
                }, this), r.push({
                    seriesId: i.id,
                    dataIndex: n
                })
            }, this), r
        }, e.prototype.getVisualMeta = function (t) {
            var r = uf(this, "outOfRange", this.getExtent()),
                i = uf(this, "inRange", this.option.range.slice()),
                n = [];

            function o(f, p) {
                n.push({
                    value: f,
                    color: t(f, p)
                })
            }
            for (var s = 0, l = 0, u = i.length, v = r.length; l < v && (!i.length || r[l] <= i[0]); l++) r[l] < i[s] && o(r[l], "outOfRange");
            for (var h = 1; s < u; s++, h = 0) h && n.length && o(i[s], "outOfRange"), o(i[s], "inRange");
            for (var h = 1; l < v; l++)(!i.length || i[i.length - 1] < r[l]) && (h && (n.length && o(n[n.length - 1].value, "outOfRange"), h = 0), o(r[l], "outOfRange"));
            var c = n.length;
            return {
                stops: n,
                outerColors: [c ? n[0].color : "transparent", c ? n[c - 1].color : "transparent"]
            }
        }, e.type = "visualMap.continuous", e.defaultOption = mr($i.defaultOption, {
            align: "auto",
            calculable: !1,
            hoverLink: !0,
            realtime: !0,
            handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
            handleSize: "120%",
            handleStyle: {
                borderColor: "#fff",
                borderWidth: 1
            },
            indicatorIcon: "circle",
            indicatorSize: "50%",
            indicatorStyle: {
                borderColor: "#fff",
                borderWidth: 2,
                shadowBlur: 2,
                shadowOffsetX: 1,
                shadowOffsetY: 1,
                shadowColor: "rgba(0,0,0,0.2)"
            }
        }), e
    }($i);

function uf(a, e, t) {
    if (t[0] === t[1]) return t.slice();
    for (var r = 200, i = (t[1] - t[0]) / r, n = t[0], o = [], s = 0; s <= r && n < t[1]; s++) o.push(n), n += i;
    return o.push(t[1]), o
}
const b2 = _2;
var w2 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t.autoPositionValues = {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1
        }, t
    }
    return e.prototype.init = function (t, r) {
        this.ecModel = t, this.api = r
    }, e.prototype.render = function (t, r, i, n) {
        if (this.visualMapModel = t, t.get("show") === !1) {
            this.group.removeAll();
            return
        }
        this.doRender(t, r, i, n)
    }, e.prototype.renderBackground = function (t) {
        var r = this.visualMapModel,
            i = pn(r.get("padding") || 0),
            n = t.getBoundingRect();
        t.add(new pt({
            z2: -1,
            silent: !0,
            shape: {
                x: n.x - i[3],
                y: n.y - i[0],
                width: n.width + i[3] + i[1],
                height: n.height + i[0] + i[2]
            },
            style: {
                fill: r.get("backgroundColor"),
                stroke: r.get("borderColor"),
                lineWidth: r.get("borderWidth")
            }
        }))
    }, e.prototype.getControllerVisual = function (t, r, i) {
        i = i || {};
        var n = i.forceState,
            o = this.visualMapModel,
            s = {};
        if (r === "color") {
            var l = o.get("contentColor");
            s.color = l
        }

        function u(f) {
            return s[f]
        }

        function v(f, p) {
            s[f] = p
        }
        var h = o.controllerVisuals[n || o.getValueState(t)],
            c = Ot.prepareVisualTypes(h);
        return T(c, function (f) {
            var p = h[f];
            i.convertOpacityToAlpha && f === "opacity" && (f = "colorAlpha", p = h.__alphaForOpacity), Ot.dependsOn(f, r) && p && p.applyVisual(t, u, v)
        }), s[r]
    }, e.prototype.positionGroup = function (t) {
        var r = this.visualMapModel,
            i = this.api;
        hn(t, r.getBoxLayoutParams(), {
            width: i.getWidth(),
            height: i.getHeight()
        })
    }, e.prototype.doRender = function (t, r, i, n) {}, e.type = "visualMap", e
}(It);
const Kg = w2;
var vf = [
    ["left", "right", "width"],
    ["top", "bottom", "height"]
];

function qg(a, e, t) {
    var r = a.option,
        i = r.align;
    if (i != null && i !== "auto") return i;
    for (var n = {
            width: e.getWidth(),
            height: e.getHeight()
        }, o = r.orient === "horizontal" ? 1 : 0, s = vf[o], l = [0, null, 10], u = {}, v = 0; v < 3; v++) u[vf[1 - o][v]] = l[v], u[s[v]] = v === 2 ? t[0] : r[s[v]];
    var h = [
            ["x", "width", 3],
            ["y", "height", 0]
        ][o],
        c = kt(u, n, r.padding);
    return s[(c.margin[h[2]] || 0) + c[h[0]] + c[h[1]] * .5 < n[h[1]] * .5 ? 0 : 1]
}

function Ai(a, e) {
    return T(a || [], function (t) {
        t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "")
    }), a
}
var ce = ht,
    A2 = T,
    hf = Math.min,
    Go = Math.max,
    T2 = 12,
    C2 = 6,
    D2 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t
        }
        return e.prototype.init = function (t, r) {
            a.prototype.init.call(this, t, r), this._hoverLinkFromSeriesMouseOver = F(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = F(this._hideIndicator, this)
        }, e.prototype.doRender = function (t, r, i, n) {
            (!n || n.type !== "selectDataRange" || n.from !== this.uid) && this._buildView()
        }, e.prototype._buildView = function () {
            this.group.removeAll();
            var t = this.visualMapModel,
                r = this.group;
            this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(r);
            var i = t.get("text");
            this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(!0), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r)
        }, e.prototype._renderEndsText = function (t, r, i) {
            if (r) {
                var n = r[1 - i];
                n = n != null ? n + "" : "";
                var o = this.visualMapModel,
                    s = o.get("textGap"),
                    l = o.itemSize,
                    u = this._shapes.mainGroup,
                    v = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u),
                    h = this._applyTransform(i === 0 ? "bottom" : "top", u),
                    c = this._orient,
                    f = this.visualMapModel.textStyleModel;
                this.group.add(new ut({
                    style: mt(f, {
                        x: v[0],
                        y: v[1],
                        verticalAlign: c === "horizontal" ? "middle" : h,
                        align: c === "horizontal" ? h : "center",
                        text: n
                    })
                }))
            }
        }, e.prototype._renderBar = function (t) {
            var r = this.visualMapModel,
                i = this._shapes,
                n = r.itemSize,
                o = this._orient,
                s = this._useHandle,
                l = qg(r, this.api, n),
                u = i.mainGroup = this._createBarGroup(l),
                v = new U;
            u.add(v), v.add(i.outOfRange = cf()), v.add(i.inRange = cf(null, s ? pf(this._orient) : null, F(this._dragHandle, this, "all", !1), F(this._dragHandle, this, "all", !0))), v.setClipPath(new pt({
                shape: {
                    x: 0,
                    y: 0,
                    width: n[0],
                    height: n[1],
                    r: 3
                }
            }));
            var h = r.textStyleModel.getTextRect("å›½"),
                c = Go(h.width, h.height);
            s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, u, 0, n, c, o), this._createHandle(r, u, 1, n, c, o)), this._createIndicator(r, u, n, c, o), t.add(u)
        }, e.prototype._createHandle = function (t, r, i, n, o, s) {
            var l = F(this._dragHandle, this, i, !1),
                u = F(this._dragHandle, this, i, !0),
                v = rs(t.get("handleSize"), n[0]),
                h = Et(t.get("handleIcon"), -v / 2, -v / 2, v, v, null, !0),
                c = pf(this._orient);
            h.attr({
                cursor: c,
                draggable: !0,
                drift: l,
                ondragend: u,
                onmousemove: function (y) {
                    Ne(y.event)
                }
            }), h.x = n[0] / 2, h.useStyle(t.getModel("handleStyle").getItemStyle()), h.setStyle({
                strokeNoScale: !0,
                strokeFirst: !0
            }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), va(h, !0), r.add(h);
            var f = this.visualMapModel.textStyleModel,
                p = new ut({
                    cursor: c,
                    draggable: !0,
                    drift: l,
                    onmousemove: function (y) {
                        Ne(y.event)
                    },
                    ondragend: u,
                    style: mt(f, {
                        x: 0,
                        y: 0,
                        text: ""
                    })
                });
            p.ensureState("blur").style = {
                opacity: .1
            }, p.stateTransition = {
                duration: 200
            }, this.group.add(p);
            var d = [v, 0],
                g = this._shapes;
            g.handleThumbs[i] = h, g.handleLabelPoints[i] = d, g.handleLabels[i] = p
        }, e.prototype._createIndicator = function (t, r, i, n, o) {
            var s = rs(t.get("indicatorSize"), i[0]),
                l = Et(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
            l.attr({
                cursor: "move",
                invisible: !0,
                silent: !0,
                x: i[0] / 2
            });
            var u = t.getModel("indicatorStyle").getItemStyle();
            if (l instanceof ge) {
                var v = l.style;
                l.useStyle(W({
                    image: v.image,
                    x: v.x,
                    y: v.y,
                    width: v.width,
                    height: v.height
                }, u))
            } else l.useStyle(u);
            r.add(l);
            var h = this.visualMapModel.textStyleModel,
                c = new ut({
                    silent: !0,
                    invisible: !0,
                    style: mt(h, {
                        x: 0,
                        y: 0,
                        text: ""
                    })
                });
            this.group.add(c);
            var f = [(o === "horizontal" ? n / 2 : C2) + i[0] / 2, 0],
                p = this._shapes;
            p.indicator = l, p.indicatorLabel = c, p.indicatorLabelPoint = f, this._firstShowIndicator = !0
        }, e.prototype._dragHandle = function (t, r, i, n) {
            if (this._useHandle) {
                if (this._dragging = !r, !r) {
                    var o = this._applyTransform([i, n], this._shapes.mainGroup, !0);
                    this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView()
                }
                r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: this._dataInterval.slice()
                }), r ? !this._hovering && this._clearHoverLinkToSeries() : ff(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1)
            }
        }, e.prototype._resetInterval = function () {
            var t = this.visualMapModel,
                r = this._dataInterval = t.getSelected(),
                i = t.getExtent(),
                n = [0, t.itemSize[1]];
            this._handleEnds = [ce(r[0], i, n, !0), ce(r[1], i, n, !0)]
        }, e.prototype._updateInterval = function (t, r) {
            r = r || 0;
            var i = this.visualMapModel,
                n = this._handleEnds,
                o = [0, i.itemSize[1]];
            Sr(r, n, o, t, 0);
            var s = i.getExtent();
            this._dataInterval = [ce(n[0], o, s, !0), ce(n[1], o, s, !0)]
        }, e.prototype._updateView = function (t) {
            var r = this.visualMapModel,
                i = r.getExtent(),
                n = this._shapes,
                o = [0, r.itemSize[1]],
                s = t ? o : this._handleEnds,
                l = this._createBarVisual(this._dataInterval, i, s, "inRange"),
                u = this._createBarVisual(i, i, o, "outOfRange");
            n.inRange.setStyle({
                fill: l.barColor
            }).setShape("points", l.barPoints), n.outOfRange.setStyle({
                fill: u.barColor
            }).setShape("points", u.barPoints), this._updateHandle(s, l)
        }, e.prototype._createBarVisual = function (t, r, i, n) {
            var o = {
                    forceState: n,
                    convertOpacityToAlpha: !0
                },
                s = this._makeColorGradient(t, o),
                l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)],
                u = this._createBarPoints(i, l);
            return {
                barColor: new qi(0, 0, 0, 1, s),
                barPoints: u,
                handlesColor: [s[0].color, s[s.length - 1].color]
            }
        }, e.prototype._makeColorGradient = function (t, r) {
            var i = 100,
                n = [],
                o = (t[1] - t[0]) / i;
            n.push({
                color: this.getControllerVisual(t[0], "color", r),
                offset: 0
            });
            for (var s = 1; s < i; s++) {
                var l = t[0] + o * s;
                if (l > t[1]) break;
                n.push({
                    color: this.getControllerVisual(l, "color", r),
                    offset: s / i
                })
            }
            return n.push({
                color: this.getControllerVisual(t[1], "color", r),
                offset: 1
            }), n
        }, e.prototype._createBarPoints = function (t, r) {
            var i = this.visualMapModel.itemSize;
            return [
                [i[0] - r[0], t[0]],
                [i[0], t[0]],
                [i[0], t[1]],
                [i[0] - r[1], t[1]]
            ]
        }, e.prototype._createBarGroup = function (t) {
            var r = this._orient,
                i = this.visualMapModel.get("inverse");
            return new U(r === "horizontal" && !i ? {
                scaleX: t === "bottom" ? 1 : -1,
                rotation: Math.PI / 2
            } : r === "horizontal" && i ? {
                scaleX: t === "bottom" ? -1 : 1,
                rotation: -Math.PI / 2
            } : r === "vertical" && !i ? {
                scaleX: t === "left" ? 1 : -1,
                scaleY: -1
            } : {
                scaleX: t === "left" ? 1 : -1
            })
        }, e.prototype._updateHandle = function (t, r) {
            if (this._useHandle) {
                var i = this._shapes,
                    n = this.visualMapModel,
                    o = i.handleThumbs,
                    s = i.handleLabels,
                    l = n.itemSize,
                    u = n.getExtent();
                A2([0, 1], function (v) {
                    var h = o[v];
                    h.setStyle("fill", r.handlesColor[v]), h.y = t[v];
                    var c = ce(t[v], [0, l[1]], u, !0),
                        f = this.getControllerVisual(c, "symbolSize");
                    h.scaleX = h.scaleY = f / l[0], h.x = l[0] - f / 2;
                    var p = we(i.handleLabelPoints[v], zr(h, this.group));
                    s[v].setStyle({
                        x: p[0],
                        y: p[1],
                        text: n.formatValueText(this._dataInterval[v]),
                        verticalAlign: "middle",
                        align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
                    })
                }, this)
            }
        }, e.prototype._showIndicator = function (t, r, i, n) {
            var o = this.visualMapModel,
                s = o.getExtent(),
                l = o.itemSize,
                u = [0, l[1]],
                v = this._shapes,
                h = v.indicator;
            if (h) {
                h.attr("invisible", !1);
                var c = {
                        convertOpacityToAlpha: !0
                    },
                    f = this.getControllerVisual(t, "color", c),
                    p = this.getControllerVisual(t, "symbolSize"),
                    d = ce(t, s, u, !0),
                    g = l[0] - p / 2,
                    y = {
                        x: h.x,
                        y: h.y
                    };
                h.y = d, h.x = g;
                var x = we(v.indicatorLabelPoint, zr(h, this.group)),
                    m = v.indicatorLabel;
                m.attr("invisible", !1);
                var S = this._applyTransform("left", v.mainGroup),
                    _ = this._orient,
                    b = _ === "horizontal";
                m.setStyle({
                    text: (i || "") + o.formatValueText(r),
                    verticalAlign: b ? S : "middle",
                    align: b ? "center" : S
                });
                var w = {
                        x: g,
                        y: d,
                        style: {
                            fill: f
                        }
                    },
                    A = {
                        style: {
                            x: x[0],
                            y: x[1]
                        }
                    };
                if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
                    var C = {
                        duration: 100,
                        easing: "cubicInOut",
                        additive: !0
                    };
                    h.x = y.x, h.y = y.y, h.animateTo(w, C), m.animateTo(A, C)
                } else h.attr(w), m.attr(A);
                this._firstShowIndicator = !1;
                var D = this._shapes.handleLabels;
                if (D)
                    for (var I = 0; I < D.length; I++) this.api.enterBlur(D[I])
            }
        }, e.prototype._enableHoverLinkToSeries = function () {
            var t = this;
            this._shapes.mainGroup.on("mousemove", function (r) {
                if (t._hovering = !0, !t._dragging) {
                    var i = t.visualMapModel.itemSize,
                        n = t._applyTransform([r.offsetX, r.offsetY], t._shapes.mainGroup, !0, !0);
                    n[1] = hf(Go(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0])
                }
            }).on("mouseout", function () {
                t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries()
            })
        }, e.prototype._enableHoverLinkFromSeries = function () {
            var t = this.api.getZr();
            this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
        }, e.prototype._doHoverLinkToSeries = function (t, r) {
            var i = this.visualMapModel,
                n = i.itemSize;
            if (i.option.hoverLink) {
                var o = [0, n[1]],
                    s = i.getExtent();
                t = hf(Go(o[0], t), o[1]);
                var l = I2(i, s, o),
                    u = [t - l, t + l],
                    v = ce(t, o, s, !0),
                    h = [ce(u[0], o, s, !0), ce(u[1], o, s, !0)];
                u[0] < o[0] && (h[0] = -1 / 0), u[1] > o[1] && (h[1] = 1 / 0), r && (h[0] === -1 / 0 ? this._showIndicator(v, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(v, h[0], "> ", l) : this._showIndicator(v, v, "â‰ˆ ", l));
                var c = this._hoverLinkDataIndices,
                    f = [];
                (r || ff(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
                var p = v0(c, f);
                this._dispatchHighDown("downplay", Ai(p[0], i)), this._dispatchHighDown("highlight", Ai(p[1], i))
            }
        }, e.prototype._hoverLinkFromSeriesMouseOver = function (t) {
            var r;
            if (Ks(t.target, function (l) {
                    var u = tt(l);
                    if (u.dataIndex != null) return r = u, !0
                }, !0), !!r) {
                var i = this.ecModel.getSeriesByIndex(r.seriesIndex),
                    n = this.visualMapModel;
                if (n.isTargetSeries(i)) {
                    var o = i.getData(r.dataType),
                        s = o.getStore().get(n.getDataDimensionIndex(o), r.dataIndex);
                    isNaN(s) || this._showIndicator(s, s)
                }
            }
        }, e.prototype._hideIndicator = function () {
            var t = this._shapes;
            t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
            var r = this._shapes.handleLabels;
            if (r)
                for (var i = 0; i < r.length; i++) this.api.leaveBlur(r[i])
        }, e.prototype._clearHoverLinkToSeries = function () {
            this._hideIndicator();
            var t = this._hoverLinkDataIndices;
            this._dispatchHighDown("downplay", Ai(t, this.visualMapModel)), t.length = 0
        }, e.prototype._clearHoverLinkFromSeries = function () {
            this._hideIndicator();
            var t = this.api.getZr();
            t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator)
        }, e.prototype._applyTransform = function (t, r, i, n) {
            var o = zr(r, n ? null : this.group);
            return B(t) ? we(t, o, i) : tl(t, o, i)
        }, e.prototype._dispatchHighDown = function (t, r) {
            r && r.length && this.api.dispatchAction({
                type: t,
                batch: r
            })
        }, e.prototype.dispose = function () {
            this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
        }, e.type = "visualMap.continuous", e
    }(Kg);

function cf(a, e, t, r) {
    return new de({
        shape: {
            points: a
        },
        draggable: !!t,
        cursor: e,
        drift: t,
        onmousemove: function (i) {
            Ne(i.event)
        },
        ondragend: r
    })
}

function I2(a, e, t) {
    var r = T2 / 2,
        i = a.get("hoverLinkDataSize");
    return i && (r = ce(i, e, t, !0) / 2), r
}

function ff(a) {
    var e = a.get("hoverLinkOnHandle");
    return !!(e ? ? a.get("realtime"))
}

function pf(a) {
    return a === "vertical" ? "ns-resize" : "ew-resize"
}
const L2 = D2;
var M2 = {
        type: "selectDataRange",
        event: "dataRangeSelected",
        update: "update"
    },
    P2 = function (a, e) {
        e.eachComponent({
            mainType: "visualMap",
            query: a
        }, function (t) {
            t.setSelected(a.selected)
        })
    },
    R2 = [{
        createOnAllSeries: !0,
        reset: function (a, e) {
            var t = [];
            return e.eachComponent("visualMap", function (r) {
                var i = a.pipelineContext;
                !r.isTargetSeries(a) || i && i.large || t.push(LL(r.stateList, r.targetVisuals, F(r.getValueState, r), r.getDataDimensionIndex(a.getData())))
            }), t
        }
    }, {
        createOnAllSeries: !0,
        reset: function (a, e) {
            var t = a.getData(),
                r = [];
            e.eachComponent("visualMap", function (i) {
                if (i.isTargetSeries(a)) {
                    var n = i.getVisualMeta(F(E2, null, a, i)) || {
                            stops: [],
                            outerColors: []
                        },
                        o = i.getDataDimensionIndex(t);
                    o >= 0 && (n.dimension = o, r.push(n))
                }
            }), a.getData().setVisual("visualMeta", r)
        }
    }];

function E2(a, e, t, r) {
    for (var i = e.targetVisuals[r], n = Ot.prepareVisualTypes(i), o = {
            color: dn(a.getData(), "color")
        }, s = 0, l = n.length; s < l; s++) {
        var u = n[s],
            v = i[u === "opacity" ? "__alphaForOpacity" : u];
        v && v.applyVisual(t, h, c)
    }
    return o.color;

    function h(f) {
        return o[f]
    }

    function c(f, p) {
        o[f] = p
    }
}
var df = T;

function k2(a) {
    var e = a && a.visualMap;
    B(e) || (e = e ? [e] : []), df(e, function (t) {
        if (t) {
            Dr(t, "splitList") && !Dr(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
            var r = t.pieces;
            r && B(r) && df(r, function (i) {
                St(i) && (Dr(i, "start") && !Dr(i, "min") && (i.min = i.start), Dr(i, "end") && !Dr(i, "max") && (i.max = i.end))
            })
        }
    })
}

function Dr(a, e) {
    return a && a.hasOwnProperty && a.hasOwnProperty(e)
}
var gf = !1;

function jg(a) {
    gf || (gf = !0, a.registerSubTypeDefaulter("visualMap", function (e) {
        return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise"
    }), a.registerAction(M2, P2), T(R2, function (e) {
        a.registerVisual(a.PRIORITY.VISUAL.COMPONENT, e)
    }), a.registerPreprocessor(k2))
}

function Jg(a) {
    a.registerComponentModel(b2), a.registerComponentView(L2), jg(a)
}
var V2 = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = e.type, t._pieceList = [], t
        }
        return e.prototype.optionUpdated = function (t, r) {
            a.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
            var i = this._mode = this._determineMode();
            this._pieceList = [], O2[this._mode].call(this, this._pieceList), this._resetSelected(t, r);
            var n = this.option.categories;
            this.resetVisual(function (o, s) {
                i === "categories" ? (o.mappingMethod = "category", o.categories = ot(n)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = G(this._pieceList, function (l) {
                    return l = ot(l), s !== "inRange" && (l.visual = null), l
                }))
            })
        }, e.prototype.completeVisualOption = function () {
            var t = this.option,
                r = {},
                i = Ot.listVisualTypes(),
                n = this.isCategory();
            T(t.pieces, function (s) {
                T(i, function (l) {
                    s.hasOwnProperty(l) && (r[l] = 1)
                })
            }), T(r, function (s, l) {
                var u = !1;
                T(this.stateList, function (v) {
                    u = u || o(t, v, l) || o(t.target, v, l)
                }, this), !u && T(this.stateList, function (v) {
                    (t[v] || (t[v] = {}))[l] = Xg.get(l, v === "inRange" ? "active" : "inactive", n)
                })
            }, this);

            function o(s, l, u) {
                return s && s[l] && s[l].hasOwnProperty(u)
            }
            a.prototype.completeVisualOption.apply(this, arguments)
        }, e.prototype._resetSelected = function (t, r) {
            var i = this.option,
                n = this._pieceList,
                o = (r ? i : t).selected || {};
            if (i.selected = o, T(n, function (l, u) {
                    var v = this.getSelectedMapKey(l);
                    o.hasOwnProperty(v) || (o[v] = !0)
                }, this), i.selectedMode === "single") {
                var s = !1;
                T(n, function (l, u) {
                    var v = this.getSelectedMapKey(l);
                    o[v] && (s ? o[v] = !1 : s = !0)
                }, this)
            }
        }, e.prototype.getItemSymbol = function () {
            return this.get("itemSymbol")
        }, e.prototype.getSelectedMapKey = function (t) {
            return this._mode === "categories" ? t.value + "" : t.index + ""
        }, e.prototype.getPieceList = function () {
            return this._pieceList
        }, e.prototype._determineMode = function () {
            var t = this.option;
            return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber"
        }, e.prototype.setSelected = function (t) {
            this.option.selected = ot(t)
        }, e.prototype.getValueState = function (t) {
            var r = Ot.findPieceIndex(t, this._pieceList);
            return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange"
        }, e.prototype.findTargetDataIndices = function (t) {
            var r = [],
                i = this._pieceList;
            return this.eachTargetSeries(function (n) {
                var o = [],
                    s = n.getData();
                s.each(this.getDataDimensionIndex(s), function (l, u) {
                    var v = Ot.findPieceIndex(l, i);
                    v === t && o.push(u)
                }, this), r.push({
                    seriesId: n.id,
                    dataIndex: o
                })
            }, this), r
        }, e.prototype.getRepresentValue = function (t) {
            var r;
            if (this.isCategory()) r = t.value;
            else if (t.value != null) r = t.value;
            else {
                var i = t.interval || [];
                r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
            }
            return r
        }, e.prototype.getVisualMeta = function (t) {
            if (this.isCategory()) return;
            var r = [],
                i = ["", ""],
                n = this;

            function o(v, h) {
                var c = n.getRepresentValue({
                    interval: v
                });
                h || (h = n.getValueState(c));
                var f = t(c, h);
                v[0] === -1 / 0 ? i[0] = f : v[1] === 1 / 0 ? i[1] = f : r.push({
                    value: v[0],
                    color: f
                }, {
                    value: v[1],
                    color: f
                })
            }
            var s = this._pieceList.slice();
            if (!s.length) s.push({
                interval: [-1 / 0, 1 / 0]
            });
            else {
                var l = s[0].interval[0];
                l !== -1 / 0 && s.unshift({
                    interval: [-1 / 0, l]
                }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
                    interval: [l, 1 / 0]
                })
            }
            var u = -1 / 0;
            return T(s, function (v) {
                var h = v.interval;
                h && (h[0] > u && o([u, h[0]], "outOfRange"), o(h.slice()), u = h[1])
            }, this), {
                stops: r,
                outerColors: i
            }
        }, e.type = "visualMap.piecewise", e.defaultOption = mr($i.defaultOption, {
            selected: null,
            minOpen: !1,
            maxOpen: !1,
            align: "auto",
            itemWidth: 20,
            itemHeight: 14,
            itemSymbol: "roundRect",
            pieces: null,
            categories: null,
            splitNumber: 5,
            selectedMode: "multiple",
            itemGap: 10,
            hoverLink: !0
        }), e
    }($i),
    O2 = {
        splitNumber: function (a) {
            var e = this.option,
                t = Math.min(e.precision, 20),
                r = this.getExtent(),
                i = e.splitNumber;
            i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
            for (var n = (r[1] - r[0]) / i; + n.toFixed(t) !== n && t < 5;) t++;
            e.precision = t, n = +n.toFixed(t), e.minOpen && a.push({
                interval: [-1 / 0, r[0]],
                close: [0, 0]
            });
            for (var o = 0, s = r[0]; o < i; s += n, o++) {
                var l = o === i - 1 ? r[1] : s + n;
                a.push({
                    interval: [s, l],
                    close: [1, 1]
                })
            }
            e.maxOpen && a.push({
                interval: [r[1], 1 / 0],
                close: [0, 0]
            }), Cu(a), T(a, function (u, v) {
                u.index = v, u.text = this.formatValueText(u.interval)
            }, this)
        },
        categories: function (a) {
            var e = this.option;
            T(e.categories, function (t) {
                a.push({
                    text: this.formatValueText(t, !0),
                    value: t
                })
            }, this), yf(e, a)
        },
        pieces: function (a) {
            var e = this.option;
            T(e.pieces, function (t, r) {
                St(t) || (t = {
                    value: t
                });
                var i = {
                    text: "",
                    index: r
                };
                if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
                    var n = i.value = t.value;
                    i.interval = [n, n], i.close = [1, 1]
                } else {
                    for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], v = [], h = 0; h < 2; h++) {
                        for (var c = [
                                ["gte", "gt", "min"],
                                ["lte", "lt", "max"]
                            ][h], f = 0; f < 3 && o[h] == null; f++) o[h] = t[c[f]], s[h] = l[f], v[h] = f === 2;
                        o[h] == null && (o[h] = u[h])
                    }
                    v[0] && o[1] === 1 / 0 && (s[0] = 0), v[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] === o[1] && s[0] && s[1] && (i.value = o[0])
                }
                i.visual = Ot.retrieveVisuals(t), a.push(i)
            }, this), yf(e, a), Cu(a), T(a, function (t) {
                var r = t.close,
                    i = [
                        ["<", "â‰¤"][r[1]],
                        [">", "â‰¥"][r[0]]
                    ];
                t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i)
            }, this)
        }
    };

function yf(a, e) {
    var t = a.inverse;
    (a.orient === "vertical" ? !t : t) && e.reverse()
}
const z2 = V2;
var N2 = function (a) {
    E(e, a);

    function e() {
        var t = a !== null && a.apply(this, arguments) || this;
        return t.type = e.type, t
    }
    return e.prototype.doRender = function () {
        var t = this.group;
        t.removeAll();
        var r = this.visualMapModel,
            i = r.get("textGap"),
            n = r.textStyleModel,
            o = n.getFont(),
            s = n.getTextColor(),
            l = this._getItemAlign(),
            u = r.itemSize,
            v = this._getViewData(),
            h = v.endsText,
            c = Ut(r.get("showLabel", !0), !h);
        h && this._renderEndsText(t, h[0], u, c, l), T(v.viewPieceList, function (f) {
            var p = f.piece,
                d = new U;
            d.onclick = F(this._onItemClick, this, p), this._enableHoverLink(d, f.indexInModelPieceList);
            var g = r.getRepresentValue(p);
            if (this._createItemSymbol(d, g, [0, 0, u[0], u[1]]), c) {
                var y = this.visualMapModel.getValueState(g);
                d.add(new ut({
                    style: {
                        x: l === "right" ? -i : u[0] + i,
                        y: u[1] / 2,
                        text: p.text,
                        verticalAlign: "middle",
                        align: l,
                        font: o,
                        fill: s,
                        opacity: y === "outOfRange" ? .5 : 1
                    }
                }))
            }
            t.add(d)
        }, this), h && this._renderEndsText(t, h[1], u, c, l), sr(r.get("orient"), t, r.get("itemGap")), this.renderBackground(t), this.positionGroup(t)
    }, e.prototype._enableHoverLink = function (t, r) {
        var i = this;
        t.on("mouseover", function () {
            return n("highlight")
        }).on("mouseout", function () {
            return n("downplay")
        });
        var n = function (o) {
            var s = i.visualMapModel;
            s.option.hoverLink && i.api.dispatchAction({
                type: o,
                batch: Ai(s.findTargetDataIndices(r), s)
            })
        }
    }, e.prototype._getItemAlign = function () {
        var t = this.visualMapModel,
            r = t.option;
        if (r.orient === "vertical") return qg(t, this.api, t.itemSize);
        var i = r.align;
        return (!i || i === "auto") && (i = "left"), i
    }, e.prototype._renderEndsText = function (t, r, i, n, o) {
        if (r) {
            var s = new U,
                l = this.visualMapModel.textStyleModel;
            s.add(new ut({
                style: mt(l, {
                    x: n ? o === "right" ? i[0] : 0 : i[0] / 2,
                    y: i[1] / 2,
                    verticalAlign: "middle",
                    align: n ? o : "center",
                    text: r
                })
            })), t.add(s)
        }
    }, e.prototype._getViewData = function () {
        var t = this.visualMapModel,
            r = G(t.getPieceList(), function (s, l) {
                return {
                    piece: s,
                    indexInModelPieceList: l
                }
            }),
            i = t.get("text"),
            n = t.get("orient"),
            o = t.get("inverse");
        return (n === "horizontal" ? o : !o) ? r.reverse() : i && (i = i.slice().reverse()), {
            viewPieceList: r,
            endsText: i
        }
    }, e.prototype._createItemSymbol = function (t, r, i) {
        t.add(Et(this.getControllerVisual(r, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(r, "color")))
    }, e.prototype._onItemClick = function (t) {
        var r = this.visualMapModel,
            i = r.option,
            n = i.selectedMode;
        if (n) {
            var o = ot(i.selected),
                s = r.getSelectedMapKey(t);
            n === "single" || n === !0 ? (o[s] = !0, T(o, function (l, u) {
                o[u] = u === s
            })) : o[s] = !o[s], this.api.dispatchAction({
                type: "selectDataRange",
                from: this.uid,
                visualMapId: this.visualMapModel.id,
                selected: o
            })
        }
    }, e.type = "visualMap.piecewise", e
}(Kg);
const G2 = N2;

function Qg(a) {
    a.registerComponentModel(z2), a.registerComponentView(G2), jg(a)
}

function B2(a) {
    j(Jg), j(Qg)
}
var H2 = {
        label: {
            enabled: !0
        },
        decal: {
            show: !1
        }
    },
    mf = xt(),
    F2 = {};

function W2(a, e) {
    var t = a.getModel("aria");
    if (!t.get("enabled")) return;
    var r = ot(H2);
    ct(r.label, a.getLocaleModel().get("aria"), !1), ct(t.option, r, !1), i(), n();

    function i() {
        var u = t.getModel("decal"),
            v = u.get("show");
        if (v) {
            var h = Q();
            a.eachSeries(function (c) {
                if (!c.isColorBySeries()) {
                    var f = h.get(c.type);
                    f || (f = {}, h.set(c.type, f)), mf(c).scope = f
                }
            }), a.eachRawSeries(function (c) {
                if (a.isSeriesFiltered(c)) return;
                if (rt(c.enableAriaDecal)) {
                    c.enableAriaDecal();
                    return
                }
                var f = c.getData();
                if (c.isColorBySeries()) {
                    var x = jo(c.ecModel, c.name, F2, a.getSeriesCount()),
                        m = f.getVisual("decal");
                    f.setVisual("decal", S(m, x))
                } else {
                    var p = c.getRawData(),
                        d = {},
                        g = mf(c).scope;
                    f.each(function (_) {
                        var b = f.getRawIndex(_);
                        d[b] = _
                    });
                    var y = p.count();
                    p.each(function (_) {
                        var b = d[_],
                            w = p.getName(_) || _ + "",
                            A = jo(c.ecModel, w, g, y),
                            C = f.getItemVisual(b, "decal");
                        f.setItemVisual(b, "decal", S(C, A))
                    })
                }

                function S(_, b) {
                    var w = _ ? W(W({}, b), _) : b;
                    return w.dirty = !0, w
                }
            })
        }
    }

    function n() {
        var u = a.getLocaleModel().get("aria"),
            v = t.getModel("label");
        if (v.option = at(v.option, u), !!v.get("enabled")) {
            var h = e.getZr().dom;
            if (v.get("description")) {
                h.setAttribute("aria-label", v.get("description"));
                return
            }
            var c = a.getSeriesCount(),
                f = v.get(["data", "maxCount"]) || 10,
                p = v.get(["series", "maxCount"]) || 10,
                d = Math.min(c, p),
                g;
            if (!(c < 1)) {
                var y = s();
                if (y) {
                    var x = v.get(["general", "withTitle"]);
                    g = o(x, {
                        title: y
                    })
                } else g = v.get(["general", "withoutTitle"]);
                var m = [],
                    S = c > 1 ? v.get(["series", "multiple", "prefix"]) : v.get(["series", "single", "prefix"]);
                g += o(S, {
                    seriesCount: c
                }), a.eachSeries(function (A, C) {
                    if (C < d) {
                        var D = void 0,
                            I = A.get("name"),
                            L = I ? "withName" : "withoutName";
                        D = c > 1 ? v.get(["series", "multiple", L]) : v.get(["series", "single", L]), D = o(D, {
                            seriesId: A.seriesIndex,
                            seriesName: A.get("name"),
                            seriesType: l(A.subType)
                        });
                        var M = A.getData();
                        if (M.count() > f) {
                            var P = v.get(["data", "partialData"]);
                            D += o(P, {
                                displayCnt: f
                            })
                        } else D += v.get(["data", "allData"]);
                        for (var R = v.get(["data", "separator", "middle"]), k = v.get(["data", "separator", "end"]), V = [], O = 0; O < M.count(); O++)
                            if (O < f) {
                                var z = M.getName(O),
                                    $ = M.getValues(O),
                                    Z = v.get(["data", z ? "withName" : "withoutName"]);
                                V.push(o(Z, {
                                    name: z,
                                    value: $.join(R)
                                }))
                            } D += V.join(R) + k, m.push(D)
                    }
                });
                var _ = v.getModel(["series", "multiple", "separator"]),
                    b = _.get("middle"),
                    w = _.get("end");
                g += m.join(b) + w, h.setAttribute("aria-label", g)
            }
        }
    }

    function o(u, v) {
        if (!q(u)) return u;
        var h = u;
        return T(v, function (c, f) {
            h = h.replace(new RegExp("\\{\\s*" + f + "\\s*\\}", "g"), c)
        }), h
    }

    function s() {
        var u = a.get("title");
        return u && u.length && (u = u[0]), u && u.text
    }

    function l(u) {
        var v = a.getLocaleModel().get(["series", "typeNames"]);
        return v[u] || v.chart
    }
}

function $2(a) {
    if (!(!a || !a.aria)) {
        var e = a.aria;
        e.show != null && (e.enabled = e.show), e.label = e.label || {}, T(["description", "general", "series", "data"], function (t) {
            e[t] != null && (e.label[t] = e[t])
        })
    }
}

function Z2(a) {
    a.registerPreprocessor($2), a.registerVisual(a.PRIORITY.VISUAL.ARIA, W2)
}
var xf = {
        value: "eq",
        "<": "lt",
        "<=": "lte",
        ">": "gt",
        ">=": "gte",
        "=": "eq",
        "!=": "ne",
        "<>": "ne"
    },
    U2 = function () {
        function a(e) {
            var t = this._condVal = q(e) ? new RegExp(e) : c0(e) ? e : null;
            if (t == null) {
                var r = "";
                bt(r)
            }
        }
        return a.prototype.evaluate = function (e) {
            var t = typeof e;
            return q(t) ? this._condVal.test(e) : te(t) ? this._condVal.test(e + "") : !1
        }, a
    }(),
    Y2 = function () {
        function a() {}
        return a.prototype.evaluate = function () {
            return this.value
        }, a
    }(),
    X2 = function () {
        function a() {}
        return a.prototype.evaluate = function () {
            for (var e = this.children, t = 0; t < e.length; t++)
                if (!e[t].evaluate()) return !1;
            return !0
        }, a
    }(),
    K2 = function () {
        function a() {}
        return a.prototype.evaluate = function () {
            for (var e = this.children, t = 0; t < e.length; t++)
                if (e[t].evaluate()) return !0;
            return !1
        }, a
    }(),
    q2 = function () {
        function a() {}
        return a.prototype.evaluate = function () {
            return !this.child.evaluate()
        }, a
    }(),
    j2 = function () {
        function a() {}
        return a.prototype.evaluate = function () {
            for (var e = !!this.valueParser, t = this.getValue, r = t(this.valueGetterParam), i = e ? this.valueParser(r) : null, n = 0; n < this.subCondList.length; n++)
                if (!this.subCondList[n].evaluate(e ? i : r)) return !1;
            return !0
        }, a
    }();

function ru(a, e) {
    if (a === !0 || a === !1) {
        var t = new Y2;
        return t.value = a, t
    }
    var r = "";
    return ty(a) || bt(r), a.and ? Sf("and", a, e) : a.or ? Sf("or", a, e) : a.not ? J2(a, e) : Q2(a, e)
}

function Sf(a, e, t) {
    var r = e[a],
        i = "";
    B(r) || bt(i), r.length || bt(i);
    var n = a === "and" ? new X2 : new K2;
    return n.children = G(r, function (o) {
        return ru(o, t)
    }), n.children.length || bt(i), n
}

function J2(a, e) {
    var t = a.not,
        r = "";
    ty(t) || bt(r);
    var i = new q2;
    return i.child = ru(t, e), i.child || bt(r), i
}

function Q2(a, e) {
    for (var t = "", r = e.prepareGetValue(a), i = [], n = wt(a), o = a.parser, s = o ? gp(o) : null, l = 0; l < n.length; l++) {
        var u = n[l];
        if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
            var v = N(xf, u) ? xf[u] : u,
                h = a[u],
                c = s ? s(h) : h,
                f = h0(v, c) || v === "reg" && new U2(c);
            f || bt(t), i.push(f)
        }
    }
    i.length || bt(t);
    var p = new j2;
    return p.valueGetterParam = r, p.valueParser = s, p.getValue = e.getValue, p.subCondList = i, p
}

function ty(a) {
    return St(a) && !op(a)
}
var tP = function () {
    function a(e, t) {
        this._cond = ru(e, t)
    }
    return a.prototype.evaluate = function () {
        return this._cond.evaluate()
    }, a
}();

function eP(a, e) {
    return new tP(a, e)
}
var rP = {
        type: "echarts:filter",
        transform: function (a) {
            for (var e = a.upstream, t, r = eP(a.config, {
                    valueGetterAttrMap: Q({
                        dimension: !0
                    }),
                    prepareGetValue: function (s) {
                        var l = "",
                            u = s.dimension;
                        N(s, "dimension") || bt(l);
                        var v = e.getDimensionInfo(u);
                        return v || bt(l), {
                            dimIdx: v.index
                        }
                    },
                    getValue: function (s) {
                        return e.retrieveValueFromItem(t, s.dimIdx)
                    }
                }), i = [], n = 0, o = e.count(); n < o; n++) t = e.getRawDataItem(n), r.evaluate() && i.push(t);
            return {
                data: i
            }
        }
    },
    aP = {
        type: "echarts:sort",
        transform: function (a) {
            var e = a.upstream,
                t = a.config,
                r = "",
                i = Wt(t);
            i.length || bt(r);
            var n = [];
            T(i, function (v) {
                var h = v.dimension,
                    c = v.order,
                    f = v.parser,
                    p = v.incomparable;
                if (h == null && bt(r), c !== "asc" && c !== "desc" && bt(r), p && p !== "min" && p !== "max") {
                    var d = "";
                    bt(d)
                }
                if (c !== "asc" && c !== "desc") {
                    var g = "";
                    bt(g)
                }
                var y = e.getDimensionInfo(h);
                y || bt(r);
                var x = f ? gp(f) : null;
                f && !x && bt(r), n.push({
                    dimIdx: y.index,
                    parser: x,
                    comparator: new f0(c, p)
                })
            });
            var o = e.sourceFormat;
            o !== np && o !== p0 && bt(r);
            for (var s = [], l = 0, u = e.count(); l < u; l++) s.push(e.getRawDataItem(l));
            return s.sort(function (v, h) {
                for (var c = 0; c < n.length; c++) {
                    var f = n[c],
                        p = e.retrieveValueFromItem(v, f.dimIdx),
                        d = e.retrieveValueFromItem(h, f.dimIdx);
                    f.parser && (p = f.parser(p), d = f.parser(d));
                    var g = f.comparator.evaluate(p, d);
                    if (g !== 0) return g
                }
                return 0
            }), {
                data: s
            }
        }
    };

function iP(a) {
    a.registerTransform(rP), a.registerTransform(aP)
}
var nP = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = "dataset", t
        }
        return e.prototype.init = function (t, r, i) {
            a.prototype.init.call(this, t, r, i), this._sourceManager = new d0(this), Du(this)
        }, e.prototype.mergeOption = function (t, r) {
            a.prototype.mergeOption.call(this, t, r), Du(this)
        }, e.prototype.optionUpdated = function () {
            this._sourceManager.dirty()
        }, e.prototype.getSourceManager = function () {
            return this._sourceManager
        }, e.type = "dataset", e.defaultOption = {
            seriesLayoutBy: g0
        }, e
    }(Ct),
    oP = function (a) {
        E(e, a);

        function e() {
            var t = a !== null && a.apply(this, arguments) || this;
            return t.type = "dataset", t
        }
        return e.type = "dataset", e
    }(It);

function sP(a) {
    a.registerComponentModel(nP), a.registerComponentView(oP)
}
var ve = Zs.CMD;

function Or(a, e) {
    return Math.abs(a - e) < 1e-5
}

function Hs(a) {
    var e = a.data,
        t = a.len(),
        r = [],
        i, n = 0,
        o = 0,
        s = 0,
        l = 0;

    function u(M, P) {
        i && i.length > 2 && r.push(i), i = [M, P]
    }

    function v(M, P, R, k) {
        Or(M, R) && Or(P, k) || i.push(M, P, R, k, R, k)
    }

    function h(M, P, R, k, V, O) {
        var z = Math.abs(P - M),
            $ = Math.tan(z / 4) * 4 / 3,
            Z = P < M ? -1 : 1,
            et = Math.cos(M),
            J = Math.sin(M),
            X = Math.cos(P),
            nt = Math.sin(P),
            st = et * V + R,
            it = J * O + k,
            Y = X * V + R,
            vt = nt * O + k,
            lt = V * $ * Z,
            dt = O * $ * Z;
        i.push(st - lt * J, it + dt * et, Y + lt * nt, vt - dt * X, Y, vt)
    }
    for (var c, f, p, d, g = 0; g < t;) {
        var y = e[g++],
            x = g === 1;
        switch (x && (n = e[g], o = e[g + 1], s = n, l = o, (y === ve.L || y === ve.C || y === ve.Q) && (i = [s, l])), y) {
            case ve.M:
                n = s = e[g++], o = l = e[g++], u(s, l);
                break;
            case ve.L:
                c = e[g++], f = e[g++], v(n, o, c, f), n = c, o = f;
                break;
            case ve.C:
                i.push(e[g++], e[g++], e[g++], e[g++], n = e[g++], o = e[g++]);
                break;
            case ve.Q:
                c = e[g++], f = e[g++], p = e[g++], d = e[g++], i.push(n + 2 / 3 * (c - n), o + 2 / 3 * (f - o), p + 2 / 3 * (c - p), d + 2 / 3 * (f - d), p, d), n = p, o = d;
                break;
            case ve.A:
                var m = e[g++],
                    S = e[g++],
                    _ = e[g++],
                    b = e[g++],
                    w = e[g++],
                    A = e[g++] + w;
                g += 1;
                var C = !e[g++];
                c = Math.cos(w) * _ + m, f = Math.sin(w) * b + S, x ? (s = c, l = f, u(s, l)) : v(n, o, c, f), n = Math.cos(A) * _ + m, o = Math.sin(A) * b + S;
                for (var D = (C ? -1 : 1) * Math.PI / 2, I = w; C ? I > A : I < A; I += D) {
                    var L = C ? Math.max(I + D, A) : Math.min(I + D, A);
                    h(I, L, m, S, _, b)
                }
                break;
            case ve.R:
                s = n = e[g++], l = o = e[g++], c = s + e[g++], f = l + e[g++], u(c, l), v(c, l, c, f), v(c, f, s, f), v(s, f, s, l), v(s, l, c, l);
                break;
            case ve.Z:
                i && v(n, o, s, l), n = s, o = l;
                break
        }
    }
    return i && i.length > 2 && r.push(i), r
}

function Fs(a, e, t, r, i, n, o, s, l, u) {
    if (Or(a, t) && Or(e, r) && Or(i, o) && Or(n, s)) {
        l.push(o, s);
        return
    }
    var v = 2 / u,
        h = v * v,
        c = o - a,
        f = s - e,
        p = Math.sqrt(c * c + f * f);
    c /= p, f /= p;
    var d = t - a,
        g = r - e,
        y = i - o,
        x = n - s,
        m = d * d + g * g,
        S = y * y + x * x;
    if (m < h && S < h) {
        l.push(o, s);
        return
    }
    var _ = c * d + f * g,
        b = -c * y - f * x,
        w = m - _ * _,
        A = S - b * b;
    if (w < h && _ >= 0 && A < h && b >= 0) {
        l.push(o, s);
        return
    }
    var C = [],
        D = [];
    Li(a, t, i, o, .5, C), Li(e, r, n, s, .5, D), Fs(C[0], D[0], C[1], D[1], C[2], D[2], C[3], D[3], l, u), Fs(C[4], D[4], C[5], D[5], C[6], D[6], C[7], D[7], l, u)
}

function lP(a, e) {
    var t = Hs(a),
        r = [];
    e = e || 1;
    for (var i = 0; i < t.length; i++) {
        var n = t[i],
            o = [],
            s = n[0],
            l = n[1];
        o.push(s, l);
        for (var u = 2; u < n.length;) {
            var v = n[u++],
                h = n[u++],
                c = n[u++],
                f = n[u++],
                p = n[u++],
                d = n[u++];
            Fs(s, l, v, h, c, f, p, d, o, e), s = p, l = d
        }
        r.push(o)
    }
    return r
}

function ey(a, e, t) {
    var r = a[e],
        i = a[1 - e],
        n = Math.abs(r / i),
        o = Math.ceil(Math.sqrt(n * t)),
        s = Math.floor(t / o);
    s === 0 && (s = 1, o = t);
    for (var l = [], u = 0; u < o; u++) l.push(s);
    var v = o * s,
        h = t - v;
    if (h > 0)
        for (var u = 0; u < h; u++) l[u % o] += 1;
    return l
}

function _f(a, e, t) {
    for (var r = a.r0, i = a.r, n = a.startAngle, o = a.endAngle, s = Math.abs(o - n), l = s * i, u = i - r, v = l > Math.abs(u), h = ey([l, u], v ? 0 : 1, e), c = (v ? s : u) / h.length, f = 0; f < h.length; f++)
        for (var p = (v ? u : s) / h[f], d = 0; d < h[f]; d++) {
            var g = {};
            v ? (g.startAngle = n + c * f, g.endAngle = n + c * (f + 1), g.r0 = r + p * d, g.r = r + p * (d + 1)) : (g.startAngle = n + p * d, g.endAngle = n + p * (d + 1), g.r0 = r + c * f, g.r = r + c * (f + 1)), g.clockwise = a.clockwise, g.cx = a.cx, g.cy = a.cy, t.push(g)
        }
}

function uP(a, e, t) {
    for (var r = a.width, i = a.height, n = r > i, o = ey([r, i], n ? 0 : 1, e), s = n ? "width" : "height", l = n ? "height" : "width", u = n ? "x" : "y", v = n ? "y" : "x", h = a[s] / o.length, c = 0; c < o.length; c++)
        for (var f = a[l] / o[c], p = 0; p < o[c]; p++) {
            var d = {};
            d[u] = c * h, d[v] = p * f, d[s] = h, d[l] = f, d.x += a.x, d.y += a.y, t.push(d)
        }
}

function bf(a, e, t, r) {
    return a * r - t * e
}

function vP(a, e, t, r, i, n, o, s) {
    var l = t - a,
        u = r - e,
        v = o - i,
        h = s - n,
        c = bf(v, h, l, u);
    if (Math.abs(c) < 1e-6) return null;
    var f = a - i,
        p = e - n,
        d = bf(f, p, v, h) / c;
    return d < 0 || d > 1 ? null : new _e(d * l + a, d * u + e)
}

function hP(a, e, t) {
    var r = new _e;
    _e.sub(r, t, e), r.normalize();
    var i = new _e;
    _e.sub(i, a, e);
    var n = i.dot(r);
    return n
}

function Ir(a, e) {
    var t = a[a.length - 1];
    t && t[0] === e[0] && t[1] === e[1] || a.push(e)
}

function cP(a, e, t) {
    for (var r = a.length, i = [], n = 0; n < r; n++) {
        var o = a[n],
            s = a[(n + 1) % r],
            l = vP(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
        l && i.push({
            projPt: hP(l, e, t),
            pt: l,
            idx: n
        })
    }
    if (i.length < 2) return [{
        points: a
    }, {
        points: a
    }];
    i.sort(function (g, y) {
        return g.projPt - y.projPt
    });
    var u = i[0],
        v = i[i.length - 1];
    if (v.idx < u.idx) {
        var h = u;
        u = v, v = h
    }
    for (var c = [u.pt.x, u.pt.y], f = [v.pt.x, v.pt.y], p = [c], d = [f], n = u.idx + 1; n <= v.idx; n++) Ir(p, a[n].slice());
    Ir(p, f), Ir(p, c);
    for (var n = v.idx + 1; n <= u.idx + r; n++) Ir(d, a[n % r].slice());
    return Ir(d, c), Ir(d, f), [{
        points: p
    }, {
        points: d
    }]
}

function wf(a) {
    var e = a.points,
        t = [],
        r = [];
    vn(e, t, r);
    var i = new gt(t[0], t[1], r[0] - t[0], r[1] - t[1]),
        n = i.width,
        o = i.height,
        s = i.x,
        l = i.y,
        u = new _e,
        v = new _e;
    return n > o ? (u.x = v.x = s + n / 2, u.y = l, v.y = l + o) : (u.y = v.y = l + o / 2, u.x = s, v.x = s + n), cP(e, u, v)
}

function Zi(a, e, t, r) {
    if (t === 1) r.push(e);
    else {
        var i = Math.floor(t / 2),
            n = a(e);
        Zi(a, n[0], i, r), Zi(a, n[1], t - i, r)
    }
    return r
}

function fP(a, e) {
    for (var t = [], r = 0; r < e; r++) t.push(rl(a));
    return t
}

function pP(a, e) {
    e.setStyle(a.style), e.z = a.z, e.z2 = a.z2, e.zlevel = a.zlevel
}

function dP(a) {
    for (var e = [], t = 0; t < a.length;) e.push([a[t++], a[t++]]);
    return e
}

function gP(a, e) {
    var t = [],
        r = a.shape,
        i;
    switch (a.type) {
        case "rect":
            uP(r, e, t), i = pt;
            break;
        case "sector":
            _f(r, e, t), i = cr;
            break;
        case "circle":
            _f({
                r0: 0,
                r: r.r,
                startAngle: 0,
                endAngle: Math.PI * 2,
                cx: r.cx,
                cy: r.cy
            }, e, t), i = cr;
            break;
        default:
            var n = a.getComputedTransform(),
                o = n ? Math.sqrt(Math.max(n[0] * n[0] + n[1] * n[1], n[2] * n[2] + n[3] * n[3])) : 1,
                s = G(lP(a.getUpdatedPathProxy(), o), function (y) {
                    return dP(y)
                }),
                l = s.length;
            if (l === 0) Zi(wf, {
                points: s[0]
            }, e, t);
            else if (l === e)
                for (var u = 0; u < l; u++) t.push({
                    points: s[u]
                });
            else {
                var v = 0,
                    h = G(s, function (y) {
                        var x = [],
                            m = [];
                        vn(y, x, m);
                        var S = (m[1] - x[1]) * (m[0] - x[0]);
                        return v += S, {
                            poly: y,
                            area: S
                        }
                    });
                h.sort(function (y, x) {
                    return x.area - y.area
                });
                for (var c = e, u = 0; u < l; u++) {
                    var f = h[u];
                    if (c <= 0) break;
                    var p = u === l - 1 ? c : Math.ceil(f.area / v * e);
                    p < 0 || (Zi(wf, {
                        points: f.poly
                    }, p, t), c -= p)
                }
            }
            i = de;
            break
    }
    if (!i) return fP(a, e);
    for (var d = [], u = 0; u < t.length; u++) {
        var g = new i;
        g.setShape(t[u]), pP(a, g), d.push(g)
    }
    return d
}

function yP(a, e) {
    var t = a.length,
        r = e.length;
    if (t === r) return [a, e];
    for (var i = [], n = [], o = t < r ? a : e, s = Math.min(t, r), l = Math.abs(r - t) / 6, u = (s - 2) / 6, v = Math.ceil(l / u) + 1, h = [o[0], o[1]], c = l, f = 2; f < s;) {
        var p = o[f - 2],
            d = o[f - 1],
            g = o[f++],
            y = o[f++],
            x = o[f++],
            m = o[f++],
            S = o[f++],
            _ = o[f++];
        if (c <= 0) {
            h.push(g, y, x, m, S, _);
            continue
        }
        for (var b = Math.min(c, v - 1) + 1, w = 1; w <= b; w++) {
            var A = w / b;
            Li(p, g, x, S, A, i), Li(d, y, m, _, A, n), p = i[3], d = n[3], h.push(i[1], n[1], i[2], n[2], p, d), g = i[5], y = n[5], x = i[6], m = n[6]
        }
        c -= b - 1
    }
    return o === a ? [h, e] : [a, h]
}

function Af(a, e) {
    for (var t = a.length, r = a[t - 2], i = a[t - 1], n = [], o = 0; o < e.length;) n[o++] = r, n[o++] = i;
    return n
}

function mP(a, e) {
    for (var t, r, i, n = [], o = [], s = 0; s < Math.max(a.length, e.length); s++) {
        var l = a[s],
            u = e[s],
            v = void 0,
            h = void 0;
        l ? u ? (t = yP(l, u), v = t[0], h = t[1], r = v, i = h) : (h = Af(i || l, l), v = l) : (v = Af(r || u, u), h = u), n.push(v), o.push(h)
    }
    return [n, o]
}

function Tf(a) {
    for (var e = 0, t = 0, r = 0, i = a.length, n = 0, o = i - 2; n < i; o = n, n += 2) {
        var s = a[o],
            l = a[o + 1],
            u = a[n],
            v = a[n + 1],
            h = s * v - u * l;
        e += h, t += (s + u) * h, r += (l + v) * h
    }
    return e === 0 ? [a[0] || 0, a[1] || 0] : [t / e / 3, r / e / 3, e]
}

function xP(a, e, t, r) {
    for (var i = (a.length - 2) / 6, n = 1 / 0, o = 0, s = a.length, l = s - 2, u = 0; u < i; u++) {
        for (var v = u * 6, h = 0, c = 0; c < s; c += 2) {
            var f = c === 0 ? v : (v + c - 2) % l + 2,
                p = a[f] - t[0],
                d = a[f + 1] - t[1],
                g = e[c] - r[0],
                y = e[c + 1] - r[1],
                x = g - p,
                m = y - d;
            h += x * x + m * m
        }
        h < n && (n = h, o = u)
    }
    return o
}

function SP(a) {
    for (var e = [], t = a.length, r = 0; r < t; r += 2) e[r] = a[t - r - 2], e[r + 1] = a[t - r - 1];
    return e
}

function _P(a, e, t, r) {
    for (var i = [], n, o = 0; o < a.length; o++) {
        var s = a[o],
            l = e[o],
            u = Tf(s),
            v = Tf(l);
        n == null && (n = u[2] < 0 != v[2] < 0);
        var h = [],
            c = [],
            f = 0,
            p = 1 / 0,
            d = [],
            g = s.length;
        n && (s = SP(s));
        for (var y = xP(s, l, u, v) * 6, x = g - 2, m = 0; m < x; m += 2) {
            var S = (y + m) % x + 2;
            h[m + 2] = s[S] - u[0], h[m + 3] = s[S + 1] - u[1]
        }
        if (h[0] = s[y] - u[0], h[1] = s[y + 1] - u[1], t > 0)
            for (var _ = r / t, b = -r / 2; b <= r / 2; b += _) {
                for (var w = Math.sin(b), A = Math.cos(b), C = 0, m = 0; m < s.length; m += 2) {
                    var D = h[m],
                        I = h[m + 1],
                        L = l[m] - v[0],
                        M = l[m + 1] - v[1],
                        P = L * A - M * w,
                        R = L * w + M * A;
                    d[m] = P, d[m + 1] = R;
                    var k = P - D,
                        V = R - I;
                    C += k * k + V * V
                }
                if (C < p) {
                    p = C, f = b;
                    for (var O = 0; O < d.length; O++) c[O] = d[O]
                }
            } else
                for (var z = 0; z < g; z += 2) c[z] = l[z] - v[0], c[z + 1] = l[z + 1] - v[1];
        i.push({
            from: h,
            to: c,
            fromCp: u,
            toCp: v,
            rotation: -f
        })
    }
    return i
}

function Ui(a) {
    return a.__isCombineMorphing
}
var ry = "__mOriginal_";

function Yi(a, e, t) {
    var r = ry + e,
        i = a[r] || a[e];
    a[r] || (a[r] = a[e]);
    var n = t.replace,
        o = t.after,
        s = t.before;
    a[e] = function () {
        var l = arguments,
            u;
        return s && s.apply(this, l), n ? u = n.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u
    }
}

function Sa(a, e) {
    var t = ry + e;
    a[t] && (a[e] = a[t], a[t] = null)
}

function Cf(a, e) {
    for (var t = 0; t < a.length; t++)
        for (var r = a[t], i = 0; i < r.length;) {
            var n = r[i],
                o = r[i + 1];
            r[i++] = e[0] * n + e[2] * o + e[4], r[i++] = e[1] * n + e[3] * o + e[5]
        }
}

function ay(a, e) {
    var t = a.getUpdatedPathProxy(),
        r = e.getUpdatedPathProxy(),
        i = mP(Hs(t), Hs(r)),
        n = i[0],
        o = i[1],
        s = a.getComputedTransform(),
        l = e.getComputedTransform();

    function u() {
        this.transform = null
    }
    s && Cf(n, s), l && Cf(o, l), Yi(e, "updateTransform", {
        replace: u
    }), e.transform = null;
    var v = _P(n, o, 10, Math.PI),
        h = [];
    Yi(e, "buildPath", {
        replace: function (c) {
            for (var f = e.__morphT, p = 1 - f, d = [], g = 0; g < v.length; g++) {
                var y = v[g],
                    x = y.from,
                    m = y.to,
                    S = y.rotation * f,
                    _ = y.fromCp,
                    b = y.toCp,
                    w = Math.sin(S),
                    A = Math.cos(S);
                y0(d, _, b, f);
                for (var C = 0; C < x.length; C += 2) {
                    var D = x[C],
                        I = x[C + 1],
                        L = m[C],
                        M = m[C + 1],
                        P = D * p + L * f,
                        R = I * p + M * f;
                    h[C] = P * A - R * w + d[0], h[C + 1] = P * w + R * A + d[1]
                }
                var k = h[0],
                    V = h[1];
                c.moveTo(k, V);
                for (var C = 2; C < x.length;) {
                    var L = h[C++],
                        M = h[C++],
                        O = h[C++],
                        z = h[C++],
                        $ = h[C++],
                        Z = h[C++];
                    k === L && V === M && O === $ && z === Z ? c.lineTo($, Z) : c.bezierCurveTo(L, M, O, z, $, Z), k = $, V = Z
                }
            }
        }
    })
}

function au(a, e, t) {
    if (!a || !e) return e;
    var r = t.done,
        i = t.during;
    ay(a, e), e.__morphT = 0;

    function n() {
        Sa(e, "buildPath"), Sa(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape()
    }
    return e.animateTo({
        __morphT: 1
    }, at({
        during: function (o) {
            e.dirtyShape(), i && i(o)
        },
        done: function () {
            n(), r && r()
        }
    }, t)), e
}

function bP(a, e, t, r, i, n) {
    var o = 16;
    a = i === t ? 0 : Math.round(32767 * (a - t) / (i - t)), e = n === r ? 0 : Math.round(32767 * (e - r) / (n - r));
    for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
        var v = 0,
            h = 0;
        (a & u) > 0 && (v = 1), (e & u) > 0 && (h = 1), s += u * u * (3 * v ^ h), h === 0 && (v === 1 && (a = u - 1 - a, e = u - 1 - e), l = a, a = e, e = l)
    }
    return s
}

function Xi(a) {
    var e = 1 / 0,
        t = 1 / 0,
        r = -1 / 0,
        i = -1 / 0,
        n = G(a, function (s) {
            var l = s.getBoundingRect(),
                u = s.getComputedTransform(),
                v = l.x + l.width / 2 + (u ? u[4] : 0),
                h = l.y + l.height / 2 + (u ? u[5] : 0);
            return e = Math.min(v, e), t = Math.min(h, t), r = Math.max(v, r), i = Math.max(h, i), [v, h]
        }),
        o = G(n, function (s, l) {
            return {
                cp: s,
                z: bP(s[0], s[1], e, t, r, i),
                path: a[l]
            }
        });
    return o.sort(function (s, l) {
        return s.z - l.z
    }).map(function (s) {
        return s.path
    })
}

function iy(a) {
    return gP(a.path, a.count)
}

function Ws() {
    return {
        fromIndividuals: [],
        toIndividuals: [],
        count: 0
    }
}

function wP(a, e, t) {
    var r = [];

    function i(_) {
        for (var b = 0; b < _.length; b++) {
            var w = _[b];
            Ui(w) ? i(w.childrenRef()) : w instanceof Pt && r.push(w)
        }
    }
    i(a);
    var n = r.length;
    if (!n) return Ws();
    var o = t.dividePath || iy,
        s = o({
            path: e,
            count: n
        });
    if (s.length !== n) return console.error("Invalid morphing: unmatched splitted path"), Ws();
    r = Xi(r), s = Xi(s);
    for (var l = t.done, u = t.during, v = t.individualDelay, h = new Er, c = 0; c < n; c++) {
        var f = r[c],
            p = s[c];
        p.parent = e, p.copyTransform(h), v || ay(f, p)
    }
    e.__isCombineMorphing = !0, e.childrenRef = function () {
        return s
    };

    function d(_) {
        for (var b = 0; b < s.length; b++) s[b].addSelfToZr(_)
    }
    Yi(e, "addSelfToZr", {
        after: function (_) {
            d(_)
        }
    }), Yi(e, "removeSelfFromZr", {
        after: function (_) {
            for (var b = 0; b < s.length; b++) s[b].removeSelfFromZr(_)
        }
    });

    function g() {
        e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, Sa(e, "addSelfToZr"), Sa(e, "removeSelfFromZr")
    }
    var y = s.length;
    if (v)
        for (var x = y, m = function () {
                x--, x === 0 && (g(), l && l())
            }, c = 0; c < y; c++) {
            var S = v ? at({
                delay: (t.delay || 0) + v(c, y, r[c], s[c]),
                done: m
            }, t) : t;
            au(r[c], s[c], S)
        } else e.__morphT = 0, e.animateTo({
            __morphT: 1
        }, at({
            during: function (_) {
                for (var b = 0; b < y; b++) {
                    var w = s[b];
                    w.__morphT = e.__morphT, w.dirtyShape()
                }
                u && u(_)
            },
            done: function () {
                g();
                for (var _ = 0; _ < a.length; _++) Sa(a[_], "updateTransform");
                l && l()
            }
        }, t));
    return e.__zr && d(e.__zr), {
        fromIndividuals: r,
        toIndividuals: s,
        count: y
    }
}

function AP(a, e, t) {
    var r = e.length,
        i = [],
        n = t.dividePath || iy;

    function o(f) {
        for (var p = 0; p < f.length; p++) {
            var d = f[p];
            Ui(d) ? o(d.childrenRef()) : d instanceof Pt && i.push(d)
        }
    }
    if (Ui(a)) {
        o(a.childrenRef());
        var s = i.length;
        if (s < r)
            for (var l = 0, u = s; u < r; u++) i.push(rl(i[l++ % s]));
        i.length = r
    } else {
        i = n({
            path: a,
            count: r
        });
        for (var v = a.getComputedTransform(), u = 0; u < i.length; u++) i[u].setLocalTransform(v);
        if (i.length !== r) return console.error("Invalid morphing: unmatched splitted path"), Ws()
    }
    i = Xi(i), e = Xi(e);
    for (var h = t.individualDelay, u = 0; u < r; u++) {
        var c = h ? at({
            delay: (t.delay || 0) + h(u, r, i[u], e[u])
        }, t) : t;
        au(i[u], e[u], c)
    }
    return {
        fromIndividuals: i,
        toIndividuals: e,
        count: e.length
    }
}

function Df(a) {
    return B(a[0])
}

function If(a, e) {
    for (var t = [], r = a.length, i = 0; i < r; i++) t.push({
        one: a[i],
        many: []
    });
    for (var i = 0; i < e.length; i++) {
        var n = e[i].length,
            o = void 0;
        for (o = 0; o < n; o++) t[o % r].many.push(e[i][o])
    }
    for (var s = 0, i = r - 1; i >= 0; i--)
        if (!t[i].many.length) {
            var l = t[s].many;
            if (l.length <= 1)
                if (s) s = 0;
                else return t;
            var n = l.length,
                u = Math.ceil(n / 2);
            t[i].many = l.slice(u, n), t[s].many = l.slice(0, u), s++
        } return t
}
var TP = {
    clone: function (a) {
        for (var e = [], t = 1 - Math.pow(1 - a.path.style.opacity, 1 / a.count), r = 0; r < a.count; r++) {
            var i = rl(a.path);
            i.setStyle("opacity", t), e.push(i)
        }
        return e
    },
    split: null
};

function Bo(a, e, t, r, i, n) {
    if (!a.length || !e.length) return;
    var o = Za("update", r, i);
    if (!(o && o.duration > 0)) return;
    var s = r.getModel("universalTransition").get("delay"),
        l = Object.assign({
            setToFinal: !0
        }, o),
        u, v;
    Df(a) && (u = a, v = e), Df(e) && (u = e, v = a);

    function h(y, x, m, S, _) {
        var b = y.many,
            w = y.one;
        if (b.length === 1 && !_) {
            var A = x ? b[0] : w,
                C = x ? w : b[0];
            if (Ui(A)) h({
                many: [A],
                one: C
            }, !0, m, S, !0);
            else {
                var D = s ? at({
                    delay: s(m, S)
                }, l) : l;
                au(A, C, D), n(A, C, A, C, D)
            }
        } else
            for (var I = at({
                    dividePath: TP[t],
                    individualDelay: s && function (V, O, z, $) {
                        return s(V + m, S)
                    }
                }, l), L = x ? wP(b, w, I) : AP(w, b, I), M = L.fromIndividuals, P = L.toIndividuals, R = M.length, k = 0; k < R; k++) {
                var D = s ? at({
                    delay: s(k, R)
                }, l) : l;
                n(M[k], P[k], x ? b[k] : y.one, x ? y.one : b[k], D)
            }
    }
    for (var c = u ? u === a : a.length > e.length, f = u ? If(v, u) : If(c ? e : a, [c ? a : e]), p = 0, d = 0; d < f.length; d++) p += f[d].many.length;
    for (var g = 0, d = 0; d < f.length; d++) h(f[d], c, g, p), g += f[d].many.length
}

function er(a) {
    if (!a) return [];
    if (B(a)) {
        for (var e = [], t = 0; t < a.length; t++) e.push(er(a[t]));
        return e
    }
    var r = [];
    return a.traverse(function (i) {
        i instanceof Pt && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i)
    }), r
}
var ny = 1e4,
    CP = 0,
    Lf = 1,
    Mf = 2,
    DP = xt();

function IP(a, e) {
    for (var t = a.dimensions, r = 0; r < t.length; r++) {
        var i = a.getDimensionInfo(t[r]);
        if (i && i.otherDims[e] === 0) return t[r]
    }
}

function LP(a, e, t) {
    var r = a.getDimensionInfo(t),
        i = r && r.ordinalMeta;
    if (r) {
        var n = a.get(r.name, e);
        return i && i.categories[n] || n + ""
    }
}

function Pf(a, e, t, r) {
    var i = r ? "itemChildGroupId" : "itemGroupId",
        n = IP(a, i);
    if (n) {
        var o = LP(a, e, n);
        return o
    }
    var s = a.getRawDataItem(e),
        l = r ? "childGroupId" : "groupId";
    if (s && s[l]) return s[l] + "";
    if (!r) return t || a.getId(e)
}

function Rf(a) {
    var e = [];
    return T(a, function (t) {
        var r = t.data,
            i = t.dataGroupId;
        if (!(r.count() > ny))
            for (var n = r.getIndices(), o = 0; o < n.length; o++) e.push({
                data: r,
                groupId: Pf(r, o, i, !1),
                childGroupId: Pf(r, o, i, !0),
                divide: t.divide,
                dataIndex: o
            })
    }), e
}

function Ho(a, e, t) {
    a.traverse(function (r) {
        r instanceof Pt && Yt(r, {
            style: {
                opacity: 0
            }
        }, e, {
            dataIndex: t,
            isFrom: !0
        })
    })
}

function Fo(a) {
    if (a.parent) {
        var e = a.getComputedTransform();
        a.setLocalTransform(e), a.parent.remove(a)
    }
}

function Lr(a) {
    a.stopAnimation(), a.isGroup && a.traverse(function (e) {
        e.stopAnimation()
    })
}

function MP(a, e, t) {
    var r = Za("update", t, e);
    r && a.traverse(function (i) {
        if (i instanceof hr) {
            var n = m0(i);
            n && i.animateFrom({
                style: n
            }, r)
        }
    })
}

function PP(a, e) {
    var t = a.length;
    if (t !== e.length) return !1;
    for (var r = 0; r < t; r++) {
        var i = a[r],
            n = e[r];
        if (i.data.getId(i.dataIndex) !== n.data.getId(n.dataIndex)) return !1
    }
    return !0
}

function oy(a, e, t) {
    var r = Rf(a),
        i = Rf(e);

    function n(m, S, _, b, w) {
        (_ || m) && S.animateFrom({
            style: _ && _ !== m ? W(W({}, _.style), m.style) : m.style
        }, w)
    }
    var o = !1,
        s = CP,
        l = Q(),
        u = Q();
    r.forEach(function (m) {
        m.groupId && l.set(m.groupId, !0), m.childGroupId && u.set(m.childGroupId, !0)
    });
    for (var v = 0; v < i.length; v++) {
        var h = i[v].groupId;
        if (u.get(h)) {
            s = Lf;
            break
        }
        var c = i[v].childGroupId;
        if (c && l.get(c)) {
            s = Mf;
            break
        }
    }

    function f(m, S) {
        return function (_) {
            var b = _.data,
                w = _.dataIndex;
            return S ? b.getId(w) : m ? s === Lf ? _.childGroupId : _.groupId : s === Mf ? _.childGroupId : _.groupId
        }
    }
    var p = PP(r, i),
        d = {};
    if (!p)
        for (var v = 0; v < i.length; v++) {
            var g = i[v],
                y = g.data.getItemGraphicEl(g.dataIndex);
            y && (d[y.id] = !0)
        }

    function x(m, S) {
        var _ = r[S],
            b = i[m],
            w = b.data.hostModel,
            A = _.data.getItemGraphicEl(_.dataIndex),
            C = b.data.getItemGraphicEl(b.dataIndex);
        if (A === C) {
            C && MP(C, b.dataIndex, w);
            return
        }
        A && d[A.id] || C && (Lr(C), A ? (Lr(A), Fo(A), o = !0, Bo(er(A), er(C), b.divide, w, m, n)) : Ho(C, w, m))
    }
    new Be(r, i, f(!0, p), f(!1, p), null, "multiple").update(x).updateManyToOne(function (m, S) {
        var _ = i[m],
            b = _.data,
            w = b.hostModel,
            A = b.getItemGraphicEl(_.dataIndex),
            C = Dt(G(S, function (D) {
                return r[D].data.getItemGraphicEl(r[D].dataIndex)
            }), function (D) {
                return D && D !== A && !d[D.id]
            });
        A && (Lr(A), C.length ? (T(C, function (D) {
            Lr(D), Fo(D)
        }), o = !0, Bo(er(C), er(A), _.divide, w, m, n)) : Ho(A, w, _.dataIndex))
    }).updateOneToMany(function (m, S) {
        var _ = r[S],
            b = _.data.getItemGraphicEl(_.dataIndex);
        if (!(b && d[b.id])) {
            var w = Dt(G(m, function (C) {
                    return i[C].data.getItemGraphicEl(i[C].dataIndex)
                }), function (C) {
                    return C && C !== b
                }),
                A = i[m[0]].data.hostModel;
            w.length && (T(w, function (C) {
                return Lr(C)
            }), b ? (Lr(b), Fo(b), o = !0, Bo(er(b), er(w), _.divide, A, m[0], n)) : T(w, function (C) {
                return Ho(C, A, m[0])
            }))
        }
    }).updateManyToMany(function (m, S) {
        new Be(S, m, function (_) {
            return r[_].data.getId(r[_].dataIndex)
        }, function (_) {
            return i[_].data.getId(i[_].dataIndex)
        }).update(function (_, b) {
            x(m[_], S[b])
        }).execute()
    }).execute(), o && T(e, function (m) {
        var S = m.data,
            _ = S.hostModel,
            b = _ && t.getViewOfSeriesModel(_),
            w = Za("update", _, 0);
        b && _.isAnimationEnabled() && w && w.duration > 0 && b.group.traverse(function (A) {
            A instanceof Pt && !A.animators.length && A.animateFrom({
                style: {
                    opacity: 0
                }
            }, w)
        })
    })
}

function Ef(a) {
    var e = a.getModel("universalTransition").get("seriesKey");
    return e || a.id
}

function kf(a) {
    return B(a) ? a.sort().join(",") : a
}

function Pe(a) {
    if (a.hostModel) return a.hostModel.getModel("universalTransition").get("divideShape")
}

function RP(a, e) {
    var t = Q(),
        r = Q(),
        i = Q();
    return T(a.oldSeries, function (n, o) {
        var s = a.oldDataGroupIds[o],
            l = a.oldData[o],
            u = Ef(n),
            v = kf(u);
        r.set(v, {
            dataGroupId: s,
            data: l
        }), B(u) && T(u, function (h) {
            i.set(h, {
                key: v,
                dataGroupId: s,
                data: l
            })
        })
    }), T(e.updatedSeries, function (n) {
        if (n.isUniversalTransitionEnabled() && n.isAnimationEnabled()) {
            var o = n.get("dataGroupId"),
                s = n.getData(),
                l = Ef(n),
                u = kf(l),
                v = r.get(u);
            if (v) t.set(u, {
                oldSeries: [{
                    dataGroupId: v.dataGroupId,
                    divide: Pe(v.data),
                    data: v.data
                }],
                newSeries: [{
                    dataGroupId: o,
                    divide: Pe(s),
                    data: s
                }]
            });
            else if (B(l)) {
                var h = [];
                T(l, function (p) {
                    var d = r.get(p);
                    d.data && h.push({
                        dataGroupId: d.dataGroupId,
                        divide: Pe(d.data),
                        data: d.data
                    })
                }), h.length && t.set(u, {
                    oldSeries: h,
                    newSeries: [{
                        dataGroupId: o,
                        data: s,
                        divide: Pe(s)
                    }]
                })
            } else {
                var c = i.get(l);
                if (c) {
                    var f = t.get(c.key);
                    f || (f = {
                        oldSeries: [{
                            dataGroupId: c.dataGroupId,
                            data: c.data,
                            divide: Pe(c.data)
                        }],
                        newSeries: []
                    }, t.set(c.key, f)), f.newSeries.push({
                        dataGroupId: o,
                        data: s,
                        divide: Pe(s)
                    })
                }
            }
        }
    }), t
}

function Vf(a, e) {
    for (var t = 0; t < a.length; t++) {
        var r = e.seriesIndex != null && e.seriesIndex === a[t].seriesIndex || e.seriesId != null && e.seriesId === a[t].id;
        if (r) return t
    }
}

function EP(a, e, t, r) {
    var i = [],
        n = [];
    T(Wt(a.from), function (o) {
        var s = Vf(e.oldSeries, o);
        s >= 0 && i.push({
            dataGroupId: e.oldDataGroupIds[s],
            data: e.oldData[s],
            divide: Pe(e.oldData[s]),
            groupIdDim: o.dimension
        })
    }), T(Wt(a.to), function (o) {
        var s = Vf(t.updatedSeries, o);
        if (s >= 0) {
            var l = t.updatedSeries[s].getData();
            n.push({
                dataGroupId: e.oldDataGroupIds[s],
                data: l,
                divide: Pe(l),
                groupIdDim: o.dimension
            })
        }
    }), i.length > 0 && n.length > 0 && oy(i, n, r)
}

function kP(a) {
    a.registerUpdateLifecycle("series:beforeupdate", function (e, t, r) {
        T(Wt(r.seriesTransition), function (i) {
            T(Wt(i.to), function (n) {
                for (var o = r.updatedSeries, s = 0; s < o.length; s++)(n.seriesIndex != null && n.seriesIndex === o[s].seriesIndex || n.seriesId != null && n.seriesId === o[s].id) && (o[s][In] = !0)
            })
        })
    }), a.registerUpdateLifecycle("series:transition", function (e, t, r) {
        var i = DP(t);
        if (i.oldSeries && r.updatedSeries && r.optionChanged) {
            var n = r.seriesTransition;
            if (n) T(Wt(n), function (f) {
                EP(f, i, r, t)
            });
            else {
                var o = RP(i, r);
                T(o.keys(), function (f) {
                    var p = o.get(f);
                    oy(p.oldSeries, p.newSeries, t)
                })
            }
            T(r.updatedSeries, function (f) {
                f[In] && (f[In] = !1)
            })
        }
        for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], v = i.oldData = [], h = 0; h < s.length; h++) {
            var c = s[h].getData();
            c.count() < ny && (l.push(s[h]), u.push(s[h].get("dataGroupId")), v.push(c))
        }
    })
}
j([Sx]);
j([fx]);
j([Bx, x0, S0, yS, _0, v1, B1, C_, j_, nb, gb, xw, Uw, nA, TA, RA, KA, nT, mT, CT, NT, wC]);
j(UC);
j(AD);
j(ed);
j(HD);
j(Hd);
j(XD);
j(aI);
j(rL);
j(AL);
j(ja);
j($L);
j(YL);
j(sM);
j(yM);
j(TM);
j(EM);
j(YM);
j(d2);
j(Ug);
j(Yg);
j(B2);
j(Jg);
j(Qg);
j(Z2);
j(iP);
j(sP);
j(kP);
j(R0);
